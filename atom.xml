<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你好，我叫weking</title>
  
  <subtitle>不怕千万人阻挡，最怕自己会投降</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-24T14:11:50.572Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wekingtan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQLite 数据库</title>
    <link href="http://yoursite.com/2018/07/24/SQLite%20%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/07/24/SQLite 数据库/</id>
    <published>2018-07-24T14:06:22.000Z</published>
    <updated>2018-07-24T14:11:50.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQLiteOpenHelper"><a href="#SQLiteOpenHelper" class="headerlink" title="SQLiteOpenHelper"></a>SQLiteOpenHelper</h1><p>该类封装了 SQLite 数据库的创建和升级工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQLiteOpenHelper&quot;&gt;&lt;a href=&quot;#SQLiteOpenHelper&quot; class=&quot;headerlink&quot; title=&quot;SQLiteOpenHelper&quot;&gt;&lt;/a&gt;SQLiteOpenHelper&lt;/h1&gt;&lt;p&gt;该类封装了 SQLite 数
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="SQLite" scheme="http://yoursite.com/tags/SQLite/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>初探 Retrofit 2.0</title>
    <link href="http://yoursite.com/2018/07/20/%E5%88%9D%E6%8E%A2%20Retrofit%202.0/"/>
    <id>http://yoursite.com/2018/07/20/初探 Retrofit 2.0/</id>
    <published>2018-07-20T14:52:30.000Z</published>
    <updated>2018-07-20T14:59:02.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/carson_ho/article/details/73732076" target="_blank" rel="noopener">这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/carson_ho/article/details/73732076&quot; tar
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Retrofit 2.0" scheme="http://yoursite.com/tags/Retrofit-2-0/"/>
    
  </entry>
  
  <entry>
    <title>初探 RxJava 2</title>
    <link href="http://yoursite.com/2018/07/20/%E5%88%9D%E6%8E%A2%20RxJava%202/"/>
    <id>http://yoursite.com/2018/07/20/初探 RxJava 2/</id>
    <published>2018-07-20T14:52:03.000Z</published>
    <updated>2018-07-20T14:58:55.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/0cd258eecf60" target="_blank" rel="noopener">这可能是最好的RxJava 2.x 教程（完结版）</a></p><p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/0cd258eecf60&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>友盟练习</title>
    <link href="http://yoursite.com/2018/07/20/%E5%8F%8B%E7%9B%9F%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/07/20/友盟练习/</id>
    <published>2018-07-20T14:49:12.000Z</published>
    <updated>2018-07-21T08:47:14.915Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.umeng.com/sdk" target="_blank" rel="noopener">友盟 + SDK</a></p><h1 id="Common-集成"><a href="#Common-集成" class="headerlink" title="Common 集成"></a>Common 集成</h1><h2 id="自动集成"><a href="#自动集成" class="headerlink" title="自动集成"></a>自动集成</h2><p>在 app 的 build.gradle 中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.umeng.sdk:common:latest.integration'</span></span><br><span class="line">compile <span class="string">'com.umeng.sdk:utdid:1.1.5.3'</span></span><br></pre></td></tr></table></figure><p>如果无法正常集成则在 project 的 build.gradle 中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">            mavenCentral()     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Android Studio 3.1 及以上版本开发环境下，指定引用最新版本依赖写法 <code>latest.integration</code> 可能导致下载库超时，此时需要指定具体版本号。 </p><h2 id="手动集成"><a href="#手动集成" class="headerlink" title="手动集成"></a>手动集成</h2><ul><li>选择 SDK 功能组件并下载后，解压.zip文件得到相应组件包（例如：umeng-common-x.x.x.jar、umeng-analytics-x.x.x.jar等），在 Android Studio 的项目工程 libs 目录中拷入相关组件jar包；</li><li>右键 Android Studio 的项目工程 —&gt; 选择 <code>Open Module Settings</code> —&gt; 在  <code>Project Structure</code> 弹出框中 —&gt; 选择 <code>Dependencies</code>选项卡 —&gt; 点击左下“＋” —&gt; 选择组件包类型 —&gt; 引入相应的组件包；</li></ul><p>注意：umeng-common-x.x.x.jar为基础组件包，必须导入。 </p><h2 id="权限授予"><a href="#权限授予" class="headerlink" title="权限授予"></a>权限授予</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 必须的权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 推荐的权限 --&gt;</span><br><span class="line">&lt;!-- 添加如下权限，以便使用更多的第三方SDK和更精准的统计数据 --&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_COARSE_LOCATION"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_FINE_LOCATION"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.CHANGE_WIFI_STATE"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="混淆设置"><a href="#混淆设置" class="headerlink" title="混淆设置"></a>混淆设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">umeng</span>.** </span>&#123;*;&#125;</span><br></pre></td></tr></table></figure><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><h2 id="初始化及通用接口"><a href="#初始化及通用接口" class="headerlink" title="初始化及通用接口"></a>初始化及通用接口</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在项目工程中新建自定义 application 中的 <code>onCreate()</code> 中添加以下两个方法之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UMApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">//doSomething……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：一定要在主进程进行该项操作，如果您使用到 PUSH （消息推送），还需在推送进程（channel 进程）同样进行该项操作。</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化common库</span></span><br><span class="line"><span class="comment">* 参数1:上下文，不能为空</span></span><br><span class="line"><span class="comment">* 参数2:设备类型，UMConfigure.DEVICE_TYPE_PHONE为手机、</span></span><br><span class="line"><span class="comment">* UMConfigure.DEVICE_TYPE_BOX为盒子，默认为手机</span></span><br><span class="line"><span class="comment">* 参数3:Push推送业务的secret</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UMConfigure.init(<span class="keyword">this</span>, UMConfigure.DEVICE_TYPE_PHONE, <span class="string">" push secret number</span></span><br><span class="line"><span class="string">                 "</span>);</span><br></pre></td></tr></table></figure><ul><li>如果项目的 AndroidManifest 文件中已经配置【友盟+】的 AppKey 和 Channel，则使用该方法初始化，同时不必再次传入 AppKey 和 Channel 两个参数。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data </span><br><span class="line">android:value=<span class="string">"58edcfeb310c93091c000be2"</span> android:name=<span class="string">"UMENG_APPKEY"</span>/&gt;</span><br><span class="line">&lt;meta-data </span><br><span class="line">android:value=<span class="string">"Umeng"</span> android:name=<span class="string">"UMENG_CHANNEL"</span>/&gt;</span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化common库</span></span><br><span class="line"><span class="comment">* 参数1:上下文，不能为空</span></span><br><span class="line"><span class="comment">* 参数2:【友盟+】 AppKey</span></span><br><span class="line"><span class="comment">* 参数3:【友盟+】 Channel</span></span><br><span class="line"><span class="comment">* 参数4:设备类型，UMConfigure.DEVICE_TYPE_PHONE为手机、UMConfigure.DEVICE_TYPE_BOX为盒子，默认为手机</span></span><br><span class="line"><span class="comment">* 参数5:Push推送业务的secret</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UMConfigure.init(<span class="keyword">this</span>, <span class="string">"58edcfeb310c93091c000be2"</span>, <span class="string">"Umeng"</span>, UMConfigure.DEVICE_TYPE_PHONE, <span class="string">"1fe6a20054bcef865eeb0991ee84525b"</span>);</span><br></pre></td></tr></table></figure><h4 id="Channel渠道的使用规范"><a href="#Channel渠道的使用规范" class="headerlink" title="Channel渠道的使用规范"></a>Channel渠道的使用规范</h4><p>每台设备仅记录首次安装激活的渠道，在其他渠道再次安装不会重复计量。 所以在测试不同的渠道的时候，请使用不同的设备来分别测试不要改变’UMENG_CHANNEL’。 </p><h4 id="Channel渠道的命名规范"><a href="#Channel渠道的命名规范" class="headerlink" title="Channel渠道的命名规范"></a>Channel渠道的命名规范</h4><p>1.可以由英文字母、阿拉伯数字、下划线、中划线、空格、括号组成，可以含汉字以及其他明文字符，但是不建议使用中文命名，会出现乱码。</p><p>2.首尾字符不可以为空格。</p><p>3.不要使用纯数字作为渠道ID。</p><p>4.最多256个字符。</p><p>5.”unknown” 及其各种大小写形式，作为【友盟+】保留的字段，不可以作为渠道名。</p><p>在您查看数据时，渠道会作为一个数据细分的维度。</p><h3 id="通用接口"><a href="#通用接口" class="headerlink" title="通用接口"></a>通用接口</h3><h4 id="设置Log开关"><a href="#设置Log开关" class="headerlink" title="设置Log开关"></a>设置Log开关</h4><p>初始化时可以通过该方法设置组件化的 Log 是否输出，默认关闭 Log 输出。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置组件化的Log开关</span></span><br><span class="line"><span class="comment">* 参数: boolean 默认为false，如需查看LOG设置为true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UMConfigure.setLogEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h4 id="设置日志加密"><a href="#设置日志加密" class="headerlink" title="设置日志加密"></a>设置日志加密</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置日志加密</span></span><br><span class="line"><span class="comment">* 参数：boolean 默认为false（不加密）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UMConfigure.setEncryptEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><ul><li>如果参数为true，SDK会对日志进行加密。加密模式可以有效防止网络攻击，提高数据安全性。 </li><li>如果参数为false，SDK将按照非加密的方式来传输日志。</li><li>如果您没有设置加密模式，SDK的加密模式为false（不加密）。</li></ul><h1 id="移动统计集成"><a href="#移动统计集成" class="headerlink" title="移动统计集成"></a>移动统计集成</h1><h2 id="自动集成-1"><a href="#自动集成-1" class="headerlink" title="自动集成"></a>自动集成</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'com.umeng.sdk:common:latest.integration'</span></span><br><span class="line">    compile <span class="string">'com.umeng.sdk:analytics:latest.integration'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手动集成-1"><a href="#手动集成-1" class="headerlink" title="手动集成"></a>手动集成</h2><p>将下载的SDK zip包解压缩，得到如下文件：</p><ul><li>common/common_android_x.x.x/normal/umeng-common-x.x.x.jar // 基础组件包</li><li>analytics/analytics_android_x.x.x/umeng-analytics-x.x.x.jar // 统计SDK包</li><li>thirdparties/thirdparties_android_1.x.x/utdid4all-1.x.x.x_proguard.jar // 包含设备标识UTDID组件</li><li>thirdparties/thirdparties_android_x.x.x/SecurityEnvSDK/<em>.</em> // 金融风控组件，包含一个jar包和多个so库</li></ul><p>集成步骤：</p><ul><li>选择SDK功能组件并下载，解压.zip文件得到相应组件包（例如：umeng-common-x.x.x.jar、umeng-analytics-x.x.x.jar等），在Android Studio的项目工程libs目录中拷入相关组件jar包。</li><li>右键Android Studio的项目工程 —&gt; 选择Open Module Settings —&gt; 在  Project Structure弹出框中 —&gt; 选择 Dependencies选项卡 —&gt; 点击左下“＋” —&gt;  选择组件包类型 —&gt; 引入相应的组件包。</li></ul><blockquote><p>注意：umeng-common-x.x.x.jar为基础组件包，必须导入。</p></blockquote><h2 id="初始化及通用接口-1"><a href="#初始化及通用接口-1" class="headerlink" title="初始化及通用接口"></a>初始化及通用接口</h2><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>在宿主应用application.onCreate函数中调用基础组件包提供的初始化函数： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意: 即使您已经在AndroidManifest.xml中配置过appkey和channel值，也需要在App代码中调用初始化接口（如需要使用AndroidManifest.xml中配置好的appkey和channel值，UMConfigure.init调用中appkey和channel参数请置为null）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UMConfigure.init(Context context, String appkey, String channel, <span class="keyword">int</span> deviceType, String pushSecret);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：如果您已经在AndroidManifest.xml中配置过appkey和channel值，可以调用此版本初始化函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UMConfigure.init(Context context, <span class="keyword">int</span> deviceType, String pushSecret);</span><br></pre></td></tr></table></figure><h3 id="设置场景类型接口"><a href="#设置场景类型接口" class="headerlink" title="设置场景类型接口"></a>设置场景类型接口</h3><p>在初始化的 Activity 中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MobclickAgent.setScenarioType(mContext, EScenarioType.E_UM_NORMAL);</span><br></pre></td></tr></table></figure><ul><li><p>context： 当前宿主进程的ApplicationContext上下文。 </p></li><li><p>etype ： EScenarioType.E_UM_NORMAL 普通统计场景，如果您在埋点过程中没有使用到 U-Game统计接口，请使用普通统计场景。   EScenarioType.E_UM_GAME 游戏场景 ，如果您在埋点过程中需要使用到U-Game 统计接口，则必须设置游戏场景，否则所有的U-Game统计接口不会生效。 </p></li></ul><h3 id="设置-secretkey"><a href="#设置-secretkey" class="headerlink" title="设置 secretkey"></a>设置 secretkey</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MobclickAgent.setSecret(mContext, <span class="string">"s10bacedtyz"</span>);</span><br></pre></td></tr></table></figure><ul><li>context ：当前宿主进程的ApplicationContext上下文。 </li><li>secretkey ：secretkey需要在【友盟+】网站申请。 </li></ul><h3 id="设置-Session-启动、App-使用时长等基础数据统计接口-API"><a href="#设置-Session-启动、App-使用时长等基础数据统计接口-API" class="headerlink" title="设置 Session 启动、App 使用时长等基础数据统计接口 API:"></a>设置 Session 启动、App 使用时长等基础数据统计接口 API:</h3><p>在 App 中每个 Activity 的 onResume 方法中调用 MobclickAgent.onResume(context)，在 onPause 方法中调用 MobclickAgent.onPause(context)。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    MobclickAgent.onResume(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    MobclickAgent.onPause(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>确保在所有的Activity中都调用 MobclickAgent.onResume() 和onPause()方法，这两个调用不会阻塞应用程序的主线程，也不会影响应用程序的性能。</li><li>注意：如果您的Activity之间有继承或者控制关系，请不要同时在父和子Activity中重复添加nPause和nResume方法，否则会造成重复统计，导致启动次数异常增高。(例如：使用TabHost、TabActivity、ActivityGroup时)。</li><li>当应用在后台运行超过30秒（默认）再回到前台，将被认为是两次独立的Session(启动)，例如：用户回到home，或进入其他程序，经过一段时间后再返回之前的应用。即被认为是两个独立的Session。</li></ul><h3 id="设置-session-间隔时长接口"><a href="#设置-session-间隔时长接口" class="headerlink" title="设置 session 间隔时长接口"></a>设置 session 间隔时长接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将默认Session间隔时长改为40秒。</span></span><br><span class="line">MobclickAgent.setSessionContinueMillis(<span class="number">1000</span>*<span class="number">40</span>);</span><br></pre></td></tr></table></figure><h1 id="消息推送集成"><a href="#消息推送集成" class="headerlink" title="消息推送集成"></a>消息推送集成</h1><h2 id="在友盟创建应用"><a href="#在友盟创建应用" class="headerlink" title="在友盟创建应用"></a>在友盟创建应用</h2><p>在 <a href="http://message.umeng.com" target="_blank" rel="noopener">http://message.umeng.com</a> 上使用你的应用包名创建应用（注：Android Studio请使用 <code>applicationId</code> 作为包名）。 </p><h2 id="自动集成-2"><a href="#自动集成-2" class="headerlink" title="自动集成"></a>自动集成</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PushSDK必须依赖基础组件库，所以需要加入对应依赖</span></span><br><span class="line">compile <span class="string">'com.umeng.sdk:common:1.5.3'</span></span><br><span class="line"><span class="comment">//PushSDK必须依赖utdid库，所以需要加入对应依赖</span></span><br><span class="line">compile <span class="string">'com.umeng.sdk:utdid:1.1.5.3'</span></span><br><span class="line"><span class="comment">//PushSDK</span></span><br><span class="line">compile <span class="string">'com.umeng.sdk:push:4.2.0'</span></span><br></pre></td></tr></table></figure><h2 id="手动集成-2"><a href="#手动集成-2" class="headerlink" title="手动集成"></a>手动集成</h2><ul><li>访问友盟+官网组件化 SDK 下载地址，选择 Android 平台<a href="http://developer.umeng.com/sdk" target="_blank" rel="noopener">下载</a>页面，选择对应业务 SDK 进行下载，并把下载的 zip 文件解压缩（解压后的文件路径不能有中文）；</li><li>把解压缩后得到的目录下的<code>thirdparties</code>目录里的<code>utdid4all-*.*.*</code>这个 jar 文件拷贝到项目工程的 libs 目录；</li><li>把解压缩后得到的目录下的<code>push</code>目录当做 Module 导入到自己的工程，使用 <code>Import Module</code>。</li><li>在 Application Module的build.gradle文件的<code>dependencies</code>下添加<code>implementation project(&#39;:push&#39;)</code>。 </li></ul><p>如果出现 <code>implementation project(&#39;:push&#39;)</code> 不成功，则查看在 <code>settings.gradle</code> 中是否包含有 <code>include &#39;:push&#39;</code> 。</p><blockquote><p><strong>注意：</strong></p><ul><li>PushSDK  4.0默认只提供armeabi和x86两种so文件夹，若主工程中的so文件夹与PushSDK下的so文件夹不一致，则可以有两种方式处理（选择一种即可）：(1)  删除主工程下多余的so文件夹，与PushSDK下的so文件夹保持一致。(2)  下载全平台so文件，添加缺少的so文件夹至PushSDK模块的libs目录下，使PushSDK的so文件夹与主工程的so文件夹保持一致。<a href="http://dev.umeng.com/system/resources/W1siZiIsIjIwMTcvMDMvMTQvMTBfMzdfNDBfMjg5X3NvX2FsbF9wbGF0Zm9ybXMuemlwIl1d/so_all_platforms.zip" target="_blank" rel="noopener">全平台SO文件下载</a></li></ul></blockquote><h2 id="初始化及通用接口-2"><a href="#初始化及通用接口-2" class="headerlink" title="初始化及通用接口"></a>初始化及通用接口</h2><h2 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h2><p>在工程的自定义Application类的 <code>onCreate()</code> 方法中调用基础组件包提供的初始化函数。 </p><p>方法一：</p><p>仅使用代码初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UMConfigure.init(Context context, String appkey, String channel, int deviceType, String pushSecret);</span><br></pre></td></tr></table></figure><p>方法二：</p><p>如果在AndroidManifest.xml中配置appkey和channel值，可以调用此版本初始化函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UMConfigure.init(Context context, int deviceType, String pushSecret);</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data    </span><br><span class="line">android:name=&quot;UMENG_APPKEY&quot;    </span><br><span class="line">android:value=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; /&gt;</span><br><span class="line">&lt;!-- Channel ID用来标识App的推广渠道，作为推送消息时给用户分组的一个维度。--&gt;&lt;meta-data    </span><br><span class="line">android:name=&quot;UMENG_CHANNEL&quot;    </span><br><span class="line">android:value=&quot;Channel ID&quot; /&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong></p><ul><li>若同时在AndroidManifest.xml和代码中设置了Channel，则以代码设置的为准。</li><li>若在AndroidManifest.xml和代码里均没有设置，则使用Unknown作为Channel ID。</li><li>你可以使用20位以内的英文和数字为渠道定名（不要使用纯数字）。</li><li><strong>每台设备仅识别首次安装激活的渠道。</strong></li></ul></blockquote><h2 id="注册推送服务"><a href="#注册推送服务" class="headerlink" title="注册推送服务"></a>注册推送服务</h2><p><code>务必</code>在工程的自定义 Application 类的 <code>onCreate()</code> 方法中注册推送服务，无论推送是否开启都需要调用此方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PushAgent mPushAgent = PushAgent.getInstance(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//注册推送服务，每次调用register方法都会回调该接口</span></span><br><span class="line">mPushAgent.register(<span class="keyword">new</span> IUmengRegisterCallback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String deviceToken)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注册成功会返回device token</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(String s, String s1)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li><code>请勿在调用register方法时做进程判断处理（主进程和channel进程均需要调用register方法才能保证长连接的正确建立）。</code>若未按文档要求初始化，则会导致App运行时，弹出toast提示。此时，请参考下文解决。</li><li>device token是【友盟+】消息推送生成的用于标识设备的id，长度为44位，不能定制和修改。同一台设备上不同应用对应的device token不一样。</li><li>如需手动获取device token，可以调用<code>mPushAgent.getRegistrationId()</code>方法（需在注册成功后调用）。</li></ul></blockquote><h2 id="统计应用启动数据"><a href="#统计应用启动数据" class="headerlink" title="统计应用启动数据"></a>统计应用启动数据</h2><p>在所有的Activity 的<code>onCreate</code> 方法或在应用的<code>BaseActivity</code>的<code>onCreate</code>方法中添加： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushAgent.getInstance(context).onAppStart();</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li><code>此方法与统计分析sdk中统计日活的方法无关！请务必调用此方法！</code></li><li>如果不调用此方法，不仅会导致按照”几天不活跃”条件来推送失效，还将导致广播发送不成功以及设备描述红色等问题发生。可以只在应用的主Activity中调用此方法，但是由于SDK的日志发送策略，有可能由于主activity的日志没有发送成功，而导致未统计到日活数据。</li></ul></blockquote><h2 id="配置ApplicationId"><a href="#配置ApplicationId" class="headerlink" title="配置ApplicationId"></a>配置ApplicationId</h2><p>请确保Application Module的build.gradle文件中的<code>applicationId</code>与资源包名<code>package</code>一致（若不一致，请参考高级功能—自定义资源包名） </p><h1 id="社会化分享和第三方登录集成"><a href="#社会化分享和第三方登录集成" class="headerlink" title="社会化分享和第三方登录集成"></a>社会化分享和第三方登录集成</h1><h2 id="自动集成-3"><a href="#自动集成-3" class="headerlink" title="自动集成"></a>自动集成</h2><h2 id="手动集成-3"><a href="#手动集成-3" class="headerlink" title="手动集成"></a>手动集成</h2><ul><li>下载最新 SDK 文件；</li><li>将main文件夹以及platform（选择你想使用的平台即可）文件下，对应的 res 文件和 jar 文件放入你的工程；</li><li>记得同步 libs 文件。</li></ul><h2 id="添加回调-Activity"><a href="#添加回调-Activity" class="headerlink" title="添加回调 Activity"></a>添加回调 Activity</h2><h3 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h3><p>在包名目录下 com.xxx.xxx 创建wxapi文件夹，新建一个名为<code>WXEntryActivity</code>的activity继承<code>WXCallbackActivity</code> </p><h3 id="QQ-和新浪"><a href="#QQ-和新浪" class="headerlink" title="QQ 和新浪"></a>QQ 和新浪</h3><p>QQ与新浪不需要添加Activity，但需要在使用QQ分享或者授权的Activity中，添加： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        UMShareAPI.get(<span class="keyword">this</span>).onActivityResult(requestCode, resultCode, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>onActivityResult</code>不可在fragment中实现，如果在fragment中调用登录或分享，需要在fragment依赖的Activity中实现 </p><h2 id="配置-Android-Manifest-XML"><a href="#配置-Android-Manifest-XML" class="headerlink" title="配置 Android Manifest.XML"></a>配置 Android Manifest.XML</h2><h3 id="微信-1"><a href="#微信-1" class="headerlink" title="微信"></a>微信</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">           android:name=<span class="string">".wxapi.WXEntryActivity"</span></span><br><span class="line">           android:configChanges=<span class="string">"keyboardHidden|orientation|screenSize"</span></span><br><span class="line">           android:exported=<span class="string">"true"</span></span><br><span class="line">           android:theme=<span class="string">"@android:style/Theme.Translucent.NoTitleBar"</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="权限添加"><a href="#权限添加" class="headerlink" title="权限添加"></a>权限添加</h2><p>如果需要使用QQ纯图分享或避免其它平台纯图分享的时候图片不被压缩，可以增加以下权限： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;   </span><br><span class="line"> &lt;uses-permission android:name=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span><br></pre></td></tr></table></figure><h2 id="Android6-0权限适配"><a href="#Android6-0权限适配" class="headerlink" title="Android6.0权限适配"></a>Android6.0权限适配</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Build.VERSION.SDK_INT&gt;=<span class="number">23</span>)&#123;</span><br><span class="line">                  String[] mPermissionList = <span class="keyword">new</span> String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.ACCESS_FINE_LOCATION,Manifest.permission.CALL_PHONE,Manifest.permission.READ_LOGS,Manifest.permission.READ_PHONE_STATE, Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.SET_DEBUG_APP,Manifest.permission.SYSTEM_ALERT_WINDOW,Manifest.permission.GET_ACCOUNTS,Manifest.permission.WRITE_APN_SETTINGS&#125;;</span><br><span class="line">                  ActivityCompat.requestPermissions(<span class="keyword">this</span>,mPermissionList,<span class="number">123</span>);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        String permissions[], <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h2><p>初始化需要在您的 Application 中调用我们的初始化接口： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        UMConfigure.init(<span class="keyword">this</span>,<span class="string">"5a12384aa40fa3551f0001d1"</span></span><br><span class="line">                ,<span class="string">"umeng"</span>,UMConfigure.DEVICE_TYPE_PHONE,<span class="string">""</span>);<span class="comment">//58edcfeb310c93091c000be2 5965ee00734be40b580001a0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并且设置各个平台的 appkey</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    PlatformConfig.setWeixin(…………);</span><br><span class="line">    PlatformConfig.setSinaWeibo(…………);</span><br><span class="line">    ……………………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="签名配置"><a href="#签名配置" class="headerlink" title="签名配置"></a>签名配置</h2><h2 id="分享面板设置"><a href="#分享面板设置" class="headerlink" title="分享面板设置"></a>分享面板设置</h2><p>在需要引用 activity 中设置。</p><h3 id="带面板"><a href="#带面板" class="headerlink" title="带面板"></a>带面板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ShareAction(MainActivity.<span class="keyword">this</span>).withText(<span class="string">"hello"</span>)                    .setDisplayList(SHARE_MEDIA.SINA,SHARE_MEDIA.QQ,SHARE_MEDIA.WEIXIN)</span><br><span class="line">.setCallback(umShareListener).open();</span><br></pre></td></tr></table></figure><h3 id="不带面板"><a href="#不带面板" class="headerlink" title="不带面板"></a>不带面板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ShareAction(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">.setPlatform(SHARE_MEDIA.QQ)<span class="comment">//传入平台</span></span><br><span class="line">.withText(<span class="string">"hello"</span>)<span class="comment">//分享内容</span></span><br><span class="line">.setCallback(umShareListener)<span class="comment">//回调监听器</span></span><br><span class="line">.share();</span><br></pre></td></tr></table></figure><h3 id="回调监听"><a href="#回调监听" class="headerlink" title="回调监听"></a>回调监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> UMShareListener shareListener = <span class="keyword">new</span> UMShareListener() &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@descrption</span> 分享开始的回调</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> platform 平台类型</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(SHARE_MEDIA platform)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@descrption</span> 分享成功的回调</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> platform 平台类型</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(SHARE_MEDIA platform)</span> </span>&#123;</span><br><span class="line">           Toast.makeText(ShareDetailActivity.<span class="keyword">this</span>,<span class="string">"成功                                        了"</span>,Toast.LENGTH_LONG).show()；</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@descrption</span> 分享失败的回调</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> platform 平台类型</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> t 错误原因</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(SHARE_MEDIA platform, Throwable t)</span> </span>&#123;</span><br><span class="line">           Toast.makeText(ShareDetailActivity.<span class="keyword">this</span>,<span class="string">"失                                            败"</span>+t.getMessage(),Toast.LENGTH_LONG).show();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@descrption</span> 分享取消的回调</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> platform 平台类型</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(SHARE_MEDIA platform)</span> </span>&#123;</span><br><span class="line">           Toast.makeText(ShareDetailActivity.<span class="keyword">this</span>,<span class="string">"取消                                          了"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h2 id="第三方登录"><a href="#第三方登录" class="headerlink" title="第三方登录"></a>第三方登录</h2><p>第三方登录包含两种使用场景：</p><p>获取用户资料的授权接口，使用该接口可以获取该三方平台返回的所有资料（包括姓名，性别，头像等）目前支持第三方登录的平台包括：</p><ul><li>国内平台（微信、新浪微博、QQ、豆瓣、人人）</li><li>国外平台（Facebook、Twitter、linkedIn、kakao、VKontakte、Dropbox）</li></ul><p>这里推荐直接使用第一种方式实现，因为本质上三方登录最终都需要拉取三方平台的用户资料，从这点来说，直接调用SDK和通过后台服务器请求，安全性是一样的</p><h3 id="获取用户资料"><a href="#获取用户资料" class="headerlink" title="获取用户资料"></a>获取用户资料</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UMShareAPI.get(MainActivity.<span class="keyword">this</span>).getPlatformInfo(MainActivity.<span class="keyword">this</span>, SHARE_MEDIA.WEIXIN, umAuthListener);</span><br></pre></td></tr></table></figure><h3 id="授权回调"><a href="#授权回调" class="headerlink" title="授权回调"></a>授权回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">UMAuthListener authListener = <span class="keyword">new</span> UMAuthListener() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 授权开始的回调</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> platform 平台名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(SHARE_MEDIA platform)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 授权成功的回调</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> platform 平台名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> action 行为序号，开发者用不上</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> data 用户资料返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(SHARE_MEDIA platform, <span class="keyword">int</span> action, Map&lt;String, String&gt; data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Toast.makeText(mContext, <span class="string">"成功了"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 授权失败的回调</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> platform 平台名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> action 行为序号，开发者用不上</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t 错误原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(SHARE_MEDIA platform, <span class="keyword">int</span> action, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           Toast.makeText(mContext, <span class="string">"失败："</span> + t.getMessage(),                                     Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span> 授权取消的回调</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> platform 平台名称</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> action 行为序号，开发者用不上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(SHARE_MEDIA platform, <span class="keyword">int</span> action)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(mContext, <span class="string">"取消了"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>登录成功后，第三方平台会将用户资料传回， <strong>全部会在Map data中返回</strong> ，由于各个平台对于用户资料的标识不同，因此为了便于开发者使用，我们将一些常用的字段做了统一封装，开发者可以直接获取，不再需要对不同平台的不同字段名做转换，这里列出我们封装的字段及含义。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.umeng.com/sdk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;友盟 + SDK&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Common-集成&quot;&gt;&lt;a href=&quot;#Common-集成&quot; class=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="友盟" scheme="http://yoursite.com/tags/%E5%8F%8B%E7%9B%9F/"/>
    
  </entry>
  
  <entry>
    <title>内存优化与内存泄露</title>
    <link href="http://yoursite.com/2018/07/19/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2018/07/19/内存优化与内存泄露/</id>
    <published>2018-07-19T03:25:53.000Z</published>
    <updated>2018-07-19T16:14:59.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对象在内存 heap 堆中分配的空间，当不再使用或没有引用指向的情况下，仍不能被垃圾收集器 GC 正常回收的情况。</p><ul><li>多数出现在不合理的编码情况下，Android 中常见就是 Activity 被引用，但在调用 finish 之后却没有释放，第二次打开 activity又重新创建，这样的内存泄漏不断的发生，则会导致内存的溢出。 </li><li>比如在 Activity 中注册了一个广播接收器，但是在页面关闭的时候没有进行unRegister，就会出现内存溢出的现象。通常情况下，大量的内存泄漏会造成 OOM。</li></ul><h2 id="OOM（内存溢出）"><a href="#OOM（内存溢出）" class="headerlink" title="OOM（内存溢出）"></a>OOM（内存溢出）</h2><p>即 Out Of Memoery，顾名思义就是指内存溢出了。</p><p>Android 的每个应用程序都会使用一个专有的 Dalvik 虚拟机实例来运行，它是由 Zygote 服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。 Android 为不同类型的进程分配了不同的内存使用上限 。</p><p>APP 向系统申请超过最大阀值的内存请求，但系统不会再分配多余的空间，就会造成OOM error。在我们 Android 平台下，多数情况是出现在图片不当处理加载的时候。  </p><a id="more"></a><h1 id="Android-内存管理"><a href="#Android-内存管理" class="headerlink" title="Android 内存管理"></a>Android 内存管理</h1><p>Android 应用层是由 java 开发的，Android 的 davlik 虚拟机与 jvm 也类似，只不过它是<code>基于寄存器</code>的。</p><p>在 java 中，通过 new 为对象分配内存，所有对象在 java 堆内分配空间；而内存的释放是由垃圾收集器（GC）来回收的。 </p><p>Java采用了有向图的原理。Java 将引用关系考虑为图的有向边，有向边从引用者指向引用对象。</p><p>线程对象可以作为有向图的起始顶点，该图就是从起始顶点(GC roots)开始的一棵树，根顶点可以到达的对象都是有效对象，GC 不会回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。  </p><h1 id="Android-内存优化的关键点"><a href="#Android-内存优化的关键点" class="headerlink" title="Android 内存优化的关键点"></a>Android 内存优化的关键点</h1><h2 id="万恶的-static"><a href="#万恶的-static" class="headerlink" title="万恶的 static"></a>万恶的 static</h2><p>由于 static 声明变量的生命周期其实是和 APP 的生命周期一 样的，有点类似于 Application<strong>。</strong>如果大量使用的话，就会占据内存空间不释放，积少成多也会造成内存的不断开销，直至挂掉。</p><p>static 的合理使用一般用来修饰基本数据类型或者轻量级对象，尽量避免修饰集合或者大对象，常用作修饰全局配置项、工具类方法、内部类。</p><h2 id="无关引用"><a href="#无关引用" class="headerlink" title="无关引用"></a>无关引用</h2><p>很多情况下，我们需求用到传递引用，但是我们无法确保引用传递出去后能否及时的回收。</p><p>比较有代表性的 Context 泄漏，很多情况下当 Activity 结束后，由于仍被其他的对象指向导致一直迟迟不能回收，这就造成了内存泄漏。这时可以考虑第三条建议。</p><p>不要让生命周期长于Activity 的对象持有到 Activity 的引用 。</p><h2 id="善用-SoftReference-WeakReference-LruCache"><a href="#善用-SoftReference-WeakReference-LruCache" class="headerlink" title="善用 SoftReference/WeakReference/LruCache"></a>善用 SoftReference/WeakReference/LruCache</h2><p>Java、Android 中有没有这样一种机制呢，当内存吃紧或者 GC 扫过的情况下，就能及时把一些内存占用给释放掉，从而分配给需要分配的地方。答案是肯定的，java 为我们提供了两个解决方案：</p><ul><li>如果对内存的开销比较关注的 APP，可以考虑使用 WeakReference，当 GC 回收扫过这块内存区域时就会回收；如果不是那么关注的话，可以使用 SoftReference，它会在内存申请不足的情况下自动释放，同样也能解决 OOM 问题；</li><li>Android 自 3.0 以后也推出了 LruCache 类，使用 LRU 算法释放内存，一样的能解决 OOM，如果兼容 3.0 以下的版本，请导入 v4 包。关于 第二条的无关引用的问题，我们传参可以考虑使用 WeakReference 包装一下。</li></ul><h2 id="谨慎-handler"><a href="#谨慎-handler" class="headerlink" title="谨慎 handler"></a>谨慎 handler</h2><p>在处理异步操作的时候，handler + thread 是个不错的选择。但是相信在使用 handler 的时候，大家都会遇到警告的情形，这个就是 lint 为开发者的提醒。handler 运行于 UI 线程，不断处理来自 MessageQueue 的消息，如果 handler 还有消息需要处理但是 Activity 页面已经结束的情况下，Activity 的引用其实并不会被回收，这就造成了内存泄漏。解决方案有 2 种：</p><ul><li><p>在 Activity 的 onDestroy 方法中调用 <code>handler.removeCallbacksAndMessages(null);</code> 取消所有的消息的处理，包括待处理的消息；</p></li><li><p>声明handler的内部类为static。</p></li></ul><h2 id="Bitmap终极杀手"><a href="#Bitmap终极杀手" class="headerlink" title="Bitmap终极杀手"></a>Bitmap终极杀手</h2><p>Bitmap 的不当处理极可能造成 OOM，绝大多数情况都是因这个原因出现的。Bitamp 位图是 Android 中当之无愧的胖小子，所以在操作的时候当然是十分的小心了。由于 Dalivk 并不会主动的去回收，需要开发者在 Bitmap 不被使用的时候 recycle 掉。使用的过程中，及时释放是非常重要 的。同时如果需求允许，也可以去 BItmap 进行一定的缩放，通过 <code>BitmapFactory.Options</code> 的 <code>inSampleSize</code> 属性进行控制。 </p><p>如果仅仅只想获得 Bitmap 的属性，其实并不需要根据 BItmap 的像素去分配内存，只需在解析读取 Bmp 的时候使用 <code>BitmapFactory.Options</code> 的 <code>inJustDecodeBounds</code> 属性。</p><p>最后建议大家在加载网络图片的时候，使用软引用或者弱引用并进行本地缓存，推荐使用 <code>android-universal-imageloader</code> 或者 <code>xUtils</code>，牛人出品，必属精品。</p><h2 id="Cursor-和-I-O-流及时关闭"><a href="#Cursor-和-I-O-流及时关闭" class="headerlink" title="Cursor 和 I/O 流及时关闭"></a>Cursor 和 I/O 流及时关闭</h2><p>在查询 SQLite 数据库时，会返回一个 Cursor，当查询完毕后，及时关闭，这样就可以把查询的结果集及时给回收掉。</p><p>I/O 流操作完毕，读写结束，记得关闭。</p><h2 id="ListView-和-GridView-的-item-缓存"><a href="#ListView-和-GridView-的-item-缓存" class="headerlink" title="ListView 和 GridView 的 item 缓存"></a>ListView 和 GridView 的 item 缓存</h2><p>对于移动设备，尤其硬件参差不齐的 Android 生态，页面的绘制其实是很耗时的，findViewById 也是蛮慢的。所以不重用 View，在有列表的时候就尤为显著了，经常会出现滑动很卡的现象。</p><h2 id="页面背景和图片加载"><a href="#页面背景和图片加载" class="headerlink" title="页面背景和图片加载"></a>页面背景和图片加载</h2><p>在布局和代码中设置背景和图片的时候，如果是纯色，尽量使用 color；如果是规则图形，尽量使用 shape 画图；如果稍微复杂点，可以使用 9patch 图；如果不能使用 9patch 的情况下，针对几种主流分辨率的机型进行切图。</p><h2 id="BroadCastReceiver、Service"><a href="#BroadCastReceiver、Service" class="headerlink" title="BroadCastReceiver、Service"></a>BroadCastReceiver、Service</h2><p>绑定广播和服务，一定要记得在不需要的时候给解绑。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程不再需要继续执行的时候要记得及时关闭，开启线程数量不易过多，一般和自己机器内核数一样最好，推荐开启线程的时候，使用<code>线程池</code>。</p><h2 id="String-StringBuffer"><a href="#String-StringBuffer" class="headerlink" title="String/StringBuffer"></a>String/StringBuffer</h2><p>当有较多的字符创需要拼接的时候，推荐使用 StringBuffer。</p><h1 id="Android内存分配回收机制"><a href="#Android内存分配回收机制" class="headerlink" title="Android内存分配回收机制"></a>Android内存分配回收机制</h1><p>从宏观角度上来看Android系统可以分为三个层次</p><ul><li>Application Framework,</li><li>Dalvik 虚拟机</li><li>Linux内核。</li></ul><p>这三个层次都有各自内存相关工作：</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg%3D%3D&amp;mid=2653578816&amp;idx=1&amp;sn=20b6160e92167dde676561f3a43d0860&amp;scene=45#wechat_redirect" target="_blank" rel="noopener">Android 内存优化总结&amp;实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h2&gt;&lt;p&gt;对象在内存 heap 堆中分配的空间，当不再使用或没有引用指向的情况下，仍不能被垃圾收集器 GC 正常回收的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多数出现在不合理的编码情况下，Android 中常见就是 Activity 被引用，但在调用 finish 之后却没有释放，第二次打开 activity又重新创建，这样的内存泄漏不断的发生，则会导致内存的溢出。 &lt;/li&gt;
&lt;li&gt;比如在 Activity 中注册了一个广播接收器，但是在页面关闭的时候没有进行unRegister，就会出现内存溢出的现象。通常情况下，大量的内存泄漏会造成 OOM。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OOM（内存溢出）&quot;&gt;&lt;a href=&quot;#OOM（内存溢出）&quot; class=&quot;headerlink&quot; title=&quot;OOM（内存溢出）&quot;&gt;&lt;/a&gt;OOM（内存溢出）&lt;/h2&gt;&lt;p&gt;即 Out Of Memoery，顾名思义就是指内存溢出了。&lt;/p&gt;
&lt;p&gt;Android 的每个应用程序都会使用一个专有的 Dalvik 虚拟机实例来运行，它是由 Zygote 服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。 Android 为不同类型的进程分配了不同的内存使用上限 。&lt;/p&gt;
&lt;p&gt;APP 向系统申请超过最大阀值的内存请求，但系统不会再分配多余的空间，就会造成OOM error。在我们 Android 平台下，多数情况是出现在图片不当处理加载的时候。  &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>事件分发与滑动冲突</title>
    <link href="http://yoursite.com/2018/07/19/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%B8%8E%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
    <id>http://yoursite.com/2018/07/19/事件分发与滑动冲突/</id>
    <published>2018-07-19T03:25:24.000Z</published>
    <updated>2018-07-19T11:07:40.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h1><p>事件分发过程主要由 <code>dispatchTouchEvent</code>，<code>onInterceptTouchEvent</code> 和 <code>onTouchEvent</code> 三个方法共同完成：</p><ul><li>public boolean dispatchTouchEvent(MotionEvent ev)</li></ul><p>用来进行事件分发，如果事件能够传递给当前 view，则此方法一定调用，返回结果受当前 view 的 onTouchEvent 和下级 view 的 dispatchTouchEvent 方法影响，表示是否消耗了当前事件。</p><ul><li>public boolean onInterceptTouchEvent(MotionEvent event)</li></ul><p>在 dispatchTouchEvent 内部调用，用来判断是否拦截某个事件。</p><ul><li>public boolean onTouchEvent(MotionEvent event)</li></ul><p>在 dispatchTouchEvent 内部调用，用来处理点击事件，返回结果表示是否消耗了当前事件，如果不消耗则在同一事件序列中，当前 view 无法再次接受到事件。</p><a id="more"></a><p>点击事件达到顶级 View（一般为 ViewGroup ）后，会调用 viewGroup 的 <code>dispatchTouchEvent</code> 方法，</p><p>如果顶级 ViewGroup 的 <code>onInterceptTouchEvent</code> 返回 true，则事件由 ViewGroup 处理，这时如果 ViewGroup 的 mOnTouchListener 被设置，则 onTouch 会被调用，onTouch 若返回 true，ViewGroup 的 <code>onTouchEvent</code> 不会再被调用；若设置了 mOnClickListener，则 onClick 会被调用。</p><p>如果顶层 ViewGroup 不拦截事件即 <code>onInterceptTouchEvent</code> 返回 false，则事件传递给子 View，这时子 View 的 <code>dispatchTouchEvent</code> 会被调用，到此为止，事件已经从顶级 View 传递了下一层 View，如此循环，完成整个事件的分发。</p><p>如果一个 View 的 <code>onTouchEvent</code> 返回 false，那么它的父容器的 <code>onTouchEvent</code> 将会被调用，表示无法消耗（解决）事件，需要交给上级。</p><p>ViewGroup 默认不拦截任何事件，即 Android 源码中 ViewGroup 的 <code>onInterceptTouchEvent</code> 默认返回 false。</p><p>View 没有 <code>onInterceptTouchEvent</code> 方法，一旦有点击事件传递给它，那么它的 <code>onTouchEvent</code> 方法就会被调用。</p><p>伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result= <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(ev))&#123;</span><br><span class="line">         result = onTouchEvent(ev);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-19/3990920.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="http://pb849j3l9.bkt.clouddn.com/18-7-19/82960123.jpg" alt="如果事件不被中断，则整个事件流向是一个类 U 型图"></p><p><img src="http://pb849j3l9.bkt.clouddn.com/18-7-19/14811717.jpg" alt=""></p><h1 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h1><p>在界面中内外两层同时可以滑动，就产生了滑动冲突，如何解决滑动冲突呢？</p><p>常见的滑动冲突 场景 可分为以下 3 种：</p><ul><li>外部滑动方向和内部滑动方向不一致</li></ul><p>ViewPager 和Fragment 组成的页面中包括一个 ListView，这种情况是有滑动冲突的，但是 ViewPager 内部处理了这种滑动冲突，因此采用 ViewPager 时无须关注这个问题，如果采用的不是 ViewPager 而是 ScrollView，那就必须处理滑动冲突了，否则内外两层就只有一层能滑动。</p><ul><li>外部滑动方向和内部滑动方向一致</li></ul><p>内外两层在同一个方向都可以滑动，系统无法知道用户到底想让哪一层滑动。</p><ul><li>上面两种情况的嵌套</li></ul><p>比如 SlideMenu、ScrollView 和 ListView 三者同时出现。</p><h2 id="处理规则"><a href="#处理规则" class="headerlink" title="处理规则"></a>处理规则</h2><p>场景1：根据滑动是水平滑动还是竖直滑动来判断到底由谁来拦截事件。</p><p>场景2：虽然无法根据滑动方向来判断，但是这时一般在业务上有状态可以依赖，比如业务上有规定，当处于某种状态时需要外部 View 响应用户滑动，而处于另一种状态时需要内部 View 响应滑动。</p><p>场景3：其实很简单，结合场景 1 和场景 2 的处理规则，就能处理场景 3 的滑动冲突。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>外部拦截法</li></ul><p>点击事件先经过父容器的拦截处理，如果父容器需要响应就拦截，不需要就不拦截，拦截处理需要写在父容器的 <code>onInterceptTouchEvent</code> 方法里。</p><ul><li>内部拦截法 </li></ul><p>父容器不拦截任何事件，子 view 需要响应就直接消耗，否则就交由父容器处理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="noopener">图解 Android 事件分发机制</a></p><p><a href="https://www.jianshu.com/p/49c44652c3f4" target="_blank" rel="noopener">事件分发和滑动冲突知识点总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件分发机制&quot;&gt;&lt;a href=&quot;#事件分发机制&quot; class=&quot;headerlink&quot; title=&quot;事件分发机制&quot;&gt;&lt;/a&gt;事件分发机制&lt;/h1&gt;&lt;p&gt;事件分发过程主要由 &lt;code&gt;dispatchTouchEvent&lt;/code&gt;，&lt;code&gt;onInterceptTouchEvent&lt;/code&gt; 和 &lt;code&gt;onTouchEvent&lt;/code&gt; 三个方法共同完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public boolean dispatchTouchEvent(MotionEvent ev)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用来进行事件分发，如果事件能够传递给当前 view，则此方法一定调用，返回结果受当前 view 的 onTouchEvent 和下级 view 的 dispatchTouchEvent 方法影响，表示是否消耗了当前事件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public boolean onInterceptTouchEvent(MotionEvent event)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 dispatchTouchEvent 内部调用，用来判断是否拦截某个事件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public boolean onTouchEvent(MotionEvent event)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 dispatchTouchEvent 内部调用，用来处理点击事件，返回结果表示是否消耗了当前事件，如果不消耗则在同一事件序列中，当前 view 无法再次接受到事件。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="事件" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>热修复和增量更新</title>
    <link href="http://yoursite.com/2018/07/19/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%92%8C%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2018/07/19/热修复和增量更新/</id>
    <published>2018-07-19T03:24:54.000Z</published>
    <updated>2018-07-20T03:12:28.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/a4bf979cce3b" target="_blank" rel="noopener">Android热更新之初探</a></p><p><a href="https://help.aliyun.com/document_detail/65956.html?spm=a2c4g.11186631.6.539.F0JuPR#3.1%E3%80%81%E7%83%AD%E4%BF%AE%E5%A4%8D" target="_blank" rel="noopener">阿里巴巴热修复</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/a4bf979cce3b&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="热修复" scheme="http://yoursite.com/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="增量更新" scheme="http://yoursite.com/tags/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础</title>
    <link href="http://yoursite.com/2018/07/15/Java%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/15/Java 基础/</id>
    <published>2018-07-14T17:01:16.000Z</published>
    <updated>2018-07-17T15:53:43.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-主类结构"><a href="#Java-主类结构" class="headerlink" title="Java 主类结构"></a>Java 主类结构</h1><p>Java 程序的基本组成单元是<code>类</code>，<code>类体</code>中包括<code>属性</code>和<code>方法</code>。每个程序都必须包含一个 <code>main()</code> 方法，含有 main() 方法的类称为<code>主类</code>。</p><a id="more"></a><h2 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h2><p>语句 <code>package xxx</code> 为声明该类所在的包。</p><h2 id="声明成员变量和局部变量"><a href="#声明成员变量和局部变量" class="headerlink" title="声明成员变量和局部变量"></a>声明成员变量和局部变量</h2><p><code>全局变量（成员变量）</code>：类的属性；</p><p><code>局部变量</code>：方法中的属性；</p><h2 id="编写主方法"><a href="#编写主方法" class="headerlink" title="编写主方法"></a>编写主方法</h2><p><code>public static void main(String[] args) {……}</code> 方法是主类中的主方法。public 是<code>权限修饰符</code>、static 是<code>静态修饰符</code>、void 是<code>返回值修饰符</code>、String[] args 是一个<code>字符串类型的数组</code>。</p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>分为<code>数值型（整数类型、浮点类型）</code>、<code>字符型</code>、<code>布尔型</code>。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>整型数据在 Java 中有<code>十进制</code>、<code>八进制</code>、<code>十六进制</code>。其中八进制以<code>0</code>开头，十六进制以<code>0X</code>或<code>0x</code>开头。</p><p>整型数据根据所占内存大小不同（内存空间 8 位等于 1 字节），分为 <code>byte（8位）</code>、<code>short（16位）</code>、<code>int（32位）</code>、<code>long（64位）</code>。</p><p>变量取值范围超出就会报错。</p><p>对于 long 型值，若赋给的值大于 int 型的最大最小值，则需要在数字后面加 <code>L</code> 或 <code>l</code>。</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>浮点类型表示有小数部分的数字。分为<code>单精度浮点类型</code>和<code>双精度浮点类型</code>。</p><p>浮点数据根据所占内存大小不同（内存空间 8 位等于 1 字节），分为 <code>float（32位）</code>、<code>double（64位）</code>。</p><p>默认情况下，小数被看做是 <code>double 型</code>。</p><p>float 型小数，数字后面需要加 <code>F</code> 或 <code>f</code>。</p><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><h3 id="char-型"><a href="#char-型" class="headerlink" title="char 型"></a>char 型</h3><p>字符类型用于存储<code>单个字符</code>，占用内存空间 <code>16 位</code>（两个字节）。</p><p>在定义字符类型变量时，以单引号表示一个字符，双引号表示一个字符串。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>以反斜杠 <code>\</code> 开头，后跟一个或多个字符。</p><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>通过关键字 boolean 来定义布尔类型变量，只有 true 和 false。</p><h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><p>标识符由<code>任意顺序的字母</code>、<code>下划线</code>、<code>美元符号</code>、<code>数字组成</code>，并且第一个字符不能是数字，不能是关键字。</p><p>关键字是赋予特定意义的单词。</p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>声明变量时可以没有赋值，也可以直接赋给初值。</p><h2 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a>声明常量</h2><p>标准语法： <code>final 数据类型 常量名称[=值]</code></p><p>常量名通常使用大写字母表示。</p><p>当定义的 <code>final</code> 变量属于成员变量时，必须在定义时就设定它的初值，否则会编译错误。</p><h2 id="变量的有效范围"><a href="#变量的有效范围" class="headerlink" title="变量的有效范围"></a>变量的有效范围</h2><p>由于变量被定义出来后只是暂存在内存中，等到程序执行到某一个点，改变量会被释放掉。</p><p>根据变量的“有效范围”将变量分为 <code>“成员变量”</code> 和<code>“局部变量”</code>。</p><h3 id="成员变量（全局变量）"><a href="#成员变量（全局变量）" class="headerlink" title="成员变量（全局变量）"></a>成员变量（全局变量）</h3><p>类体中定义的变量称为成员变量，在整个类中都有效。分为<code>静态变量</code>和<code>实例变量</code>。</p><p>成员变量的类型前面加上关键字 <code>static</code>，则是静态变量。它的有效范围<code>可以跨类</code>，甚至可以达到<code>整个应用程序之内</code>。对于静态变量，除了在定义它的类内存取，还可以“类名.静态变量”方式在其他类内使用。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量是在类的方法体中定义的。只在当前代码块中有效。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="自增和自减运算符"><a href="#自增和自减运算符" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h2><p>是单目运算符。<br><code>++a（-a）</code> 表示在使用变量 a 之前，先使 a 的值加（减）1<br><code>a--（a-）</code> 表示在使用变量 a 之后，使 a 的值加（减）1</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>按位与 &amp;</p><p>按位或 |</p><p>按位取反 ~</p><p>按位异或 ^</p><p>移位操作 &lt;&lt; 左移  &gt;&gt; 右移  &gt;&gt;&gt; 无符号右移</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>使用格式： <code>条件式？值1：值2</code><br>等价于 if…else</p><h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>低精度数据类型向高精度数据类型转换，则永远不会溢出，永远成功；高精度数据类型向低精度数据类型转换，则有可能失败。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>低精度类型向高精度类型转换，系统自动执行。</p><p>精度从低到高： <code>byte &lt; short &lt; char &lt; int &lt; long &lt; float &lt; double</code></p><h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><p>高精度的变量的值赋给低精度的变量或取值范围超出变量时，必须使用显示类型转换（又称为强制类型转换）。</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h2><p>先判断，再循环</p><h2 id="do…while-循环语句"><a href="#do…while-循环语句" class="headerlink" title="do…while 循环语句"></a>do…while 循环语句</h2><p>先执行一次，再判断</p><h2 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h2><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p>for(表达式; 表达式2; 表达式3){<br>  语句序列<br>}</p><h3 id="foreach-语句"><a href="#foreach-语句" class="headerlink" title="foreach 语句"></a>foreach 语句</h3><p>for(元素变量 x : 遍历对象 obj){<br>  引用了 x 的 java 语句.<br>}</p><h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><p>包括：<code>控制循环变量的变化方式</code>、<code>控制循环的跳转</code>。<br>控制循环的跳转需要 break、continue 两个关键字。<code>break</code> 是中断循环，<code>continue</code> 是执行下一次循环。</p><h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p>break 可以跳出 switch 结构，也可以跳出当前循环体。若有循环嵌套，则 break 只会跳出包含它的最内层的循环结构，只跳出一层循环。</p><p>如果想让 break 跳出外层循环，则使用标签功能：<br>  标签 : 循环体{<br>    break 标签名<br>  }</p><h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><p>不是立即跳出循环体，而是跳过本次循环结束前的语句，回到循环的条件测试部分，重新开始执行循环。</p><p>对于 for 循环，首先执行循环的增量部分，再执行条件测试部分。对于 while 和 do…while 循环，则直接回到条件测试部分。</p><p>continue 同样支持标签功能。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="获取字符串信息"><a href="#获取字符串信息" class="headerlink" title="获取字符串信息"></a>获取字符串信息</h2><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><p>str.indexOf(substr) 用于返回参数字符串 substr 在指定字符串中首次出现的索引位置。如果没有检索到字符串 substr，则返回值是 -1。</p><blockquote><p>在计算机中 String 对象使用数组表示的。字符串的下标是 0~length()-1</p></blockquote><p>str.lastIndexOf(String str) 用于返回指定字符串最后一次出现的索引位置。如果参数是空字符串（””），则返回的结果是字符串的长度。</p><h3 id="获取指定索引位置的字符"><a href="#获取指定索引位置的字符" class="headerlink" title="获取指定索引位置的字符"></a>获取指定索引位置的字符</h3><p><code>str.charAt(int index)</code> 返回指定索引处的字符。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="获取子字符串"><a href="#获取子字符串" class="headerlink" title="获取子字符串"></a>获取子字符串</h3><p><code>str.substring(int beginIndex)</code> 返回的是从指定的索引位置开始截取知道该字符串结尾的子串。</p><p><code>substring(int beginIndex, int endIndex)</code> 返回的是字符串某一索引位置开始截取至某一索引位置结束的子串。</p><h3 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h3><p><code>str.trim()</code> 返回字符串的副本，忽略前导空格和尾部空格。</p><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p><code>str.replace(char oldChar, char newChar)</code> 将指定的字符或字符串所有都替换成新的字符或字符串。</p><h3 id="判断字符串的开始和结尾"><a href="#判断字符串的开始和结尾" class="headerlink" title="判断字符串的开始和结尾"></a>判断字符串的开始和结尾</h3><p><code>str.stratsWith(String prefix)</code> 判断当前字符串对象的前缀是否为参数指定的字符串。</p><p><code>str.endsWith(String suffix)</code> 判断当前字符串是否以给定的字符串结束。</p><h3 id="判断字符串是否相等"><a href="#判断字符串是否相等" class="headerlink" title="判断字符串是否相等"></a>判断字符串是否相等</h3><p>比较运算符 <code>==</code> 用于比较两个字符串的地址是否相同。即使两个字符串的内容相同，两个对象的内存地址是不相同的，返回 false。</p><p><code>str.equals(String otherstr)</code> 如果两个<code>字符串内容</code>相等（区分大小写），则返回 true。</p><p><code>str.equalsIgnoreCase(String otherstr)</code> 忽略大小写情况下，如果两个<code>字符串内容</code>相等，则返回 true。</p><h3 id="按字典顺序比较两个字符串"><a href="#按字典顺序比较两个字符串" class="headerlink" title="按字典顺序比较两个字符串"></a>按字典顺序比较两个字符串</h3><p><code>str.compareTo(String otherstr)</code> 按字典顺序比较两个字符串，基于字符串中各个字符的 <code>Unicode</code> 值。如果 String 对象位于参数字符串之前，则返回一个负整数；如果位于之后，则返回一个正整数；如果两者相等，则结果为 0。</p><h3 id="字母大小写转换"><a href="#字母大小写转换" class="headerlink" title="字母大小写转换"></a>字母大小写转换</h3><p><code>str.toLowerCase</code> 将原字符串中每个字符从<code>大写字母</code>等价转换为<code>小写字母</code>。</p><p><code>str.toUpperCase</code> 将原字符串中每个字符从<code>小写字母</code>等价转换为<code>大写字母</code>。</p><h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p>使用 <code>split()</code> 方法可以使字符串按指定的分割字符或字符串对内容进行分割，并将分割后的结果存放在<code>字符串数组</code>中。</p><p><code>str.split(String sign)</code> 根据给定的分隔符对字符串进行拆分。sign 为分割字符串的<code>分隔符</code>，也可以使用<code>正则表达式</code>。</p><p><code>str.split(String sign, int limit)</code> 根据给定的分隔符对字符串进行拆分，并限定拆分的次数。</p><blockquote><p>没有统一的对字符进行分割的符号，如果想定义多个分割符，可以使用符号 <code>|</code>。例如，<code>,|=</code> 表示分割符为 <code>,</code>和<code>=</code> 。</p></blockquote><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p><code>str.format(String format, Object…args)</code> 使用指定的<code>格式字符串</code>和参数返回一个格式化字符串，格式化后的新字符串使用本地默认的语言环境。</p><p><code>str.format(Local l, String format, Object…args)</code> </p><blockquote><p><code>l</code> : 格式化过程中要应用的语言环境。如果 l 为 <code>null</code>，则不进行本地化 。</p><p><code>format</code> : 格式字符串。</p><p><code>args</code> : 格式字符串中由格式说明符引用的参数。如果还有格式说明符以外的参数，则忽略这些额外的参数。此参数的数目是可变的，可以为 0 。</p></blockquote><h3 id="日期和时间字符串格式化"><a href="#日期和时间字符串格式化" class="headerlink" title="日期和时间字符串格式化"></a>日期和时间字符串格式化</h3><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();   <span class="comment">//创建 Date 对象 date</span></span><br><span class="line">String s = String.format(<span class="string">"%te"</span>, date);<span class="comment">//通过 format() 方法对 date 进行格式化</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/32299414.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/36628557.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="格式化常见的日期时间组合"><a href="#格式化常见的日期时间组合" class="headerlink" title="格式化常见的日期时间组合"></a>格式化常见的日期时间组合</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/20083769.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="常规类型格式化"><a href="#常规类型格式化" class="headerlink" title="常规类型格式化"></a>常规类型格式化</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/22126843.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><p>正则表达式用于判断语句中，用来检查某一字符串是否满足某一格式。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/94978002.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/19763480.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/69503230.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="字符串生成器"><a href="#字符串生成器" class="headerlink" title="字符串生成器"></a>字符串生成器</h2><p>使用 <code>+</code> 可以达到附加新字符或字符串的目的，但 <code>+</code> 会产生一个新的 String 实例，会在内存中创建新的字符串对象。</p><p>如果程序中频繁地附加字符串，建议使用 StringBuilder。</p><p>新创建的 StringBuilder 对象初始容量是 <code>16</code> 个字符，可以<code>自行指定初始长度</code>。如果附加的字符超过可容纳的长度，则 StringBuilder 对象将<code>自动增加长度</code>以容纳附加的字符。</p><h3 id="StringBuilder-方法"><a href="#StringBuilder-方法" class="headerlink" title="StringBuilder 方法"></a>StringBuilder 方法</h3><ul><li><code>append(content)</code> 用于向字符串生成器中追加内容；</li><li><code>insert(int offset, arg)</code> 用于向字符串生成器中的指定位置插入数据内容；</li><li><code>delete(int start, int end)</code> 用于移除此序列的字符串中的字符；（左闭右开）</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组的创建及应用"><a href="#一维数组的创建及应用" class="headerlink" title="一维数组的创建及应用"></a>一维数组的创建及应用</h2><h3 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h3><p>1、先声明，再用 new 运算符进行内存分配</p><p><strong>声明一维数组</strong>：</p><p><code>数组元素类型 数组名字[]</code> </p><p><code>数组元素类型[] 数组名字</code> </p><p><strong>为数组分配内存空间</strong>：</p><p><code>数组名字 = new 数组元素的类型[数组元素的个数]</code></p><p>假如创建的数组有 <code>5 个元素</code>，因此数组中元素的<code>下标为 0~4</code> 。</p><p>2、声明的同时为数组分配内存</p><p><code>数组元素的类型[] 数组名 = new 数组元素的类型[数组元素的个数]</code></p><h3 id="初始化一维数组"><a href="#初始化一维数组" class="headerlink" title="初始化一维数组"></a>初始化一维数组</h3><p><code>数组元素类型[] 数组名字 = new 数组元素类型[]{元素, 元素, …}</code></p><p><code>数组元素类型[] 数组名字 = {元素, 元素, …}</code></p><h3 id="使用一维数组"><a href="#使用一维数组" class="headerlink" title="使用一维数组"></a>使用一维数组</h3><p><code>数组名字[0] = 元素1;</code></p><p><code>数组名字[1] = 元素2;</code></p><p>……</p><h2 id="二维数组的创建及使用"><a href="#二维数组的创建及使用" class="headerlink" title="二维数组的创建及使用"></a>二维数组的创建及使用</h2><p>二维数组常用于表示表。第一个下标代表元素所在的行，第二个下标代表元素所在的列。</p><h3 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h3><p>1、先声明，再用 new 运算符进行内存分配</p><p><strong>声明二维数组</strong>：</p><p><code>数组元素类型 数组名字[][]</code> </p><p><code>数组元素类型[][] 数组名字</code> </p><p><strong>为数组分配内存空间</strong>：</p><p><code>数组名字 = new 数组元素的类型[数组元素的个数 1][数组元素的个数 2]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数组名字 = new 数组元素的类型[数组元素的个数 1][]</span><br><span class="line">数组名字[0] = new 数组元素类型[数组元素的个数]</span><br><span class="line">数组名字[1] = new 数组元素类型[数组元素的个数]</span><br><span class="line">…………</span><br><span class="line">数组名字[数组元素的个数 1] = new 数组元素类型[数组元素的个数]</span><br></pre></td></tr></table></figure><p>假如创建的数组有 <code>5 个元素</code>，因此数组中元素的<code>下标为 0~4</code> 。</p><p>2、声明的同时为数组分配内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数组名字 = new 数组元素的类型[数组元素的个数 1][]</span><br><span class="line">数组名字[0] = new 数组元素类型[数组元素的个数]</span><br><span class="line">数组名字[1] = new 数组元素类型[数组元素的个数]</span><br><span class="line">…………</span><br><span class="line">数组名字[数组元素的个数 1] = new 数组元素类型[数组元素的个数]</span><br></pre></td></tr></table></figure><h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>遍历二维数组一般使用双层 for 循环，通过数组的 length 属性可获得数组的长度。</p><h3 id="填充替换数组元素"><a href="#填充替换数组元素" class="headerlink" title="填充替换数组元素"></a>填充替换数组元素</h3><p>数组中的元素定义完成后，可通过 <code>Arrays</code> 类的静态方法 <code>fill()</code> 对数组中的元素进行替换。</p><p><code>Arrays.fill(数组类型[] 数组名字, 数组类型 value)</code> 将指定的 value 分配给数组的每个元素。</p><p><code>Arrays.fill(数组类型[] 数组名字, int fromIndex, int toIndex ,数组类型 value)</code> </p><ul><li><code>fromIndex</code> 用指定值填充的第一个元素的索引（包括）</li><li><code>toIndex</code> 使用指定值填充的最后一个元素的索引（不包括）</li></ul><h3 id="对数组进行排序"><a href="#对数组进行排序" class="headerlink" title="对数组进行排序"></a>对数组进行排序</h3><p><code>Arrays.sort(object)</code></p><blockquote><p>Java 中的 String 类型数组的排序算法是根据字典编排顺序排序的，因此数字排在字母前面，大写字母排在小写字母前面。</p></blockquote><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><p><code>Arrays.copyOf(数组名字, 数组类型 newlength)</code></p><p><code>Arrays.copyOfRange(数组名字, int fromIndex, int toIndex)</code></p><h3 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h3><p>Arrays 类的 binarySearch() 方法，可使用<code>二分搜索法</code>来搜索指定数组，以获得指定对象。</p><p><code>binarySearch(Object[] a, Object key)</code> </p><ul><li><code>a</code> 要搜索的数组</li><li><code>key</code> 要搜索的值</li></ul><p><strong>必须在进行此调用之前对数组进行排序。</strong></p><p><code>binarySearch(Object[] a, int fromIndex, int toIndex, Object key)</code> </p><h2 id="数组排序算法"><a href="#数组排序算法" class="headerlink" title="数组排序算法"></a>数组排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>由小到大排序。依据对比相邻的元素值。</p><p>冒泡算法由双层循环实现，外层是比较的轮数 ；内层是每轮比较的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">        <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮的初始是 true</span></span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为 false</span></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//把无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">                    lastExchangeIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastExchangeIndex;</span><br><span class="line">            <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] array = new int[]&#123;63,4,24,1,3,15&#125;;</span></span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法为已经优化后的。</p><ul><li><code>isSorted</code> 避免在所有元素都在有序情况下，坚持走完所有轮数</li><li><code>lastExchangeIndex</code> 记录最后一次元素交换的位置</li><li><code>sortBorder</code> 避免在后面的元素是有序情况下，坚持去比较。之后的元素肯定是有序的，所以不用比较</li></ul><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= array.length-i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(array[j] &gt; array[index]) &#123;</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = array[array.length-i];</span><br><span class="line">array[array.length-i] = array[index];</span><br><span class="line">array[index]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">63</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>&#125;;</span><br><span class="line">            sort(array);</span><br><span class="line">            System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转排序"><a href="#反转排序" class="headerlink" title="反转排序"></a>反转排序</h3><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><p>类就是<code>封装对象属性和行为的载体</code>，对象就是<code>类抽象出来的一个实例</code>。其中，对象的属性就是成员变量，行为就是方法。</p><p>封装是面向对象编程的核心思想。将对象的属性和行为封装起来，其载体就是类，类通常对客户隐藏其实现细节。保证内部数据结构的完整性，避免外部操作对内部数据的影响。</p><p>继承是避免重复去定义属性和行为。</p><p>多态就是将父类对象应用于子类的特征。依赖于抽象类和接口。</p><ul><li>在多态机制中，父类通常会被定义为抽象类，在抽象类中给出一个方法的标准，而不给出实现的具体流程。</li><li>在多态机制中，将抽象类定义为接口更方便。由抽象方法组成的集合就是接口。</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>java 中对象的属性就是成员变量。</p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>Java 中使用成员方法对应于类对象的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    …<span class="comment">//方法体</span></span><br><span class="line">        <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>成员方法可以有参数，这个参数可以是对象，也可以是基本数据类型</li><li>成员方法可以有有返回值，也可以有不返回值（使用 void 关键字）</li><li>返回值可以是计算结果，也可以是其他数值和对象，但返回值类型要与方法返回的值类型一致</li><li>成员方法可以调用其他成员方法和类成员变量</li><li>成员方法内可以定义局部变量</li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>对于类的成员变量、成员方法，被修饰为：</p><ul><li><code>private</code> 则只能在本类中使用，在子类中是不可见的，并且对其他包的类也是不可见；</li><li><code>public</code> 则除了可以在本类中使用，还可以在子类和其他包的类中使用；</li><li><code>protected</code> 则只有本包内的该类的子类或其他类可以访问此类中的成员变量和成员方法；</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/8901028.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果在声明类的时候，不使用修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。</p><h3 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h3><p>在成员方法中定义的变量。方法被执行时创建，方法执行结束时销毁。</p><ul><li>局部变量在使用时必须进行赋值操作或初始化，否则会编译错误</li></ul><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>在 Java 中规定，</p><ul><li>使用 this 关键字来<code>代表本类对象的引用</code>，this 关键字被隐式地<code>用于引用对象的成员变量和方法；</code></li><li>还可以<code>作为方法的返回值</code>。</li></ul><h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><p>构造方法是一个与类同名的方法，每当类实例化一个对象时，类都会自动调用构造方法。</p><ul><li>构造方法没有返回值；</li><li>构造方法的名称要与本类的名称相同；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 构造方法名（类名）&#123;</span><br><span class="line">    …<span class="comment">//构造方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中可以为成员变量赋值，当实例化一个本类对象时，相应的成员变量也可以初始化。</p><p><strong>如果类中没有明确定义构造方法，编译器会自动创建一个不带参数的默认构造方法</strong>。但如果类中已经存在带参数的构造方法时，编译器不会自动创建一个不带参数的构造方法。</p><h2 id="static-静态变量、常量和方法"><a href="#static-静态变量、常量和方法" class="headerlink" title="static 静态变量、常量和方法"></a>static 静态变量、常量和方法</h2><p>由 static 声明的变量、常量和方法被称为静态成员。在<code>本类或者其他类</code>中使用<code>类名.静态成员</code>调用。</p><ul><li>在静态方法中不可以使用 this 关键字；</li><li>在静态方法中不可以直接调用非静态方法；</li></ul><h2 id="类的主方法"><a href="#类的主方法" class="headerlink" title="类的主方法"></a>类的主方法</h2><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>使用 new 操作符调用构造方法来创建对象。</p><h3 id="访问对象的属性和行为"><a href="#访问对象的属性和行为" class="headerlink" title="访问对象的属性和行为"></a>访问对象的属性和行为</h3><p><code>对象.类成员</code></p><h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p><code>类名 对象引用名称 = new 类名()</code></p><ul><li>引用只是存放一个对象的内存地址，并非存放一个对象。严格地说，引用和对象是不同的，但是这种区别可以忽略。</li></ul><h3 id="对象的比较"><a href="#对象的比较" class="headerlink" title="对象的比较"></a>对象的比较</h3><ul><li><code>==</code> 比较两个对象引用的地址是否相等；</li><li><code>equals()</code> 是 String 类方法，比较两个对象引用所指的内容是否相等；</li></ul><h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h2 id="Integer-（Long、Short）"><a href="#Integer-（Long、Short）" class="headerlink" title="Integer （Long、Short）"></a>Integer （Long、Short）</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>Integer 变量名 = new Integer(int number)</code></li><li><code>Integer 变量名 = new Integer(String str)</code></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/92594555.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><code>toString()</code> 可以将 Integer 对象转换为<code>十进制字符串</code>;</li><li><code>toBinaryString()</code> 可以将对象转换为<code>二进制</code>;</li><li><code>toHexString()</code> 可以将对象转换为<code>十六进制;</code></li><li><code>toOctalString()</code> 可以将对象转换为<code>八进制</code>;</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/37969277.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>Boolean 变量名 = new Boolean(boolean value)</code> </p></li><li><p><code>Boolean 变量名 = new Boolean(String str)</code>  </p><p>str 不为 null 且在忽略大小写时等于 true，则分配一个表示 true 值的 Boolean 对象，否则获得一个 false 值的 Boolean 对象。</p></li></ul><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/64341997.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/4447209.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h2><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>Byte 变量名 = new Byte(byte value)</code> </li><li><code>Byte 变量名 = new Byte(String str)</code> </li></ul><p>str 要使用数值型，否则会报错</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/40206545.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="常量-2"><a href="#常量-2" class="headerlink" title="常量"></a>常量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/69130848.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><h2 id="Double-Float"><a href="#Double-Float" class="headerlink" title="Double (Float)"></a>Double (Float)</h2><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h1 id="数字处理"><a href="#数字处理" class="headerlink" title="数字处理"></a>数字处理</h1><h2 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h2><p>Java 主要对浮点型数据进行数字格式化，其中浮点数包括 double 型和 float 型数据。</p><ul><li>使用 java.text.DecimalFormat 格式化数字</li></ul><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h3><p>Math 类中提供的众多数学函数方法，都被定义为 static 形式。</p><ul><li><code>Math.数学方法</code></li><li><code>Math.PI</code>  、<code>Math.E</code></li></ul><h3 id="常用数学运算方法"><a href="#常用数学运算方法" class="headerlink" title="常用数学运算方法"></a>常用数学运算方法</h3><ul><li>Math 类三角函数方法</li><li>Math 类指数函数方法</li><li>Math 类取整函数方法</li><li>Math 类取最大值、最小值、绝对值函数方法</li></ul><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h3 id="Math-random-方法"><a href="#Math-random-方法" class="headerlink" title="Math.random() 方法"></a>Math.random() 方法</h3><p>默认生成大于等于 0.0 且小于 1.0 的 double 型随机数。</p><h3 id="Random-类"><a href="#Random-类" class="headerlink" title="Random 类"></a>Random 类</h3><p>通过实例化 Random 对象创建一个随机数生成器。</p><h2 id="大数字运算"><a href="#大数字运算" class="headerlink" title="大数字运算"></a>大数字运算</h2><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>支持任意精度整数。</p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>支持任意精度的定点数，可以用来精确计算货币值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-主类结构&quot;&gt;&lt;a href=&quot;#Java-主类结构&quot; class=&quot;headerlink&quot; title=&quot;Java 主类结构&quot;&gt;&lt;/a&gt;Java 主类结构&lt;/h1&gt;&lt;p&gt;Java 程序的基本组成单元是&lt;code&gt;类&lt;/code&gt;，&lt;code&gt;类体&lt;/code&gt;中包括&lt;code&gt;属性&lt;/code&gt;和&lt;code&gt;方法&lt;/code&gt;。每个程序都必须包含一个 &lt;code&gt;main()&lt;/code&gt; 方法，含有 main() 方法的类称为&lt;code&gt;主类&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 屏幕适配</title>
    <link href="http://yoursite.com/2018/07/13/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>http://yoursite.com/2018/07/13/屏幕适配/</id>
    <published>2018-07-13T11:07:43.000Z</published>
    <updated>2018-07-13T11:08:24.538Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="屏幕适配" scheme="http://yoursite.com/tags/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>混合开发</title>
    <link href="http://yoursite.com/2018/07/13/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/07/13/混合开发/</id>
    <published>2018-07-13T02:03:59.000Z</published>
    <updated>2018-07-13T02:05:52.688Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Hybrid" scheme="http://yoursite.com/tags/Hybrid/"/>
    
  </entry>
  
  <entry>
    <title>App 设计</title>
    <link href="http://yoursite.com/2018/07/13/App%20%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/07/13/App 设计/</id>
    <published>2018-07-13T02:01:56.000Z</published>
    <updated>2018-07-13T11:30:26.154Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/tiankongcheng6/article/details/60966281" target="_blank" rel="noopener">Android 中 vector 用法详解</a></p><p><a href="https://blog.csdn.net/p106786860/article/details/53843934" target="_blank" rel="noopener">Android UI：使用矢量图，抛弃PNG</a></p><p><a href="https://www.zhihu.com/question/36813390" target="_blank" rel="noopener">码农如何从零开始做出有设计感的app？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tiankongcheng6/article/details/60966281&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 中 vector 用法详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="设计" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Vector Assert" scheme="http://yoursite.com/tags/Vector-Assert/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2</title>
    <link href="http://yoursite.com/2018/07/11/Dagger2/"/>
    <id>http://yoursite.com/2018/07/11/Dagger2/</id>
    <published>2018-07-11T00:32:23.000Z</published>
    <updated>2018-07-12T01:32:34.857Z</updated>
    
    <content type="html"><![CDATA[<p>A fast dependency injector for Android and Java.<br><a id="more"></a></p><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><p>只要在 app module 的 build.gradle，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ………………</span><br><span class="line">    //dagger2</span><br><span class="line">    implementation &apos;com.google.dagger:dagger:版本号&apos;</span><br><span class="line">    annotationProcessor &apos;com.google.dagger:dagger-compiler:版本号&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="新建一个无参数的类"><a href="#新建一个无参数的类" class="headerlink" title="新建一个无参数的类"></a>新建一个无参数的类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a person created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新建一个该类的提供者"><a href="#新建一个该类的提供者" class="headerlink" title="新建一个该类的提供者"></a>新建一个该类的提供者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Person <span class="title">providesPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a person created from MainModule"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Module</code> 标注的对象，你可以把它想象成一个工厂，可以向外提供一些类的对象。那么到底提供什么对象呢？</li><li><code>@Provides</code> 标注的方法就是提供对象的，这种方法一般会返回一个对象实例，例如上面返回一个 Person 对象。</li></ul><h2 id="新建一个-component-容器"><a href="#新建一个-component-容器" class="headerlink" title="新建一个 component 容器"></a>新建一个 component 容器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;MainModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把它想成一个容器， module 中产出的东西都放在里面，然后将 <code>component</code> 与我要注入的 <code>MainActivity</code> 做关联，MainActivity 中需要的 person 就可以从 component 中去取出来。</p><ul><li><p><code>@Component</code> 表示这个接口是一个容器，并且与 <code>MainModule.class</code> 关联，它生产的东西都在这里。</p></li><li><p><code>void inject(MainActivity mainActivity);</code> 表示我怎么和要注入的类关联。这个比较抽象！</p></li></ul><h2 id="在-MainActivity-中将-component-关联进去"><a href="#在-MainActivity-中将-component-关联进去" class="headerlink" title="在 MainActivity 中将 component 关联进去"></a>在 MainActivity 中将 component 关联进去</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        MainComponent component = DaggerMainComponent.builder()</span><br><span class="line">                .mainModule(<span class="keyword">new</span> MainModule()).build();</span><br><span class="line">        component.inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Inject</code> 在 Person 对象上添加一个 @Inject 注解，即可自动注入对象。这个时候系统看到有一个 @Inject 修饰的 Person，就知道在这个 MainComponent 中去找，并且是有 MainModule 的 Provides 修饰的方法提供的。</li></ul><h2 id="完成以上步骤，开始重建我们的项目"><a href="#完成以上步骤，开始重建我们的项目" class="headerlink" title="完成以上步骤，开始重建我们的项目"></a>完成以上步骤，开始重建我们的项目</h2><p><code>DaggerMainComponent</code> 就是你 build project 的时候，dagger 自己为你生成的具体的 component 类（我们自己定义的是 MainComponent 接口）。</p><h1 id="其他注解和情况"><a href="#其他注解和情况" class="headerlink" title="其他注解和情况"></a>其他注解和情况</h1><h2 id="单例模式-Singleton（基于Component）"><a href="#单例模式-Singleton（基于Component）" class="headerlink" title="单例模式 @Singleton（基于Component）"></a>单例模式 @Singleton（基于Component）</h2><p>基于 Component 的单例模式， 就是在这个 Component 对象中，一个对象是单例对象。如果又新创建了一个Component，那么两个 Component 中的对象是不一样的。</p><p>我们再在 MainActivity 中添加一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inejct</span></span><br><span class="line">Person person2</span><br></pre></td></tr></table></figure></p><p>并打印两个 person 对象，发现 person 会被创建两次，并且两个 person 对象也不同。如果我们希望只有一个 person 和 person2，并且都指向同一个 Person 对象，就要使用 @Singleton 注解。</p><h3 id="在-MainModule-java-的-provides-方法上需要添加-Singleton-注解"><a href="#在-MainModule-java-的-provides-方法上需要添加-Singleton-注解" class="headerlink" title="在 MainModule.java 的 provides 方法上需要添加 @Singleton 注解"></a>在 MainModule.java 的 provides 方法上需要添加 @Singleton 注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Person <span class="title">providesPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a person created from MainModule"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-MainComponent-java-类上添加-Singleton-注解"><a href="#在-MainComponent-java-类上添加-Singleton-注解" class="headerlink" title="在 MainComponent.java 类上添加 @Singleton 注解"></a>在 MainComponent.java 类上添加 @Singleton 注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = &#123;MainModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行，发现 person 只创建了一次，并且两个 person 指向同一个对象。</p><p>需要注意的是：单例是基于 Component 的，所以不仅 Provides 的地方要加 @Singleton，Component 上也需要加。并且如果有另外一个 OtherActivity，并且创建了一个 MainComponent，也注入 Person，这个时候 MainActivity 和 OtherActivity 中的 Person 是不构成单例的，因为它们的 Component 是不同的。</p><h2 id="带有参数的依赖对象"><a href="#带有参数的依赖对象" class="headerlink" title="带有参数的依赖对象"></a>带有参数的依赖对象</h2><p>如果构造 Person 类，需要一个参数 Context，我们怎么注入呢？ 要知道注入的时候我们只有一个 @Inject 注解，并不能带参数。所以我们需要再 MainModule 中提供 context，并且由 providesXXX 函数自己去构造。</p><h3 id="新建一个带参数的类"><a href="#新建一个带参数的类" class="headerlink" title="新建一个带参数的类"></a>新建一个带参数的类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Person"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"我是一个带参数的男人"</span> + context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改该类的提供者"><a href="#修改该类的提供者" class="headerlink" title="修改该类的提供者"></a>修改该类的提供者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainModule"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainModule</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">providesContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">providesPerson</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"person from module "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>providesPerson(Context context)</code> 中的 <code>context</code> 不能直接使用成员变量 <code>this.context</code>，而是要在本类中提供一个<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">providesContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>方法，这样在发现需要 <code>context</code> 的时候会调用 <code>provideContext</code> 来获取，这也是为了解耦。</p><h1 id="依赖一个组件"><a href="#依赖一个组件" class="headerlink" title="依赖一个组件"></a>依赖一个组件</h1><h1 id="自定义标记-Qualifier-和-＠Named"><a href="#自定义标记-Qualifier-和-＠Named" class="headerlink" title="自定义标记 @Qualifier 和 ＠Named"></a>自定义标记 @Qualifier 和 ＠Named</h1><h2 id="Named-“…”"><a href="#Named-“…”" class="headerlink" title="@Named(“…”)"></a>@Named(“…”)</h2><h2 id="Qualifier自定义标签"><a href="#Qualifier自定义标签" class="headerlink" title="@Qualifier自定义标签"></a>@Qualifier自定义标签</h2><h1 id="懒加载Lazy和强制重新加载Provider"><a href="#懒加载Lazy和强制重新加载Provider" class="headerlink" title="懒加载Lazy和强制重新加载Provider"></a>懒加载Lazy和强制重新加载Provider</h1><h1 id="Scope-自定义生命周期"><a href="#Scope-自定义生命周期" class="headerlink" title="@Scope 自定义生命周期"></a>@Scope 自定义生命周期</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/google/dagger" target="_blank" rel="noopener">google/dagger</a><br><a href="https://www.jianshu.com/p/92f793e76654" target="_blank" rel="noopener">Dagger2入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A fast dependency injector for Android and Java.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://yoursite.com/tags/Dagger2/"/>
    
  </entry>
  
  <entry>
    <title>ButterKnife</title>
    <link href="http://yoursite.com/2018/07/11/ButterKnife/"/>
    <id>http://yoursite.com/2018/07/11/ButterKnife/</id>
    <published>2018-07-11T00:31:58.000Z</published>
    <updated>2018-07-12T01:30:29.905Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ButterKnife" scheme="http://yoursite.com/tags/ButterKnife/"/>
    
  </entry>
  
  <entry>
    <title>旅游记账助手</title>
    <link href="http://yoursite.com/2018/07/11/%E6%97%85%E6%B8%B8%E8%AE%B0%E8%B4%A6%E5%8A%A9%E6%89%8B/"/>
    <id>http://yoursite.com/2018/07/11/旅游记账助手/</id>
    <published>2018-07-11T00:31:58.000Z</published>
    <updated>2018-07-11T00:37:43.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>记账（AA 制）</p><p>旅游攻略</p><p>景点导航</p><p>相机</p><p>紧急电话</p><p>注意事项分享提醒（护照、衣物、登机牌…………）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h1&gt;&lt;p&gt;记账（AA 制）&lt;/p&gt;
&lt;p&gt;旅游攻略&lt;/p&gt;
&lt;p&gt;景点导航&lt;/p&gt;
&lt;p&gt;相机&lt;/p&gt;
&lt;p&gt;紧急电话&lt;/p&gt;
&lt;p&gt;注意事项分享提醒
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="记账" scheme="http://yoursite.com/tags/%E8%AE%B0%E8%B4%A6/"/>
    
  </entry>
  
  <entry>
    <title>异常捕获代码</title>
    <link href="http://yoursite.com/2018/07/06/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2018/07/06/异常捕获代码/</id>
    <published>2018-07-06T05:48:15.000Z</published>
    <updated>2018-07-06T05:48:15.430Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Content Provider 内容提供器</title>
    <link href="http://yoursite.com/2018/07/06/ContentProvider%20%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/06/ContentProvider 内容提供器/</id>
    <published>2018-07-06T05:26:27.000Z</published>
    <updated>2018-07-08T01:53:52.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><code>内容提供器</code>主要用于在不同的应用程序之间实现数据共享功能，是 Android 实现跨程序共享数据的标准方式。</p><a id="more"></a><h1 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h1><h2 id="Android-的权限机制"><a href="#Android-的权限机制" class="headerlink" title="Android 的权限机制"></a>Android 的权限机制</h2><p>每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限所对应的权限组中所有的其他权限也会同时被授权。</p><h2 id="在程序运行时申请权限"><a href="#在程序运行时申请权限" class="headerlink" title="在程序运行时申请权限"></a>在程序运行时申请权限</h2><p>1、 首先判断用户是不是已经给我们授权了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ContextCompat.checkSelfPermission(Context, Manifest.permission.权限) != PackageManager.PErMISSION_GRANTED)&#123;</span><br><span class="line">  ActivityCompat.requestPermissions(Context, <span class="keyword">new</span> String[]&#123;Manifest.permission.权限&#125;, 常量);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 如果已经授权就执行逻辑操作；如果没有授权，则调用 <code>ActivityCompat.requestPermissions()</code> 方法，最终回调到 <code>onRequestPermissionResult()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, String[] permissions, <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> 常量:</span><br><span class="line">            <span class="keyword">if</span>(grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PErMISSION_GRANTED)&#123;</span><br><span class="line">              <span class="comment">//do something</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//do another thing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h1><p>如果想要访问内容提供器中共享的数据，就一定要借助 ContentResolver 类，通过 Context 的 getContentResolver() 方法获得实例。</p><h2 id="ContentResolver-的基本用法"><a href="#ContentResolver-的基本用法" class="headerlink" title="ContentResolver 的基本用法"></a>ContentResolver 的基本用法</h2><ul><li>insert() ：增加数据</li><li>update() ：更新数据</li><li>delete() ：删除数据</li><li>query()  ：查询数据</li></ul><p>ContentResolver 中的增删改查方法都不是接受表名参数，而是使用一个 Uri 参数代替，即<code>内容 URI</code>。</p><h3 id="关于内容-URI"><a href="#关于内容-URI" class="headerlink" title="关于内容 URI"></a>关于内容 URI</h3><p><code>内容 URI</code> 由 <code>authority</code> 和 <code>path</code> 组成。其中：</p><ul><li><p>authority 是用于对不同的应用程序做区分的，采用程序包命名。例如：com.example.app.Provider。</p></li><li><p>path 是对同一程序不同的表做区分的，通常添加到 authority 后面。例如：com.example.app.Provider/table1，com.example.app.Provider/table2。</p></li></ul><p>解析内容 URI 的方法：<br><code>Uri uri = Uri.parse(&quot;com.example.app.Provider/table1&quot;);</code></p><h3 id="增删改查方法演示"><a href="#增删改查方法演示" class="headerlink" title="增删改查方法演示"></a>增删改查方法演示</h3><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = getContentResolver().query(</span><br><span class="line">  uri,</span><br><span class="line">  projection,</span><br><span class="line">  selection,</span><br><span class="line">  selectionArgs,</span><br><span class="line">  sortOrder</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">query() 方法参数</th><th style="text-align:left">对应 SQL 部分</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">uri</td><td style="text-align:left">from table_name</td><td style="text-align:left">指定查询某个应用程序下的某一张表</td></tr><tr><td style="text-align:left">projection</td><td style="text-align:left">select column1，column2</td><td style="text-align:left">指定查询的列名</td></tr><tr><td style="text-align:left">selection</td><td style="text-align:left">where column = value</td><td style="text-align:left">指定 where 的约束条件</td></tr><tr><td style="text-align:left">selectionArgs</td><td style="text-align:left">-</td><td style="text-align:left">为 where 中的占位符提供具体的值</td></tr><tr><td style="text-align:left">orderBy</td><td style="text-align:left">order by column1,column2</td><td style="text-align:left">指定查询结果的排序方式</td></tr></tbody></table><p>查询完成后返回的仍然是一个 Cursor 对象，将数据从 Cursor 对象中读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">    String column1 = cursor.getstring(cursor.getColumnIndex(<span class="string">"column1"</span>));</span><br><span class="line">    <span class="keyword">int</span> column2 = cursor.getInt(cursor.getColumnIndex(<span class="string">"column2"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  cursor.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>, <span class="string">"text"</span>);</span><br><span class="line">values.put(<span class="string">"column2"</span>, <span class="number">1</span>);</span><br><span class="line">getContentResolver().insert(uri, values);</span><br></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>, <span class="string">""</span>);</span><br><span class="line">getContentResolver().update(uri, values, <span class="string">"column1 = ? and column2 = ?"</span>, <span class="keyword">new</span> String[] &#123;<span class="string">"text"</span>, <span class="string">"1"</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p><code>getContentResolver().delete(uri, &quot;column2 = ?&quot;, new String[] {&quot;1&quot;})</code></p><h1 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;code&gt;内容提供器&lt;/code&gt;主要用于在不同的应用程序之间实现数据共享功能，是 Android 实现跨程序共享数据的标准方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="内容提供器" scheme="http://yoursite.com/tags/%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView使用</title>
    <link href="http://yoursite.com/2018/07/05/RecyclerView%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/RecyclerView使用/</id>
    <published>2018-07-05T05:48:59.000Z</published>
    <updated>2018-07-05T05:48:59.578Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fragment 使用</title>
    <link href="http://yoursite.com/2018/07/05/Fragment%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/Fragment使用/</id>
    <published>2018-07-05T05:48:36.000Z</published>
    <updated>2018-07-08T01:12:54.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fragment-的-add、hide、show"><a href="#Fragment-的-add、hide、show" class="headerlink" title="Fragment 的 add、hide、show"></a>Fragment 的 add、hide、show</h1><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加 Fragment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragmentManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragmentTag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addFragment</span><span class="params">(FragmentManager fragmentManager, Fragment fragment, String fragmentTag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fragmentManager != <span class="keyword">null</span>)&#123;</span><br><span class="line">            FragmentTransaction transaction = fragmentManager.beginTransaction();</span><br><span class="line">            transaction.add(R.id.frag_main, fragment, fragmentTag);</span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示已存在的 Fragment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragmentManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(FragmentManager fragmentManager, Fragment fragment)</span></span>&#123;</span><br><span class="line">        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fragmentTransaction.show(fragment);</span><br><span class="line">            fragmentTransaction.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏所有的 Fragment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragmentManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hideAllFragment</span><span class="params">(FragmentManager fragmentManager)</span></span>&#123;</span><br><span class="line">        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span><br><span class="line"></span><br><span class="line">        Fragment dashboard_fragment = fragmentManager.findFragmentByTag(<span class="string">"dashboard_fragment"</span>);</span><br><span class="line">        <span class="keyword">if</span> (dashboard_fragment != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fragmentTransaction.hide(dashboard_fragment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fragmentTransaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="noopener">Fragment全解析系列</a></li><li><a href="https://www.jianshu.com/p/662c46cd3b5f" target="_blank" rel="noopener">Fragment你真的熟悉吗？看了才知道</a></li><li><a href="https://www.jianshu.com/p/28ca4cbe190c" target="_blank" rel="noopener">Android基础：Fragment，看这篇就够了</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Fragment-的-add、hide、show&quot;&gt;&lt;a href=&quot;#Fragment-的-add、hide、show&quot; class=&quot;headerlink&quot; title=&quot;Fragment 的 add、hide、show&quot;&gt;&lt;/a&gt;Fragment 的 add、hide、show&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>自定义 View</title>
    <link href="http://yoursite.com/2018/07/05/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <id>http://yoursite.com/2018/07/05/自定义View/</id>
    <published>2018-07-05T05:48:16.000Z</published>
    <updated>2018-07-05T11:03:06.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="http://www.gcssloop.com/customview/CustomViewIndex/" target="_blank" rel="noopener">安卓自定义View教程</a></p></li><li><p><a href="https://blog.csdn.net/ccy0122/article/details/53241648" target="_blank" rel="noopener">仿支付宝芝麻信用的仪表盘</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.gcssloop.com/customview/CustomVie
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="自定义 View" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89-View/"/>
    
  </entry>
  
  <entry>
    <title>Intent使用</title>
    <link href="http://yoursite.com/2018/07/05/Intent%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/Intent使用/</id>
    <published>2018-07-05T05:47:59.000Z</published>
    <updated>2018-07-05T05:47:59.177Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
