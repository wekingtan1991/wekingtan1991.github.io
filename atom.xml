<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>你好，我叫weking</title>
  
  <subtitle>我不怕千万人阻挡，只怕自己会投降</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-19T16:14:59.708Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wekingtan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存优化与内存泄露</title>
    <link href="http://yoursite.com/2018/07/19/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2018/07/19/内存优化与内存泄露/</id>
    <published>2018-07-19T03:25:53.000Z</published>
    <updated>2018-07-19T16:14:59.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对象在内存 heap 堆中分配的空间，当不再使用或没有引用指向的情况下，仍不能被垃圾收集器 GC 正常回收的情况。</p><ul><li>多数出现在不合理的编码情况下，Android 中常见就是 Activity 被引用，但在调用 finish 之后却没有释放，第二次打开 activity又重新创建，这样的内存泄漏不断的发生，则会导致内存的溢出。 </li><li>比如在 Activity 中注册了一个广播接收器，但是在页面关闭的时候没有进行unRegister，就会出现内存溢出的现象。通常情况下，大量的内存泄漏会造成 OOM。</li></ul><h2 id="OOM（内存溢出）"><a href="#OOM（内存溢出）" class="headerlink" title="OOM（内存溢出）"></a>OOM（内存溢出）</h2><p>即 Out Of Memoery，顾名思义就是指内存溢出了。</p><p>Android 的每个应用程序都会使用一个专有的 Dalvik 虚拟机实例来运行，它是由 Zygote 服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。 Android 为不同类型的进程分配了不同的内存使用上限 。</p><p>APP 向系统申请超过最大阀值的内存请求，但系统不会再分配多余的空间，就会造成OOM error。在我们 Android 平台下，多数情况是出现在图片不当处理加载的时候。  </p><a id="more"></a><h1 id="Android-内存管理"><a href="#Android-内存管理" class="headerlink" title="Android 内存管理"></a>Android 内存管理</h1><p>Android 应用层是由 java 开发的，Android 的 davlik 虚拟机与 jvm 也类似，只不过它是<code>基于寄存器</code>的。</p><p>在 java 中，通过 new 为对象分配内存，所有对象在 java 堆内分配空间；而内存的释放是由垃圾收集器（GC）来回收的。 </p><p>Java采用了有向图的原理。Java 将引用关系考虑为图的有向边，有向边从引用者指向引用对象。</p><p>线程对象可以作为有向图的起始顶点，该图就是从起始顶点(GC roots)开始的一棵树，根顶点可以到达的对象都是有效对象，GC 不会回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。  </p><h1 id="Android-内存优化的关键点"><a href="#Android-内存优化的关键点" class="headerlink" title="Android 内存优化的关键点"></a>Android 内存优化的关键点</h1><h2 id="万恶的-static"><a href="#万恶的-static" class="headerlink" title="万恶的 static"></a>万恶的 static</h2><p>由于 static 声明变量的生命周期其实是和 APP 的生命周期一 样的，有点类似于 Application<strong>。</strong>如果大量使用的话，就会占据内存空间不释放，积少成多也会造成内存的不断开销，直至挂掉。</p><p>static 的合理使用一般用来修饰基本数据类型或者轻量级对象，尽量避免修饰集合或者大对象，常用作修饰全局配置项、工具类方法、内部类。</p><h2 id="无关引用"><a href="#无关引用" class="headerlink" title="无关引用"></a>无关引用</h2><p>很多情况下，我们需求用到传递引用，但是我们无法确保引用传递出去后能否及时的回收。</p><p>比较有代表性的 Context 泄漏，很多情况下当 Activity 结束后，由于仍被其他的对象指向导致一直迟迟不能回收，这就造成了内存泄漏。这时可以考虑第三条建议。</p><p>不要让生命周期长于Activity 的对象持有到 Activity 的引用 。</p><h2 id="善用-SoftReference-WeakReference-LruCache"><a href="#善用-SoftReference-WeakReference-LruCache" class="headerlink" title="善用 SoftReference/WeakReference/LruCache"></a>善用 SoftReference/WeakReference/LruCache</h2><p>Java、Android 中有没有这样一种机制呢，当内存吃紧或者 GC 扫过的情况下，就能及时把一些内存占用给释放掉，从而分配给需要分配的地方。答案是肯定的，java 为我们提供了两个解决方案：</p><ul><li>如果对内存的开销比较关注的 APP，可以考虑使用 WeakReference，当 GC 回收扫过这块内存区域时就会回收；如果不是那么关注的话，可以使用 SoftReference，它会在内存申请不足的情况下自动释放，同样也能解决 OOM 问题；</li><li>Android 自 3.0 以后也推出了 LruCache 类，使用 LRU 算法释放内存，一样的能解决 OOM，如果兼容 3.0 以下的版本，请导入 v4 包。关于 第二条的无关引用的问题，我们传参可以考虑使用 WeakReference 包装一下。</li></ul><h2 id="谨慎-handler"><a href="#谨慎-handler" class="headerlink" title="谨慎 handler"></a>谨慎 handler</h2><p>在处理异步操作的时候，handler + thread 是个不错的选择。但是相信在使用 handler 的时候，大家都会遇到警告的情形，这个就是 lint 为开发者的提醒。handler 运行于 UI 线程，不断处理来自 MessageQueue 的消息，如果 handler 还有消息需要处理但是 Activity 页面已经结束的情况下，Activity 的引用其实并不会被回收，这就造成了内存泄漏。解决方案有 2 种：</p><ul><li><p>在 Activity 的 onDestroy 方法中调用 <code>handler.removeCallbacksAndMessages(null);</code> 取消所有的消息的处理，包括待处理的消息；</p></li><li><p>声明handler的内部类为static。</p></li></ul><h2 id="Bitmap终极杀手"><a href="#Bitmap终极杀手" class="headerlink" title="Bitmap终极杀手"></a>Bitmap终极杀手</h2><p>Bitmap 的不当处理极可能造成 OOM，绝大多数情况都是因这个原因出现的。Bitamp 位图是 Android 中当之无愧的胖小子，所以在操作的时候当然是十分的小心了。由于 Dalivk 并不会主动的去回收，需要开发者在 Bitmap 不被使用的时候 recycle 掉。使用的过程中，及时释放是非常重要 的。同时如果需求允许，也可以去 BItmap 进行一定的缩放，通过 <code>BitmapFactory.Options</code> 的 <code>inSampleSize</code> 属性进行控制。 </p><p>如果仅仅只想获得 Bitmap 的属性，其实并不需要根据 BItmap 的像素去分配内存，只需在解析读取 Bmp 的时候使用 <code>BitmapFactory.Options</code> 的 <code>inJustDecodeBounds</code> 属性。</p><p>最后建议大家在加载网络图片的时候，使用软引用或者弱引用并进行本地缓存，推荐使用 <code>android-universal-imageloader</code> 或者 <code>xUtils</code>，牛人出品，必属精品。</p><h2 id="Cursor-和-I-O-流及时关闭"><a href="#Cursor-和-I-O-流及时关闭" class="headerlink" title="Cursor 和 I/O 流及时关闭"></a>Cursor 和 I/O 流及时关闭</h2><p>在查询 SQLite 数据库时，会返回一个 Cursor，当查询完毕后，及时关闭，这样就可以把查询的结果集及时给回收掉。</p><p>I/O 流操作完毕，读写结束，记得关闭。</p><h2 id="ListView-和-GridView-的-item-缓存"><a href="#ListView-和-GridView-的-item-缓存" class="headerlink" title="ListView 和 GridView 的 item 缓存"></a>ListView 和 GridView 的 item 缓存</h2><p>对于移动设备，尤其硬件参差不齐的 Android 生态，页面的绘制其实是很耗时的，findViewById 也是蛮慢的。所以不重用 View，在有列表的时候就尤为显著了，经常会出现滑动很卡的现象。</p><h2 id="页面背景和图片加载"><a href="#页面背景和图片加载" class="headerlink" title="页面背景和图片加载"></a>页面背景和图片加载</h2><p>在布局和代码中设置背景和图片的时候，如果是纯色，尽量使用 color；如果是规则图形，尽量使用 shape 画图；如果稍微复杂点，可以使用 9patch 图；如果不能使用 9patch 的情况下，针对几种主流分辨率的机型进行切图。</p><h2 id="BroadCastReceiver、Service"><a href="#BroadCastReceiver、Service" class="headerlink" title="BroadCastReceiver、Service"></a>BroadCastReceiver、Service</h2><p>绑定广播和服务，一定要记得在不需要的时候给解绑。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程不再需要继续执行的时候要记得及时关闭，开启线程数量不易过多，一般和自己机器内核数一样最好，推荐开启线程的时候，使用<code>线程池</code>。</p><h2 id="String-StringBuffer"><a href="#String-StringBuffer" class="headerlink" title="String/StringBuffer"></a>String/StringBuffer</h2><p>当有较多的字符创需要拼接的时候，推荐使用 StringBuffer。</p><h1 id="Android内存分配回收机制"><a href="#Android内存分配回收机制" class="headerlink" title="Android内存分配回收机制"></a>Android内存分配回收机制</h1><p>从宏观角度上来看Android系统可以分为三个层次</p><ul><li>Application Framework,</li><li>Dalvik 虚拟机</li><li>Linux内核。</li></ul><p>这三个层次都有各自内存相关工作：</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg%3D%3D&amp;mid=2653578816&amp;idx=1&amp;sn=20b6160e92167dde676561f3a43d0860&amp;scene=45#wechat_redirect" target="_blank" rel="noopener">Android 内存优化总结&amp;实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h2&gt;&lt;p&gt;对象在内存 heap 堆中分配的空间，当不再使用或没有引用指向的情况下，仍不能被垃圾收集器 GC 正常回收的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多数出现在不合理的编码情况下，Android 中常见就是 Activity 被引用，但在调用 finish 之后却没有释放，第二次打开 activity又重新创建，这样的内存泄漏不断的发生，则会导致内存的溢出。 &lt;/li&gt;
&lt;li&gt;比如在 Activity 中注册了一个广播接收器，但是在页面关闭的时候没有进行unRegister，就会出现内存溢出的现象。通常情况下，大量的内存泄漏会造成 OOM。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;OOM（内存溢出）&quot;&gt;&lt;a href=&quot;#OOM（内存溢出）&quot; class=&quot;headerlink&quot; title=&quot;OOM（内存溢出）&quot;&gt;&lt;/a&gt;OOM（内存溢出）&lt;/h2&gt;&lt;p&gt;即 Out Of Memoery，顾名思义就是指内存溢出了。&lt;/p&gt;
&lt;p&gt;Android 的每个应用程序都会使用一个专有的 Dalvik 虚拟机实例来运行，它是由 Zygote 服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。 Android 为不同类型的进程分配了不同的内存使用上限 。&lt;/p&gt;
&lt;p&gt;APP 向系统申请超过最大阀值的内存请求，但系统不会再分配多余的空间，就会造成OOM error。在我们 Android 平台下，多数情况是出现在图片不当处理加载的时候。  &lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>事件分发与滑动冲突</title>
    <link href="http://yoursite.com/2018/07/19/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%B8%8E%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
    <id>http://yoursite.com/2018/07/19/事件分发与滑动冲突/</id>
    <published>2018-07-19T03:25:24.000Z</published>
    <updated>2018-07-19T11:07:40.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h1><p>事件分发过程主要由 <code>dispatchTouchEvent</code>，<code>onInterceptTouchEvent</code> 和 <code>onTouchEvent</code> 三个方法共同完成：</p><ul><li>public boolean dispatchTouchEvent(MotionEvent ev)</li></ul><p>用来进行事件分发，如果事件能够传递给当前 view，则此方法一定调用，返回结果受当前 view 的 onTouchEvent 和下级 view 的 dispatchTouchEvent 方法影响，表示是否消耗了当前事件。</p><ul><li>public boolean onInterceptTouchEvent(MotionEvent event)</li></ul><p>在 dispatchTouchEvent 内部调用，用来判断是否拦截某个事件。</p><ul><li>public boolean onTouchEvent(MotionEvent event)</li></ul><p>在 dispatchTouchEvent 内部调用，用来处理点击事件，返回结果表示是否消耗了当前事件，如果不消耗则在同一事件序列中，当前 view 无法再次接受到事件。</p><a id="more"></a><p>点击事件达到顶级 View（一般为 ViewGroup ）后，会调用 viewGroup 的 <code>dispatchTouchEvent</code> 方法，</p><p>如果顶级 ViewGroup 的 <code>onInterceptTouchEvent</code> 返回 true，则事件由 ViewGroup 处理，这时如果 ViewGroup 的 mOnTouchListener 被设置，则 onTouch 会被调用，onTouch 若返回 true，ViewGroup 的 <code>onTouchEvent</code> 不会再被调用；若设置了 mOnClickListener，则 onClick 会被调用。</p><p>如果顶层 ViewGroup 不拦截事件即 <code>onInterceptTouchEvent</code> 返回 false，则事件传递给子 View，这时子 View 的 <code>dispatchTouchEvent</code> 会被调用，到此为止，事件已经从顶级 View 传递了下一层 View，如此循环，完成整个事件的分发。</p><p>如果一个 View 的 <code>onTouchEvent</code> 返回 false，那么它的父容器的 <code>onTouchEvent</code> 将会被调用，表示无法消耗（解决）事件，需要交给上级。</p><p>ViewGroup 默认不拦截任何事件，即 Android 源码中 ViewGroup 的 <code>onInterceptTouchEvent</code> 默认返回 false。</p><p>View 没有 <code>onInterceptTouchEvent</code> 方法，一旦有点击事件传递给它，那么它的 <code>onTouchEvent</code> 方法就会被调用。</p><p>伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result= <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(ev))&#123;</span><br><span class="line">         result = onTouchEvent(ev);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-19/3990920.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><img src="http://pb849j3l9.bkt.clouddn.com/18-7-19/82960123.jpg" alt="如果事件不被中断，则整个事件流向是一个类 U 型图"></p><p><img src="http://pb849j3l9.bkt.clouddn.com/18-7-19/14811717.jpg" alt=""></p><h1 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h1><p>在界面中内外两层同时可以滑动，就产生了滑动冲突，如何解决滑动冲突呢？</p><p>常见的滑动冲突 场景 可分为以下 3 种：</p><ul><li>外部滑动方向和内部滑动方向不一致</li></ul><p>ViewPager 和Fragment 组成的页面中包括一个 ListView，这种情况是有滑动冲突的，但是 ViewPager 内部处理了这种滑动冲突，因此采用 ViewPager 时无须关注这个问题，如果采用的不是 ViewPager 而是 ScrollView，那就必须处理滑动冲突了，否则内外两层就只有一层能滑动。</p><ul><li>外部滑动方向和内部滑动方向一致</li></ul><p>内外两层在同一个方向都可以滑动，系统无法知道用户到底想让哪一层滑动。</p><ul><li>上面两种情况的嵌套</li></ul><p>比如 SlideMenu、ScrollView 和 ListView 三者同时出现。</p><h2 id="处理规则"><a href="#处理规则" class="headerlink" title="处理规则"></a>处理规则</h2><p>场景1：根据滑动是水平滑动还是竖直滑动来判断到底由谁来拦截事件。</p><p>场景2：虽然无法根据滑动方向来判断，但是这时一般在业务上有状态可以依赖，比如业务上有规定，当处于某种状态时需要外部 View 响应用户滑动，而处于另一种状态时需要内部 View 响应滑动。</p><p>场景3：其实很简单，结合场景 1 和场景 2 的处理规则，就能处理场景 3 的滑动冲突。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>外部拦截法</li></ul><p>点击事件先经过父容器的拦截处理，如果父容器需要响应就拦截，不需要就不拦截，拦截处理需要写在父容器的 <code>onInterceptTouchEvent</code> 方法里。</p><ul><li>内部拦截法 </li></ul><p>父容器不拦截任何事件，子 view 需要响应就直接消耗，否则就交由父容器处理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/e99b5e8bd67b" target="_blank" rel="noopener">图解 Android 事件分发机制</a></p><p><a href="https://www.jianshu.com/p/49c44652c3f4" target="_blank" rel="noopener">事件分发和滑动冲突知识点总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件分发机制&quot;&gt;&lt;a href=&quot;#事件分发机制&quot; class=&quot;headerlink&quot; title=&quot;事件分发机制&quot;&gt;&lt;/a&gt;事件分发机制&lt;/h1&gt;&lt;p&gt;事件分发过程主要由 &lt;code&gt;dispatchTouchEvent&lt;/code&gt;，&lt;code&gt;onInterceptTouchEvent&lt;/code&gt; 和 &lt;code&gt;onTouchEvent&lt;/code&gt; 三个方法共同完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public boolean dispatchTouchEvent(MotionEvent ev)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用来进行事件分发，如果事件能够传递给当前 view，则此方法一定调用，返回结果受当前 view 的 onTouchEvent 和下级 view 的 dispatchTouchEvent 方法影响，表示是否消耗了当前事件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public boolean onInterceptTouchEvent(MotionEvent event)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 dispatchTouchEvent 内部调用，用来判断是否拦截某个事件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;public boolean onTouchEvent(MotionEvent event)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 dispatchTouchEvent 内部调用，用来处理点击事件，返回结果表示是否消耗了当前事件，如果不消耗则在同一事件序列中，当前 view 无法再次接受到事件。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="事件" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>热修复和增量更新</title>
    <link href="http://yoursite.com/2018/07/19/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%92%8C%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2018/07/19/热修复和增量更新/</id>
    <published>2018-07-19T03:24:54.000Z</published>
    <updated>2018-07-19T16:28:27.258Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="热修复" scheme="http://yoursite.com/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="增量更新" scheme="http://yoursite.com/tags/%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础</title>
    <link href="http://yoursite.com/2018/07/15/Java%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/07/15/Java 基础/</id>
    <published>2018-07-14T17:01:16.000Z</published>
    <updated>2018-07-17T15:53:43.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-主类结构"><a href="#Java-主类结构" class="headerlink" title="Java 主类结构"></a>Java 主类结构</h1><p>Java 程序的基本组成单元是<code>类</code>，<code>类体</code>中包括<code>属性</code>和<code>方法</code>。每个程序都必须包含一个 <code>main()</code> 方法，含有 main() 方法的类称为<code>主类</code>。</p><a id="more"></a><h2 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h2><p>语句 <code>package xxx</code> 为声明该类所在的包。</p><h2 id="声明成员变量和局部变量"><a href="#声明成员变量和局部变量" class="headerlink" title="声明成员变量和局部变量"></a>声明成员变量和局部变量</h2><p><code>全局变量（成员变量）</code>：类的属性；</p><p><code>局部变量</code>：方法中的属性；</p><h2 id="编写主方法"><a href="#编写主方法" class="headerlink" title="编写主方法"></a>编写主方法</h2><p><code>public static void main(String[] args) {……}</code> 方法是主类中的主方法。public 是<code>权限修饰符</code>、static 是<code>静态修饰符</code>、void 是<code>返回值修饰符</code>、String[] args 是一个<code>字符串类型的数组</code>。</p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>分为<code>数值型（整数类型、浮点类型）</code>、<code>字符型</code>、<code>布尔型</code>。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>整型数据在 Java 中有<code>十进制</code>、<code>八进制</code>、<code>十六进制</code>。其中八进制以<code>0</code>开头，十六进制以<code>0X</code>或<code>0x</code>开头。</p><p>整型数据根据所占内存大小不同（内存空间 8 位等于 1 字节），分为 <code>byte（8位）</code>、<code>short（16位）</code>、<code>int（32位）</code>、<code>long（64位）</code>。</p><p>变量取值范围超出就会报错。</p><p>对于 long 型值，若赋给的值大于 int 型的最大最小值，则需要在数字后面加 <code>L</code> 或 <code>l</code>。</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>浮点类型表示有小数部分的数字。分为<code>单精度浮点类型</code>和<code>双精度浮点类型</code>。</p><p>浮点数据根据所占内存大小不同（内存空间 8 位等于 1 字节），分为 <code>float（32位）</code>、<code>double（64位）</code>。</p><p>默认情况下，小数被看做是 <code>double 型</code>。</p><p>float 型小数，数字后面需要加 <code>F</code> 或 <code>f</code>。</p><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><h3 id="char-型"><a href="#char-型" class="headerlink" title="char 型"></a>char 型</h3><p>字符类型用于存储<code>单个字符</code>，占用内存空间 <code>16 位</code>（两个字节）。</p><p>在定义字符类型变量时，以单引号表示一个字符，双引号表示一个字符串。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>以反斜杠 <code>\</code> 开头，后跟一个或多个字符。</p><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>通过关键字 boolean 来定义布尔类型变量，只有 true 和 false。</p><h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h2><p>标识符由<code>任意顺序的字母</code>、<code>下划线</code>、<code>美元符号</code>、<code>数字组成</code>，并且第一个字符不能是数字，不能是关键字。</p><p>关键字是赋予特定意义的单词。</p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>声明变量时可以没有赋值，也可以直接赋给初值。</p><h2 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a>声明常量</h2><p>标准语法： <code>final 数据类型 常量名称[=值]</code></p><p>常量名通常使用大写字母表示。</p><p>当定义的 <code>final</code> 变量属于成员变量时，必须在定义时就设定它的初值，否则会编译错误。</p><h2 id="变量的有效范围"><a href="#变量的有效范围" class="headerlink" title="变量的有效范围"></a>变量的有效范围</h2><p>由于变量被定义出来后只是暂存在内存中，等到程序执行到某一个点，改变量会被释放掉。</p><p>根据变量的“有效范围”将变量分为 <code>“成员变量”</code> 和<code>“局部变量”</code>。</p><h3 id="成员变量（全局变量）"><a href="#成员变量（全局变量）" class="headerlink" title="成员变量（全局变量）"></a>成员变量（全局变量）</h3><p>类体中定义的变量称为成员变量，在整个类中都有效。分为<code>静态变量</code>和<code>实例变量</code>。</p><p>成员变量的类型前面加上关键字 <code>static</code>，则是静态变量。它的有效范围<code>可以跨类</code>，甚至可以达到<code>整个应用程序之内</code>。对于静态变量，除了在定义它的类内存取，还可以“类名.静态变量”方式在其他类内使用。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量是在类的方法体中定义的。只在当前代码块中有效。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="自增和自减运算符"><a href="#自增和自减运算符" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h2><p>是单目运算符。<br><code>++a（-a）</code> 表示在使用变量 a 之前，先使 a 的值加（减）1<br><code>a--（a-）</code> 表示在使用变量 a 之后，使 a 的值加（减）1</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>按位与 &amp;</p><p>按位或 |</p><p>按位取反 ~</p><p>按位异或 ^</p><p>移位操作 &lt;&lt; 左移  &gt;&gt; 右移  &gt;&gt;&gt; 无符号右移</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>使用格式： <code>条件式？值1：值2</code><br>等价于 if…else</p><h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>低精度数据类型向高精度数据类型转换，则永远不会溢出，永远成功；高精度数据类型向低精度数据类型转换，则有可能失败。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>低精度类型向高精度类型转换，系统自动执行。</p><p>精度从低到高： <code>byte &lt; short &lt; char &lt; int &lt; long &lt; float &lt; double</code></p><h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><p>高精度的变量的值赋给低精度的变量或取值范围超出变量时，必须使用显示类型转换（又称为强制类型转换）。</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h2><p>先判断，再循环</p><h2 id="do…while-循环语句"><a href="#do…while-循环语句" class="headerlink" title="do…while 循环语句"></a>do…while 循环语句</h2><p>先执行一次，再判断</p><h2 id="for-循环语句"><a href="#for-循环语句" class="headerlink" title="for 循环语句"></a>for 循环语句</h2><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p>for(表达式; 表达式2; 表达式3){<br>  语句序列<br>}</p><h3 id="foreach-语句"><a href="#foreach-语句" class="headerlink" title="foreach 语句"></a>foreach 语句</h3><p>for(元素变量 x : 遍历对象 obj){<br>  引用了 x 的 java 语句.<br>}</p><h1 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h1><p>包括：<code>控制循环变量的变化方式</code>、<code>控制循环的跳转</code>。<br>控制循环的跳转需要 break、continue 两个关键字。<code>break</code> 是中断循环，<code>continue</code> 是执行下一次循环。</p><h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p>break 可以跳出 switch 结构，也可以跳出当前循环体。若有循环嵌套，则 break 只会跳出包含它的最内层的循环结构，只跳出一层循环。</p><p>如果想让 break 跳出外层循环，则使用标签功能：<br>  标签 : 循环体{<br>    break 标签名<br>  }</p><h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><p>不是立即跳出循环体，而是跳过本次循环结束前的语句，回到循环的条件测试部分，重新开始执行循环。</p><p>对于 for 循环，首先执行循环的增量部分，再执行条件测试部分。对于 while 和 do…while 循环，则直接回到条件测试部分。</p><p>continue 同样支持标签功能。</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="获取字符串信息"><a href="#获取字符串信息" class="headerlink" title="获取字符串信息"></a>获取字符串信息</h2><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><p>str.indexOf(substr) 用于返回参数字符串 substr 在指定字符串中首次出现的索引位置。如果没有检索到字符串 substr，则返回值是 -1。</p><blockquote><p>在计算机中 String 对象使用数组表示的。字符串的下标是 0~length()-1</p></blockquote><p>str.lastIndexOf(String str) 用于返回指定字符串最后一次出现的索引位置。如果参数是空字符串（””），则返回的结果是字符串的长度。</p><h3 id="获取指定索引位置的字符"><a href="#获取指定索引位置的字符" class="headerlink" title="获取指定索引位置的字符"></a>获取指定索引位置的字符</h3><p><code>str.charAt(int index)</code> 返回指定索引处的字符。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="获取子字符串"><a href="#获取子字符串" class="headerlink" title="获取子字符串"></a>获取子字符串</h3><p><code>str.substring(int beginIndex)</code> 返回的是从指定的索引位置开始截取知道该字符串结尾的子串。</p><p><code>substring(int beginIndex, int endIndex)</code> 返回的是字符串某一索引位置开始截取至某一索引位置结束的子串。</p><h3 id="去除空格"><a href="#去除空格" class="headerlink" title="去除空格"></a>去除空格</h3><p><code>str.trim()</code> 返回字符串的副本，忽略前导空格和尾部空格。</p><h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p><code>str.replace(char oldChar, char newChar)</code> 将指定的字符或字符串所有都替换成新的字符或字符串。</p><h3 id="判断字符串的开始和结尾"><a href="#判断字符串的开始和结尾" class="headerlink" title="判断字符串的开始和结尾"></a>判断字符串的开始和结尾</h3><p><code>str.stratsWith(String prefix)</code> 判断当前字符串对象的前缀是否为参数指定的字符串。</p><p><code>str.endsWith(String suffix)</code> 判断当前字符串是否以给定的字符串结束。</p><h3 id="判断字符串是否相等"><a href="#判断字符串是否相等" class="headerlink" title="判断字符串是否相等"></a>判断字符串是否相等</h3><p>比较运算符 <code>==</code> 用于比较两个字符串的地址是否相同。即使两个字符串的内容相同，两个对象的内存地址是不相同的，返回 false。</p><p><code>str.equals(String otherstr)</code> 如果两个<code>字符串内容</code>相等（区分大小写），则返回 true。</p><p><code>str.equalsIgnoreCase(String otherstr)</code> 忽略大小写情况下，如果两个<code>字符串内容</code>相等，则返回 true。</p><h3 id="按字典顺序比较两个字符串"><a href="#按字典顺序比较两个字符串" class="headerlink" title="按字典顺序比较两个字符串"></a>按字典顺序比较两个字符串</h3><p><code>str.compareTo(String otherstr)</code> 按字典顺序比较两个字符串，基于字符串中各个字符的 <code>Unicode</code> 值。如果 String 对象位于参数字符串之前，则返回一个负整数；如果位于之后，则返回一个正整数；如果两者相等，则结果为 0。</p><h3 id="字母大小写转换"><a href="#字母大小写转换" class="headerlink" title="字母大小写转换"></a>字母大小写转换</h3><p><code>str.toLowerCase</code> 将原字符串中每个字符从<code>大写字母</code>等价转换为<code>小写字母</code>。</p><p><code>str.toUpperCase</code> 将原字符串中每个字符从<code>小写字母</code>等价转换为<code>大写字母</code>。</p><h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p>使用 <code>split()</code> 方法可以使字符串按指定的分割字符或字符串对内容进行分割，并将分割后的结果存放在<code>字符串数组</code>中。</p><p><code>str.split(String sign)</code> 根据给定的分隔符对字符串进行拆分。sign 为分割字符串的<code>分隔符</code>，也可以使用<code>正则表达式</code>。</p><p><code>str.split(String sign, int limit)</code> 根据给定的分隔符对字符串进行拆分，并限定拆分的次数。</p><blockquote><p>没有统一的对字符进行分割的符号，如果想定义多个分割符，可以使用符号 <code>|</code>。例如，<code>,|=</code> 表示分割符为 <code>,</code>和<code>=</code> 。</p></blockquote><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p><code>str.format(String format, Object…args)</code> 使用指定的<code>格式字符串</code>和参数返回一个格式化字符串，格式化后的新字符串使用本地默认的语言环境。</p><p><code>str.format(Local l, String format, Object…args)</code> </p><blockquote><p><code>l</code> : 格式化过程中要应用的语言环境。如果 l 为 <code>null</code>，则不进行本地化 。</p><p><code>format</code> : 格式字符串。</p><p><code>args</code> : 格式字符串中由格式说明符引用的参数。如果还有格式说明符以外的参数，则忽略这些额外的参数。此参数的数目是可变的，可以为 0 。</p></blockquote><h3 id="日期和时间字符串格式化"><a href="#日期和时间字符串格式化" class="headerlink" title="日期和时间字符串格式化"></a>日期和时间字符串格式化</h3><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();   <span class="comment">//创建 Date 对象 date</span></span><br><span class="line">String s = String.format(<span class="string">"%te"</span>, date);<span class="comment">//通过 format() 方法对 date 进行格式化</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/32299414.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/36628557.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="格式化常见的日期时间组合"><a href="#格式化常见的日期时间组合" class="headerlink" title="格式化常见的日期时间组合"></a>格式化常见的日期时间组合</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/20083769.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="常规类型格式化"><a href="#常规类型格式化" class="headerlink" title="常规类型格式化"></a>常规类型格式化</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/22126843.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><p>正则表达式用于判断语句中，用来检查某一字符串是否满足某一格式。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/94978002.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/19763480.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-15/69503230.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="字符串生成器"><a href="#字符串生成器" class="headerlink" title="字符串生成器"></a>字符串生成器</h2><p>使用 <code>+</code> 可以达到附加新字符或字符串的目的，但 <code>+</code> 会产生一个新的 String 实例，会在内存中创建新的字符串对象。</p><p>如果程序中频繁地附加字符串，建议使用 StringBuilder。</p><p>新创建的 StringBuilder 对象初始容量是 <code>16</code> 个字符，可以<code>自行指定初始长度</code>。如果附加的字符超过可容纳的长度，则 StringBuilder 对象将<code>自动增加长度</code>以容纳附加的字符。</p><h3 id="StringBuilder-方法"><a href="#StringBuilder-方法" class="headerlink" title="StringBuilder 方法"></a>StringBuilder 方法</h3><ul><li><code>append(content)</code> 用于向字符串生成器中追加内容；</li><li><code>insert(int offset, arg)</code> 用于向字符串生成器中的指定位置插入数据内容；</li><li><code>delete(int start, int end)</code> 用于移除此序列的字符串中的字符；（左闭右开）</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组的创建及应用"><a href="#一维数组的创建及应用" class="headerlink" title="一维数组的创建及应用"></a>一维数组的创建及应用</h2><h3 id="创建一维数组"><a href="#创建一维数组" class="headerlink" title="创建一维数组"></a>创建一维数组</h3><p>1、先声明，再用 new 运算符进行内存分配</p><p><strong>声明一维数组</strong>：</p><p><code>数组元素类型 数组名字[]</code> </p><p><code>数组元素类型[] 数组名字</code> </p><p><strong>为数组分配内存空间</strong>：</p><p><code>数组名字 = new 数组元素的类型[数组元素的个数]</code></p><p>假如创建的数组有 <code>5 个元素</code>，因此数组中元素的<code>下标为 0~4</code> 。</p><p>2、声明的同时为数组分配内存</p><p><code>数组元素的类型[] 数组名 = new 数组元素的类型[数组元素的个数]</code></p><h3 id="初始化一维数组"><a href="#初始化一维数组" class="headerlink" title="初始化一维数组"></a>初始化一维数组</h3><p><code>数组元素类型[] 数组名字 = new 数组元素类型[]{元素, 元素, …}</code></p><p><code>数组元素类型[] 数组名字 = {元素, 元素, …}</code></p><h3 id="使用一维数组"><a href="#使用一维数组" class="headerlink" title="使用一维数组"></a>使用一维数组</h3><p><code>数组名字[0] = 元素1;</code></p><p><code>数组名字[1] = 元素2;</code></p><p>……</p><h2 id="二维数组的创建及使用"><a href="#二维数组的创建及使用" class="headerlink" title="二维数组的创建及使用"></a>二维数组的创建及使用</h2><p>二维数组常用于表示表。第一个下标代表元素所在的行，第二个下标代表元素所在的列。</p><h3 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h3><p>1、先声明，再用 new 运算符进行内存分配</p><p><strong>声明二维数组</strong>：</p><p><code>数组元素类型 数组名字[][]</code> </p><p><code>数组元素类型[][] 数组名字</code> </p><p><strong>为数组分配内存空间</strong>：</p><p><code>数组名字 = new 数组元素的类型[数组元素的个数 1][数组元素的个数 2]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数组名字 = new 数组元素的类型[数组元素的个数 1][]</span><br><span class="line">数组名字[0] = new 数组元素类型[数组元素的个数]</span><br><span class="line">数组名字[1] = new 数组元素类型[数组元素的个数]</span><br><span class="line">…………</span><br><span class="line">数组名字[数组元素的个数 1] = new 数组元素类型[数组元素的个数]</span><br></pre></td></tr></table></figure><p>假如创建的数组有 <code>5 个元素</code>，因此数组中元素的<code>下标为 0~4</code> 。</p><p>2、声明的同时为数组分配内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数组名字 = new 数组元素的类型[数组元素的个数 1][]</span><br><span class="line">数组名字[0] = new 数组元素类型[数组元素的个数]</span><br><span class="line">数组名字[1] = new 数组元素类型[数组元素的个数]</span><br><span class="line">…………</span><br><span class="line">数组名字[数组元素的个数 1] = new 数组元素类型[数组元素的个数]</span><br></pre></td></tr></table></figure><h3 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h3><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>遍历二维数组一般使用双层 for 循环，通过数组的 length 属性可获得数组的长度。</p><h3 id="填充替换数组元素"><a href="#填充替换数组元素" class="headerlink" title="填充替换数组元素"></a>填充替换数组元素</h3><p>数组中的元素定义完成后，可通过 <code>Arrays</code> 类的静态方法 <code>fill()</code> 对数组中的元素进行替换。</p><p><code>Arrays.fill(数组类型[] 数组名字, 数组类型 value)</code> 将指定的 value 分配给数组的每个元素。</p><p><code>Arrays.fill(数组类型[] 数组名字, int fromIndex, int toIndex ,数组类型 value)</code> </p><ul><li><code>fromIndex</code> 用指定值填充的第一个元素的索引（包括）</li><li><code>toIndex</code> 使用指定值填充的最后一个元素的索引（不包括）</li></ul><h3 id="对数组进行排序"><a href="#对数组进行排序" class="headerlink" title="对数组进行排序"></a>对数组进行排序</h3><p><code>Arrays.sort(object)</code></p><blockquote><p>Java 中的 String 类型数组的排序算法是根据字典编排顺序排序的，因此数字排在字母前面，大写字母排在小写字母前面。</p></blockquote><h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><p><code>Arrays.copyOf(数组名字, 数组类型 newlength)</code></p><p><code>Arrays.copyOfRange(数组名字, int fromIndex, int toIndex)</code></p><h3 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h3><p>Arrays 类的 binarySearch() 方法，可使用<code>二分搜索法</code>来搜索指定数组，以获得指定对象。</p><p><code>binarySearch(Object[] a, Object key)</code> </p><ul><li><code>a</code> 要搜索的数组</li><li><code>key</code> 要搜索的值</li></ul><p><strong>必须在进行此调用之前对数组进行排序。</strong></p><p><code>binarySearch(Object[] a, int fromIndex, int toIndex, Object key)</code> </p><h2 id="数组排序算法"><a href="#数组排序算法" class="headerlink" title="数组排序算法"></a>数组排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>由小到大排序。依据对比相邻的元素值。</p><p>冒泡算法由双层循环实现，外层是比较的轮数 ；内层是每轮比较的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">        <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮的初始是 true</span></span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为 false</span></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//把无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">                    lastExchangeIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastExchangeIndex;</span><br><span class="line">            <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] array = new int[]&#123;63,4,24,1,3,15&#125;;</span></span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法为已经优化后的。</p><ul><li><code>isSorted</code> 避免在所有元素都在有序情况下，坚持走完所有轮数</li><li><code>lastExchangeIndex</code> 记录最后一次元素交换的位置</li><li><code>sortBorder</code> 避免在后面的元素是有序情况下，坚持去比较。之后的元素肯定是有序的，所以不用比较</li></ul><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= array.length-i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(array[j] &gt; array[index]) &#123;</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = array[array.length-i];</span><br><span class="line">array[array.length-i] = array[index];</span><br><span class="line">array[index]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">63</span>,<span class="number">4</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>&#125;;</span><br><span class="line">            sort(array);</span><br><span class="line">            System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转排序"><a href="#反转排序" class="headerlink" title="反转排序"></a>反转排序</h3><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><p>类就是<code>封装对象属性和行为的载体</code>，对象就是<code>类抽象出来的一个实例</code>。其中，对象的属性就是成员变量，行为就是方法。</p><p>封装是面向对象编程的核心思想。将对象的属性和行为封装起来，其载体就是类，类通常对客户隐藏其实现细节。保证内部数据结构的完整性，避免外部操作对内部数据的影响。</p><p>继承是避免重复去定义属性和行为。</p><p>多态就是将父类对象应用于子类的特征。依赖于抽象类和接口。</p><ul><li>在多态机制中，父类通常会被定义为抽象类，在抽象类中给出一个方法的标准，而不给出实现的具体流程。</li><li>在多态机制中，将抽象类定义为接口更方便。由抽象方法组成的集合就是接口。</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>java 中对象的属性就是成员变量。</p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>Java 中使用成员方法对应于类对象的行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    …<span class="comment">//方法体</span></span><br><span class="line">        <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>成员方法可以有参数，这个参数可以是对象，也可以是基本数据类型</li><li>成员方法可以有有返回值，也可以有不返回值（使用 void 关键字）</li><li>返回值可以是计算结果，也可以是其他数值和对象，但返回值类型要与方法返回的值类型一致</li><li>成员方法可以调用其他成员方法和类成员变量</li><li>成员方法内可以定义局部变量</li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>对于类的成员变量、成员方法，被修饰为：</p><ul><li><code>private</code> 则只能在本类中使用，在子类中是不可见的，并且对其他包的类也是不可见；</li><li><code>public</code> 则除了可以在本类中使用，还可以在子类和其他包的类中使用；</li><li><code>protected</code> 则只有本包内的该类的子类或其他类可以访问此类中的成员变量和成员方法；</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/8901028.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果在声明类的时候，不使用修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。</p><h3 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h3><p>在成员方法中定义的变量。方法被执行时创建，方法执行结束时销毁。</p><ul><li>局部变量在使用时必须进行赋值操作或初始化，否则会编译错误</li></ul><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>在 Java 中规定，</p><ul><li>使用 this 关键字来<code>代表本类对象的引用</code>，this 关键字被隐式地<code>用于引用对象的成员变量和方法；</code></li><li>还可以<code>作为方法的返回值</code>。</li></ul><h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><p>构造方法是一个与类同名的方法，每当类实例化一个对象时，类都会自动调用构造方法。</p><ul><li>构造方法没有返回值；</li><li>构造方法的名称要与本类的名称相同；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> 构造方法名（类名）&#123;</span><br><span class="line">    …<span class="comment">//构造方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中可以为成员变量赋值，当实例化一个本类对象时，相应的成员变量也可以初始化。</p><p><strong>如果类中没有明确定义构造方法，编译器会自动创建一个不带参数的默认构造方法</strong>。但如果类中已经存在带参数的构造方法时，编译器不会自动创建一个不带参数的构造方法。</p><h2 id="static-静态变量、常量和方法"><a href="#static-静态变量、常量和方法" class="headerlink" title="static 静态变量、常量和方法"></a>static 静态变量、常量和方法</h2><p>由 static 声明的变量、常量和方法被称为静态成员。在<code>本类或者其他类</code>中使用<code>类名.静态成员</code>调用。</p><ul><li>在静态方法中不可以使用 this 关键字；</li><li>在静态方法中不可以直接调用非静态方法；</li></ul><h2 id="类的主方法"><a href="#类的主方法" class="headerlink" title="类的主方法"></a>类的主方法</h2><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>使用 new 操作符调用构造方法来创建对象。</p><h3 id="访问对象的属性和行为"><a href="#访问对象的属性和行为" class="headerlink" title="访问对象的属性和行为"></a>访问对象的属性和行为</h3><p><code>对象.类成员</code></p><h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p><code>类名 对象引用名称 = new 类名()</code></p><ul><li>引用只是存放一个对象的内存地址，并非存放一个对象。严格地说，引用和对象是不同的，但是这种区别可以忽略。</li></ul><h3 id="对象的比较"><a href="#对象的比较" class="headerlink" title="对象的比较"></a>对象的比较</h3><ul><li><code>==</code> 比较两个对象引用的地址是否相等；</li><li><code>equals()</code> 是 String 类方法，比较两个对象引用所指的内容是否相等；</li></ul><h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><h2 id="Integer-（Long、Short）"><a href="#Integer-（Long、Short）" class="headerlink" title="Integer （Long、Short）"></a>Integer （Long、Short）</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>Integer 变量名 = new Integer(int number)</code></li><li><code>Integer 变量名 = new Integer(String str)</code></li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/92594555.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><code>toString()</code> 可以将 Integer 对象转换为<code>十进制字符串</code>;</li><li><code>toBinaryString()</code> 可以将对象转换为<code>二进制</code>;</li><li><code>toHexString()</code> 可以将对象转换为<code>十六进制;</code></li><li><code>toOctalString()</code> 可以将对象转换为<code>八进制</code>;</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/37969277.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><p><code>Boolean 变量名 = new Boolean(boolean value)</code> </p></li><li><p><code>Boolean 变量名 = new Boolean(String str)</code>  </p><p>str 不为 null 且在忽略大小写时等于 true，则分配一个表示 true 值的 Boolean 对象，否则获得一个 false 值的 Boolean 对象。</p></li></ul><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/64341997.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/4447209.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h2><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>Byte 变量名 = new Byte(byte value)</code> </li><li><code>Byte 变量名 = new Byte(String str)</code> </li></ul><p>str 要使用数值型，否则会报错</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/40206545.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="常量-2"><a href="#常量-2" class="headerlink" title="常量"></a>常量</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pb849j3l9.bkt.clouddn.com/18-7-17/69130848.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><h2 id="Double-Float"><a href="#Double-Float" class="headerlink" title="Double (Float)"></a>Double (Float)</h2><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h1 id="数字处理"><a href="#数字处理" class="headerlink" title="数字处理"></a>数字处理</h1><h2 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h2><p>Java 主要对浮点型数据进行数字格式化，其中浮点数包括 double 型和 float 型数据。</p><ul><li>使用 java.text.DecimalFormat 格式化数字</li></ul><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h3><p>Math 类中提供的众多数学函数方法，都被定义为 static 形式。</p><ul><li><code>Math.数学方法</code></li><li><code>Math.PI</code>  、<code>Math.E</code></li></ul><h3 id="常用数学运算方法"><a href="#常用数学运算方法" class="headerlink" title="常用数学运算方法"></a>常用数学运算方法</h3><ul><li>Math 类三角函数方法</li><li>Math 类指数函数方法</li><li>Math 类取整函数方法</li><li>Math 类取最大值、最小值、绝对值函数方法</li></ul><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h3 id="Math-random-方法"><a href="#Math-random-方法" class="headerlink" title="Math.random() 方法"></a>Math.random() 方法</h3><p>默认生成大于等于 0.0 且小于 1.0 的 double 型随机数。</p><h3 id="Random-类"><a href="#Random-类" class="headerlink" title="Random 类"></a>Random 类</h3><p>通过实例化 Random 对象创建一个随机数生成器。</p><h2 id="大数字运算"><a href="#大数字运算" class="headerlink" title="大数字运算"></a>大数字运算</h2><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>支持任意精度整数。</p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>支持任意精度的定点数，可以用来精确计算货币值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-主类结构&quot;&gt;&lt;a href=&quot;#Java-主类结构&quot; class=&quot;headerlink&quot; title=&quot;Java 主类结构&quot;&gt;&lt;/a&gt;Java 主类结构&lt;/h1&gt;&lt;p&gt;Java 程序的基本组成单元是&lt;code&gt;类&lt;/code&gt;，&lt;code&gt;类体&lt;/code&gt;中包括&lt;code&gt;属性&lt;/code&gt;和&lt;code&gt;方法&lt;/code&gt;。每个程序都必须包含一个 &lt;code&gt;main()&lt;/code&gt; 方法，含有 main() 方法的类称为&lt;code&gt;主类&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 屏幕适配</title>
    <link href="http://yoursite.com/2018/07/13/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>http://yoursite.com/2018/07/13/屏幕适配/</id>
    <published>2018-07-13T11:07:43.000Z</published>
    <updated>2018-07-13T11:08:24.538Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="屏幕适配" scheme="http://yoursite.com/tags/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2018/07/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/07/13/线程池/</id>
    <published>2018-07-13T04:24:47.000Z</published>
    <updated>2018-07-13T11:16:46.001Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/seu_calvin/article/details/52415337" target="_blank" rel="noopener">Android 中常见的4种线程池（保证你能看懂并理解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/seu_calvin/article/details/52415337&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 中常见的4种线程池（保证你能看懂并理解&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>混合开发</title>
    <link href="http://yoursite.com/2018/07/13/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/07/13/混合开发/</id>
    <published>2018-07-13T02:03:59.000Z</published>
    <updated>2018-07-13T02:05:52.688Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Hybrid" scheme="http://yoursite.com/tags/Hybrid/"/>
    
  </entry>
  
  <entry>
    <title>App 设计</title>
    <link href="http://yoursite.com/2018/07/13/App%20%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/07/13/App 设计/</id>
    <published>2018-07-13T02:01:56.000Z</published>
    <updated>2018-07-13T11:30:26.154Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/tiankongcheng6/article/details/60966281" target="_blank" rel="noopener">Android 中 vector 用法详解</a></p><p><a href="https://blog.csdn.net/p106786860/article/details/53843934" target="_blank" rel="noopener">Android UI：使用矢量图，抛弃PNG</a></p><p><a href="https://www.zhihu.com/question/36813390" target="_blank" rel="noopener">码农如何从零开始做出有设计感的app？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tiankongcheng6/article/details/60966281&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 中 vector 用法详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="设计" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="Vector Assert" scheme="http://yoursite.com/tags/Vector-Assert/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2</title>
    <link href="http://yoursite.com/2018/07/11/Dagger2/"/>
    <id>http://yoursite.com/2018/07/11/Dagger2/</id>
    <published>2018-07-11T00:32:23.000Z</published>
    <updated>2018-07-12T01:32:34.857Z</updated>
    
    <content type="html"><![CDATA[<p>A fast dependency injector for Android and Java.<br><a id="more"></a></p><h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><p>只要在 app module 的 build.gradle，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ………………</span><br><span class="line">    //dagger2</span><br><span class="line">    implementation &apos;com.google.dagger:dagger:版本号&apos;</span><br><span class="line">    annotationProcessor &apos;com.google.dagger:dagger-compiler:版本号&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="新建一个无参数的类"><a href="#新建一个无参数的类" class="headerlink" title="新建一个无参数的类"></a>新建一个无参数的类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a person created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新建一个该类的提供者"><a href="#新建一个该类的提供者" class="headerlink" title="新建一个该类的提供者"></a>新建一个该类的提供者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Person <span class="title">providesPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a person created from MainModule"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Module</code> 标注的对象，你可以把它想象成一个工厂，可以向外提供一些类的对象。那么到底提供什么对象呢？</li><li><code>@Provides</code> 标注的方法就是提供对象的，这种方法一般会返回一个对象实例，例如上面返回一个 Person 对象。</li></ul><h2 id="新建一个-component-容器"><a href="#新建一个-component-容器" class="headerlink" title="新建一个 component 容器"></a>新建一个 component 容器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(modules = &#123;MainModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以把它想成一个容器， module 中产出的东西都放在里面，然后将 <code>component</code> 与我要注入的 <code>MainActivity</code> 做关联，MainActivity 中需要的 person 就可以从 component 中去取出来。</p><ul><li><p><code>@Component</code> 表示这个接口是一个容器，并且与 <code>MainModule.class</code> 关联，它生产的东西都在这里。</p></li><li><p><code>void inject(MainActivity mainActivity);</code> 表示我怎么和要注入的类关联。这个比较抽象！</p></li></ul><h2 id="在-MainActivity-中将-component-关联进去"><a href="#在-MainActivity-中将-component-关联进去" class="headerlink" title="在 MainActivity 中将 component 关联进去"></a>在 MainActivity 中将 component 关联进去</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        MainComponent component = DaggerMainComponent.builder()</span><br><span class="line">                .mainModule(<span class="keyword">new</span> MainModule()).build();</span><br><span class="line">        component.inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@Inject</code> 在 Person 对象上添加一个 @Inject 注解，即可自动注入对象。这个时候系统看到有一个 @Inject 修饰的 Person，就知道在这个 MainComponent 中去找，并且是有 MainModule 的 Provides 修饰的方法提供的。</li></ul><h2 id="完成以上步骤，开始重建我们的项目"><a href="#完成以上步骤，开始重建我们的项目" class="headerlink" title="完成以上步骤，开始重建我们的项目"></a>完成以上步骤，开始重建我们的项目</h2><p><code>DaggerMainComponent</code> 就是你 build project 的时候，dagger 自己为你生成的具体的 component 类（我们自己定义的是 MainComponent 接口）。</p><h1 id="其他注解和情况"><a href="#其他注解和情况" class="headerlink" title="其他注解和情况"></a>其他注解和情况</h1><h2 id="单例模式-Singleton（基于Component）"><a href="#单例模式-Singleton（基于Component）" class="headerlink" title="单例模式 @Singleton（基于Component）"></a>单例模式 @Singleton（基于Component）</h2><p>基于 Component 的单例模式， 就是在这个 Component 对象中，一个对象是单例对象。如果又新创建了一个Component，那么两个 Component 中的对象是不一样的。</p><p>我们再在 MainActivity 中添加一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inejct</span></span><br><span class="line">Person person2</span><br></pre></td></tr></table></figure></p><p>并打印两个 person 对象，发现 person 会被创建两次，并且两个 person 对象也不同。如果我们希望只有一个 person 和 person2，并且都指向同一个 Person 对象，就要使用 @Singleton 注解。</p><h3 id="在-MainModule-java-的-provides-方法上需要添加-Singleton-注解"><a href="#在-MainModule-java-的-provides-方法上需要添加-Singleton-注解" class="headerlink" title="在 MainModule.java 的 provides 方法上需要添加 @Singleton 注解"></a>在 MainModule.java 的 provides 方法上需要添加 @Singleton 注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">Person <span class="title">providesPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a person created from MainModule"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-MainComponent-java-类上添加-Singleton-注解"><a href="#在-MainComponent-java-类上添加-Singleton-注解" class="headerlink" title="在 MainComponent.java 类上添加 @Singleton 注解"></a>在 MainComponent.java 类上添加 @Singleton 注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Component</span>(modules = &#123;MainModule.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(MainActivity mainActivity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行，发现 person 只创建了一次，并且两个 person 指向同一个对象。</p><p>需要注意的是：单例是基于 Component 的，所以不仅 Provides 的地方要加 @Singleton，Component 上也需要加。并且如果有另外一个 OtherActivity，并且创建了一个 MainComponent，也注入 Person，这个时候 MainActivity 和 OtherActivity 中的 Person 是不构成单例的，因为它们的 Component 是不同的。</p><h2 id="带有参数的依赖对象"><a href="#带有参数的依赖对象" class="headerlink" title="带有参数的依赖对象"></a>带有参数的依赖对象</h2><p>如果构造 Person 类，需要一个参数 Context，我们怎么注入呢？ 要知道注入的时候我们只有一个 @Inject 注解，并不能带参数。所以我们需要再 MainModule 中提供 context，并且由 providesXXX 函数自己去构造。</p><h3 id="新建一个带参数的类"><a href="#新建一个带参数的类" class="headerlink" title="新建一个带参数的类"></a>新建一个带参数的类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Person"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"我是一个带参数的男人"</span> + context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改该类的提供者"><a href="#修改该类的提供者" class="headerlink" title="修改该类的提供者"></a>修改该类的提供者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainModule"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainModule</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">providesContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">providesPerson</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"person from module "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>providesPerson(Context context)</code> 中的 <code>context</code> 不能直接使用成员变量 <code>this.context</code>，而是要在本类中提供一个<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">providesContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>方法，这样在发现需要 <code>context</code> 的时候会调用 <code>provideContext</code> 来获取，这也是为了解耦。</p><h1 id="依赖一个组件"><a href="#依赖一个组件" class="headerlink" title="依赖一个组件"></a>依赖一个组件</h1><h1 id="自定义标记-Qualifier-和-＠Named"><a href="#自定义标记-Qualifier-和-＠Named" class="headerlink" title="自定义标记 @Qualifier 和 ＠Named"></a>自定义标记 @Qualifier 和 ＠Named</h1><h2 id="Named-“…”"><a href="#Named-“…”" class="headerlink" title="@Named(“…”)"></a>@Named(“…”)</h2><h2 id="Qualifier自定义标签"><a href="#Qualifier自定义标签" class="headerlink" title="@Qualifier自定义标签"></a>@Qualifier自定义标签</h2><h1 id="懒加载Lazy和强制重新加载Provider"><a href="#懒加载Lazy和强制重新加载Provider" class="headerlink" title="懒加载Lazy和强制重新加载Provider"></a>懒加载Lazy和强制重新加载Provider</h1><h1 id="Scope-自定义生命周期"><a href="#Scope-自定义生命周期" class="headerlink" title="@Scope 自定义生命周期"></a>@Scope 自定义生命周期</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/google/dagger" target="_blank" rel="noopener">google/dagger</a><br><a href="https://www.jianshu.com/p/92f793e76654" target="_blank" rel="noopener">Dagger2入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A fast dependency injector for Android and Java.&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Dagger2" scheme="http://yoursite.com/tags/Dagger2/"/>
    
  </entry>
  
  <entry>
    <title>ButterKnife</title>
    <link href="http://yoursite.com/2018/07/11/ButterKnife/"/>
    <id>http://yoursite.com/2018/07/11/ButterKnife/</id>
    <published>2018-07-11T00:31:58.000Z</published>
    <updated>2018-07-12T01:30:29.905Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ButterKnife" scheme="http://yoursite.com/tags/ButterKnife/"/>
    
  </entry>
  
  <entry>
    <title>旅游记账助手</title>
    <link href="http://yoursite.com/2018/07/11/%E6%97%85%E6%B8%B8%E8%AE%B0%E8%B4%A6%E5%8A%A9%E6%89%8B/"/>
    <id>http://yoursite.com/2018/07/11/旅游记账助手/</id>
    <published>2018-07-11T00:31:58.000Z</published>
    <updated>2018-07-11T00:37:43.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>记账（AA 制）</p><p>旅游攻略</p><p>景点导航</p><p>相机</p><p>紧急电话</p><p>注意事项分享提醒（护照、衣物、登机牌…………）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h1&gt;&lt;p&gt;记账（AA 制）&lt;/p&gt;
&lt;p&gt;旅游攻略&lt;/p&gt;
&lt;p&gt;景点导航&lt;/p&gt;
&lt;p&gt;相机&lt;/p&gt;
&lt;p&gt;紧急电话&lt;/p&gt;
&lt;p&gt;注意事项分享提醒
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="记账" scheme="http://yoursite.com/tags/%E8%AE%B0%E8%B4%A6/"/>
    
  </entry>
  
  <entry>
    <title>异常捕获代码</title>
    <link href="http://yoursite.com/2018/07/06/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2018/07/06/异常捕获代码/</id>
    <published>2018-07-06T05:48:15.000Z</published>
    <updated>2018-07-06T05:48:15.430Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Content Provider 内容提供器</title>
    <link href="http://yoursite.com/2018/07/06/ContentProvider%20%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/06/ContentProvider 内容提供器/</id>
    <published>2018-07-06T05:26:27.000Z</published>
    <updated>2018-07-08T01:53:52.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><code>内容提供器</code>主要用于在不同的应用程序之间实现数据共享功能，是 Android 实现跨程序共享数据的标准方式。</p><a id="more"></a><h1 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h1><h2 id="Android-的权限机制"><a href="#Android-的权限机制" class="headerlink" title="Android 的权限机制"></a>Android 的权限机制</h2><p>每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限所对应的权限组中所有的其他权限也会同时被授权。</p><h2 id="在程序运行时申请权限"><a href="#在程序运行时申请权限" class="headerlink" title="在程序运行时申请权限"></a>在程序运行时申请权限</h2><p>1、 首先判断用户是不是已经给我们授权了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ContextCompat.checkSelfPermission(Context, Manifest.permission.权限) != PackageManager.PErMISSION_GRANTED)&#123;</span><br><span class="line">  ActivityCompat.requestPermissions(Context, <span class="keyword">new</span> String[]&#123;Manifest.permission.权限&#125;, 常量);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 如果已经授权就执行逻辑操作；如果没有授权，则调用 <code>ActivityCompat.requestPermissions()</code> 方法，最终回调到 <code>onRequestPermissionResult()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, String[] permissions, <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> 常量:</span><br><span class="line">            <span class="keyword">if</span>(grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PErMISSION_GRANTED)&#123;</span><br><span class="line">              <span class="comment">//do something</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">//do another thing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h1><p>如果想要访问内容提供器中共享的数据，就一定要借助 ContentResolver 类，通过 Context 的 getContentResolver() 方法获得实例。</p><h2 id="ContentResolver-的基本用法"><a href="#ContentResolver-的基本用法" class="headerlink" title="ContentResolver 的基本用法"></a>ContentResolver 的基本用法</h2><ul><li>insert() ：增加数据</li><li>update() ：更新数据</li><li>delete() ：删除数据</li><li>query()  ：查询数据</li></ul><p>ContentResolver 中的增删改查方法都不是接受表名参数，而是使用一个 Uri 参数代替，即<code>内容 URI</code>。</p><h3 id="关于内容-URI"><a href="#关于内容-URI" class="headerlink" title="关于内容 URI"></a>关于内容 URI</h3><p><code>内容 URI</code> 由 <code>authority</code> 和 <code>path</code> 组成。其中：</p><ul><li><p>authority 是用于对不同的应用程序做区分的，采用程序包命名。例如：com.example.app.Provider。</p></li><li><p>path 是对同一程序不同的表做区分的，通常添加到 authority 后面。例如：com.example.app.Provider/table1，com.example.app.Provider/table2。</p></li></ul><p>解析内容 URI 的方法：<br><code>Uri uri = Uri.parse(&quot;com.example.app.Provider/table1&quot;);</code></p><h3 id="增删改查方法演示"><a href="#增删改查方法演示" class="headerlink" title="增删改查方法演示"></a>增删改查方法演示</h3><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = getContentResolver().query(</span><br><span class="line">  uri,</span><br><span class="line">  projection,</span><br><span class="line">  selection,</span><br><span class="line">  selectionArgs,</span><br><span class="line">  sortOrder</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">query() 方法参数</th><th style="text-align:left">对应 SQL 部分</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">uri</td><td style="text-align:left">from table_name</td><td style="text-align:left">指定查询某个应用程序下的某一张表</td></tr><tr><td style="text-align:left">projection</td><td style="text-align:left">select column1，column2</td><td style="text-align:left">指定查询的列名</td></tr><tr><td style="text-align:left">selection</td><td style="text-align:left">where column = value</td><td style="text-align:left">指定 where 的约束条件</td></tr><tr><td style="text-align:left">selectionArgs</td><td style="text-align:left">-</td><td style="text-align:left">为 where 中的占位符提供具体的值</td></tr><tr><td style="text-align:left">orderBy</td><td style="text-align:left">order by column1,column2</td><td style="text-align:left">指定查询结果的排序方式</td></tr></tbody></table><p>查询完成后返回的仍然是一个 Cursor 对象，将数据从 Cursor 对象中读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cursor != <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="keyword">while</span>(cursor.moveToNext())&#123;</span><br><span class="line">    String column1 = cursor.getstring(cursor.getColumnIndex(<span class="string">"column1"</span>));</span><br><span class="line">    <span class="keyword">int</span> column2 = cursor.getInt(cursor.getColumnIndex(<span class="string">"column2"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  cursor.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>, <span class="string">"text"</span>);</span><br><span class="line">values.put(<span class="string">"column2"</span>, <span class="number">1</span>);</span><br><span class="line">getContentResolver().insert(uri, values);</span><br></pre></td></tr></table></figure><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">values.put(<span class="string">"column1"</span>, <span class="string">""</span>);</span><br><span class="line">getContentResolver().update(uri, values, <span class="string">"column1 = ? and column2 = ?"</span>, <span class="keyword">new</span> String[] &#123;<span class="string">"text"</span>, <span class="string">"1"</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p><code>getContentResolver().delete(uri, &quot;column2 = ?&quot;, new String[] {&quot;1&quot;})</code></p><h1 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&lt;code&gt;内容提供器&lt;/code&gt;主要用于在不同的应用程序之间实现数据共享功能，是 Android 实现跨程序共享数据的标准方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="内容提供器" scheme="http://yoursite.com/tags/%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView使用</title>
    <link href="http://yoursite.com/2018/07/05/RecyclerView%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/RecyclerView使用/</id>
    <published>2018-07-05T05:48:59.000Z</published>
    <updated>2018-07-05T05:48:59.578Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fragment 使用</title>
    <link href="http://yoursite.com/2018/07/05/Fragment%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/Fragment使用/</id>
    <published>2018-07-05T05:48:36.000Z</published>
    <updated>2018-07-08T01:12:54.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fragment-的-add、hide、show"><a href="#Fragment-的-add、hide、show" class="headerlink" title="Fragment 的 add、hide、show"></a>Fragment 的 add、hide、show</h1><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加 Fragment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragmentManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragmentTag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addFragment</span><span class="params">(FragmentManager fragmentManager, Fragment fragment, String fragmentTag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fragmentManager != <span class="keyword">null</span>)&#123;</span><br><span class="line">            FragmentTransaction transaction = fragmentManager.beginTransaction();</span><br><span class="line">            transaction.add(R.id.frag_main, fragment, fragmentTag);</span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示已存在的 Fragment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragmentManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(FragmentManager fragmentManager, Fragment fragment)</span></span>&#123;</span><br><span class="line">        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span><br><span class="line">        <span class="keyword">if</span> (fragment != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fragmentTransaction.show(fragment);</span><br><span class="line">            fragmentTransaction.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏所有的 Fragment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fragmentManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hideAllFragment</span><span class="params">(FragmentManager fragmentManager)</span></span>&#123;</span><br><span class="line">        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span><br><span class="line"></span><br><span class="line">        Fragment dashboard_fragment = fragmentManager.findFragmentByTag(<span class="string">"dashboard_fragment"</span>);</span><br><span class="line">        <span class="keyword">if</span> (dashboard_fragment != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fragmentTransaction.hide(dashboard_fragment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fragmentTransaction.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="noopener">Fragment全解析系列</a></li><li><a href="https://www.jianshu.com/p/662c46cd3b5f" target="_blank" rel="noopener">Fragment你真的熟悉吗？看了才知道</a></li><li><a href="https://www.jianshu.com/p/28ca4cbe190c" target="_blank" rel="noopener">Android基础：Fragment，看这篇就够了</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Fragment-的-add、hide、show&quot;&gt;&lt;a href=&quot;#Fragment-的-add、hide、show&quot; class=&quot;headerlink&quot; title=&quot;Fragment 的 add、hide、show&quot;&gt;&lt;/a&gt;Fragment 的 add、hide、show&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>自定义 View</title>
    <link href="http://yoursite.com/2018/07/05/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    <id>http://yoursite.com/2018/07/05/自定义View/</id>
    <published>2018-07-05T05:48:16.000Z</published>
    <updated>2018-07-05T11:03:06.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="http://www.gcssloop.com/customview/CustomViewIndex/" target="_blank" rel="noopener">安卓自定义View教程</a></p></li><li><p><a href="https://blog.csdn.net/ccy0122/article/details/53241648" target="_blank" rel="noopener">仿支付宝芝麻信用的仪表盘</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.gcssloop.com/customview/CustomVie
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="自定义 View" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89-View/"/>
    
  </entry>
  
  <entry>
    <title>Intent使用</title>
    <link href="http://yoursite.com/2018/07/05/Intent%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/Intent使用/</id>
    <published>2018-07-05T05:47:59.000Z</published>
    <updated>2018-07-05T05:47:59.177Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Service 使用</title>
    <link href="http://yoursite.com/2018/07/05/Service%20%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/Service 使用/</id>
    <published>2018-07-05T05:47:42.000Z</published>
    <updated>2018-07-19T03:28:18.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p><code>服务</code>是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些<code>不需要和用户交互而还要求长期运行的任务</code>。</p></blockquote><p>服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。但服务不是运行在一个独立的进程中，而是依赖于创建服务时所在的应用程序。当应用程序进程被杀死，服务也会被停止运行。</p><p>服务并不会自动开启线程，默认运行在主线程中。</p><a id="more"></a><h1 id="Android-多线程"><a href="#Android-多线程" class="headerlink" title="Android 多线程"></a>Android 多线程</h1><h2 id="线程基本用法"><a href="#线程基本用法" class="headerlink" title="线程基本用法"></a>线程基本用法</h2><p>1.继承的方式耦合性有点高<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//处理具体的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyThread().start();</span><br></pre></td></tr></table></figure></p><p>2.实现 Runnable 接口的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//处理具体的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="keyword">new</span> Thread(myThread).start();</span><br></pre></td></tr></table></figure></p><p>3.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//处理具体的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p><h2 id="在子线程中更新-UI"><a href="#在子线程中更新-UI" class="headerlink" title="在子线程中更新 UI"></a>在子线程中更新 UI</h2><p>Android 是不允许在子线程中更新 UI。但它提供了一套<code>异步消息处理机制</code>，可以解决在子线程中进行 UI 操作。</p><ul><li><p>首先在主线程创建一个 Handler，并重写 handleMessage() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">     <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">       <span class="keyword">case</span> 常量</span><br><span class="line">       <span class="comment">//在这里进行 UI 操作</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在需要更新 UI 的子线程中创建一个 Message 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">message.what = 常量;</span><br><span class="line">handler.sendMessage(message); <span class="comment">//将 Message 对象发送出去</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="解析异步消息处理机制"><a href="#解析异步消息处理机制" class="headerlink" title="解析异步消息处理机制"></a>解析异步消息处理机制</h2><p>Android 的异步消息处理机制由 4 部分组成：Message、Handler、MessageQueue、Looper。</p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>Message 是在线程之间传递消息，可以在内部携带少量消息，用于在不同线程之间交换数据。<code>what</code> 字段携带 String 数据，<code>arg1</code>、<code>arg2</code> 字段携带整型数据，<code>obj</code> 字段携带一个 Object 对象。</p><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>主要用于发送和处理消息。<br>发送消息一般用 Handler 的 <code>sendMessage()</code> 方法。<br>接收消息 Handler 的 <code>handleMessage()</code> 方法。</p><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>MessageQueue 是消息队列，主要用于存放所有通过 Handler 发送的消息。<code>每个线程只会有一个 MessageQueue 对象</code>。</p><h3 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h3><p>Looper 是每个线程中的 MessageQueue 管家，调用 Looper 的 <code>loop()</code> 方法后，就会进入一个无限循环，每当发现 MessageQueue 中存在的一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。<code>每个线程只有一个 Looper 对象</code>。</p><h2 id="使用-AsyncTask"><a href="#使用-AsyncTask" class="headerlink" title="使用 AsyncTask"></a>使用 AsyncTask</h2><p>由于 AsyncTask 是一个抽象类，所以我们需要<code>创建一个子类去继承</code>。</p><h3 id="AsyncTask-类的-3-个泛型参数："><a href="#AsyncTask-类的-3-个泛型参数：" class="headerlink" title="AsyncTask 类的 3 个泛型参数："></a>AsyncTask 类的 3 个泛型参数：</h3><ul><li>Params ：在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。</li><li>Progress ：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型为进度单位。</li><li>Result ：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</li></ul><h3 id="AsyncTask-几个方法："><a href="#AsyncTask-几个方法：" class="headerlink" title="AsyncTask 几个方法："></a>AsyncTask 几个方法：</h3><ul><li>onPreExecute() ：<br>这个方法会在<code>后台任务开始执行之前调用</code>，用于进行一些界面上的初始化操作，比如显示一个进度条对话框。</li><li>doInBackground(Params…) :<br>1、 所有代码都会在子线程中运行；<br>2、 任务一旦完成就会返回 return 语句，但如果 AsyncTask 第三个泛型参数为 Void，则不返回任务执行结果；<br>3、 这个方法中不可以执行 UI 操作，如果要执行 UI 操作，则可以调用 publishProgress(Progress…) 方法完成；</li><li>onProgressUpdate(Progress…) ：<br>当后台任务中调用 publishProgress(Progress…) 方法后，onProgressUpdate(Progress…) 方法就会调用。</li><li>onPostExcute(Result) ：<br>当<code>后台任务执行完毕</code>并通过 return 语句执行返回时，这个方法就会调用。</li></ul><h3 id="AsyncTask-总结"><a href="#AsyncTask-总结" class="headerlink" title="AsyncTask 总结"></a>AsyncTask 总结</h3><p>doInBackground(Params…) 执行具体的耗时任务；<br>onProgressUpdate(Progress…) 进行更新 UI；<br>onProgressUpdate(Progress…) 执行任务收尾；</p><p>启动这个任务：<code>new targetTask().execute();</code></p><h1 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h1><h2 id="定义一个服务"><a href="#定义一个服务" class="headerlink" title="定义一个服务"></a>定义一个服务</h2><p>创建一个 Service 并在 AndroidManifest 中注册，其中 <code>Exported</code> 属性表示是否允许除了当前程序之外的其他程序访问这个服务，<code>Enabled</code> 属性表示是否启用这个服务。</p><h2 id="活动和服务进行通信"><a href="#活动和服务进行通信" class="headerlink" title="活动和服务进行通信"></a>活动和服务进行通信</h2><ol><li>创建一个子类继承 Service</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> IBinder mBinder = <span class="keyword">new</span> LocalBinder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> xxxService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> xxxService.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Activity/Fragment 中调用 Service：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> xxxService.LocalBinder localBinder;</span><br><span class="line">  <span class="keyword">private</span> xxxService mxxxService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定 xxxService 服务结果回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection serviceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            localBinder = (xxxService.LocalBinder) service; <span class="comment">//通过向下转型得到 localBinder 实例</span></span><br><span class="line">            mxxxService = localBinder.getService();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">       Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, xxxService.class);</span><br><span class="line">       bindService(bindIntent, serviceConnection, Context.BIND_AUTO_CREATE); <span class="comment">//绑定服务获取持久连接</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onDestroy();</span><br><span class="line">       unbindService(serviceConnection);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="服务的更多技巧"><a href="#服务的更多技巧" class="headerlink" title="服务的更多技巧"></a>服务的更多技巧</h1><h2 id="使用前台服务"><a href="#使用前台服务" class="headerlink" title="使用前台服务"></a>使用前台服务</h2><p>前台服务和普通服务最大区别是，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏可以看到更加详细的信息。类似于彩云天气的前台服务效果。</p><h2 id="使用-IntentService"><a href="#使用-IntentService" class="headerlink" title="使用 IntentService"></a>使用 IntentService</h2><p>一个异步的、会自动停止的服务。<code>onHandleIntent(Intent intent)</code> 方法运行在子线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">xxxIntentService</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"xxxIntentService"</span>); <span class="comment">//调用父类的有参构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//当前的逻辑已经在子线程中运行</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//打印当前线程的 id</span></span><br><span class="line">      Log.d(<span class="string">"xxxIntentService"</span>, <span class="string">"Thread id is"</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;服务&lt;/code&gt;是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些&lt;code&gt;不需要和用户交互而还要求长期运行的任务&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。但服务不是运行在一个独立的进程中，而是依赖于创建服务时所在的应用程序。当应用程序进程被杀死，服务也会被停止运行。&lt;/p&gt;
&lt;p&gt;服务并不会自动开启线程，默认运行在主线程中。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Service" scheme="http://yoursite.com/tags/Service/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Broadcast 使用</title>
    <link href="http://yoursite.com/2018/07/05/Broadcast%20%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/Broadcast 使用/</id>
    <published>2018-07-05T05:47:25.000Z</published>
    <updated>2018-07-07T03:18:41.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h1><ul><li>标准广播  完全异步执行，所有广播接收器同时接收</li><li>有序广播 同步执行，同一时刻只有一个广播接收器可以接收</li></ul><a id="more"></a><h1 id="接收系统广播"><a href="#接收系统广播" class="headerlink" title="接收系统广播"></a>接收系统广播</h1><h2 id="动态注册监听网络变化"><a href="#动态注册监听网络变化" class="headerlink" title="动态注册监听网络变化"></a>动态注册监听网络变化</h2><p>动态注册的广播接收器可以随意地控制注册和注销，但必须要在程序启动之后才能街道广播。</p><h2 id="静态注册实现开机启动"><a href="#静态注册实现开机启动" class="headerlink" title="静态注册实现开机启动"></a>静态注册实现开机启动</h2><h1 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h1><h2 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h2><h2 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h2><p>使用 <code>sendOrderBrocast()</code> 发送广播，同时需要在 AndroidManifest 中设置优先级 <code>&lt;intent-filter android:priority= &gt;</code></p><h1 id="使用本地广播"><a href="#使用本地广播" class="headerlink" title="使用本地广播"></a>使用本地广播</h1><p><code>LocalBroadcastManger</code> 来管理广播。<br><code>LocalBroadcastManger localBroadcastmanger = LocalBroadcastManger.getInstance(this);</code> 获取 <code>LocalBroadcastManger</code> 实例。<br><code>localBroadcastmanger.sendBroadcast()</code> 发送广播。<br><code>localBroadcastmanger.registerReceiver()</code> 注册广播。<br><code>localBroadcastmanger.unregisterReceiver()</code> 注销广播。</p><h1 id="利用广播实现强制下线功能"><a href="#利用广播实现强制下线功能" class="headerlink" title="利用广播实现强制下线功能"></a>利用广播实现强制下线功能</h1><ol><li><p>首先定义一个活动回收器 <code>ActivityCollector</code> 类，创建一个列表来管理活动，<code>ActivityCollector</code> 类里面包含添加活动 <code>addActivity</code>、移除活动 <code>removeActivity</code>、结束活动 <code>finishAll</code> 的方法。</p></li><li><p>创建一个 <code>BaseActivity</code> 类作为所有活动的父类，同时复写 <code>onCreate</code> 添加 <code>addActivity</code> 方法；复写 <code>onDestroy</code> 添加 <code>removeActivity</code> 方法；复写 <code>onResume</code> 在里面注册广播；复写 <code>onPause</code> 在里面注销广播；在 <code>ForceOfflineReceiver</code> 的 <code>onReceive</code> 方法里面放入 <code>finishAll</code> 方法。</p></li><li><p>让需要实现强制下线功能的 Activity 继承 <code>BaseActivity</code> 类，同时发送强制下线功能的广播。</p></li></ol><h1 id="利用静态广播实现-APP-开机自动启动"><a href="#利用静态广播实现-APP-开机自动启动" class="headerlink" title="利用静态广播实现 APP 开机自动启动"></a>利用静态广播实现 APP 开机自动启动</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;广播机制&quot;&gt;&lt;a href=&quot;#广播机制&quot; class=&quot;headerlink&quot; title=&quot;广播机制&quot;&gt;&lt;/a&gt;广播机制&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;标准广播  完全异步执行，所有广播接收器同时接收&lt;/li&gt;
&lt;li&gt;有序广播 同步执行，同一时刻只有一个广播接收器可以接收&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ViewPager使用</title>
    <link href="http://yoursite.com/2018/07/05/ViewPager%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/ViewPager使用/</id>
    <published>2018-07-05T05:47:02.000Z</published>
    <updated>2018-07-05T05:47:02.958Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
