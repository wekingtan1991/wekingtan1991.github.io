<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQLite 数据库]]></title>
    <url>%2F2018%2F07%2F24%2FSQLite%20%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[SQLiteOpenHelper该类封装了 SQLite 数据库的创建和升级工作。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SQLite</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探 Retrofit 2.0]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%88%9D%E6%8E%A2%20Retrofit%202.0%2F</url>
    <content type="text"><![CDATA[参考这是一份很详细的 Retrofit 2.0 使用教程（含实例讲解）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Retrofit 2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探 RxJava 2]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%88%9D%E6%8E%A2%20RxJava%202%2F</url>
    <content type="text"><![CDATA[参考这可能是最好的RxJava 2.x 教程（完结版） RxJava]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友盟练习]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%8F%8B%E7%9B%9F%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[友盟 + SDK Common 集成自动集成在 app 的 build.gradle 中添加： 12compile 'com.umeng.sdk:common:latest.integration'compile 'com.umeng.sdk:utdid:1.1.5.3' 如果无法正常集成则在 project 的 build.gradle 中添加： 12345allprojects &#123; repositories &#123; mavenCentral() &#125;&#125; 在 Android Studio 3.1 及以上版本开发环境下，指定引用最新版本依赖写法 latest.integration 可能导致下载库超时，此时需要指定具体版本号。 手动集成 选择 SDK 功能组件并下载后，解压.zip文件得到相应组件包（例如：umeng-common-x.x.x.jar、umeng-analytics-x.x.x.jar等），在 Android Studio 的项目工程 libs 目录中拷入相关组件jar包； 右键 Android Studio 的项目工程 —&gt; 选择 Open Module Settings —&gt; 在 Project Structure 弹出框中 —&gt; 选择 Dependencies选项卡 —&gt; 点击左下“＋” —&gt; 选择组件包类型 —&gt; 引入相应的组件包； 注意：umeng-common-x.x.x.jar为基础组件包，必须导入。 权限授予123456789101112&lt;!-- 必须的权限 --&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;!-- 推荐的权限 --&gt;&lt;!-- 添加如下权限，以便使用更多的第三方SDK和更精准的统计数据 --&gt;&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;&lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" /&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 混淆设置1-keep class com.umeng.** &#123;*;&#125; 查看日志初始化及通用接口初始化在项目工程中新建自定义 application 中的 onCreate() 中添加以下两个方法之一。 1234567public class UMApplication extends Application&#123; @Override public void onCreate() &#123; super.onCreate(); //doSomething…… &#125;&#125; 注意：一定要在主进程进行该项操作，如果您使用到 PUSH （消息推送），还需在推送进程（channel 进程）同样进行该项操作。 方法一123456789/*** 初始化common库* 参数1:上下文，不能为空* 参数2:设备类型，UMConfigure.DEVICE_TYPE_PHONE为手机、* UMConfigure.DEVICE_TYPE_BOX为盒子，默认为手机* 参数3:Push推送业务的secret*/UMConfigure.init(this, UMConfigure.DEVICE_TYPE_PHONE, " push secret number "); 如果项目的 AndroidManifest 文件中已经配置【友盟+】的 AppKey 和 Channel，则使用该方法初始化，同时不必再次传入 AppKey 和 Channel 两个参数。 1234&lt;meta-data android:value="58edcfeb310c93091c000be2" android:name="UMENG_APPKEY"/&gt;&lt;meta-data android:value="Umeng" android:name="UMENG_CHANNEL"/&gt; 方法二123456789/*** 初始化common库* 参数1:上下文，不能为空* 参数2:【友盟+】 AppKey* 参数3:【友盟+】 Channel* 参数4:设备类型，UMConfigure.DEVICE_TYPE_PHONE为手机、UMConfigure.DEVICE_TYPE_BOX为盒子，默认为手机* 参数5:Push推送业务的secret*/UMConfigure.init(this, "58edcfeb310c93091c000be2", "Umeng", UMConfigure.DEVICE_TYPE_PHONE, "1fe6a20054bcef865eeb0991ee84525b"); Channel渠道的使用规范每台设备仅记录首次安装激活的渠道，在其他渠道再次安装不会重复计量。 所以在测试不同的渠道的时候，请使用不同的设备来分别测试不要改变’UMENG_CHANNEL’。 Channel渠道的命名规范1.可以由英文字母、阿拉伯数字、下划线、中划线、空格、括号组成，可以含汉字以及其他明文字符，但是不建议使用中文命名，会出现乱码。 2.首尾字符不可以为空格。 3.不要使用纯数字作为渠道ID。 4.最多256个字符。 5.”unknown” 及其各种大小写形式，作为【友盟+】保留的字段，不可以作为渠道名。 在您查看数据时，渠道会作为一个数据细分的维度。 通用接口设置Log开关初始化时可以通过该方法设置组件化的 Log 是否输出，默认关闭 Log 输出。 12345/*** 设置组件化的Log开关* 参数: boolean 默认为false，如需查看LOG设置为true*/UMConfigure.setLogEnabled(true); 设置日志加密12345/*** 设置日志加密* 参数：boolean 默认为false（不加密）*/UMConfigure.setEncryptEnabled(true); 如果参数为true，SDK会对日志进行加密。加密模式可以有效防止网络攻击，提高数据安全性。 如果参数为false，SDK将按照非加密的方式来传输日志。 如果您没有设置加密模式，SDK的加密模式为false（不加密）。 移动统计集成自动集成1234dependencies &#123; compile 'com.umeng.sdk:common:latest.integration' compile 'com.umeng.sdk:analytics:latest.integration'&#125; 手动集成将下载的SDK zip包解压缩，得到如下文件： common/common_android_x.x.x/normal/umeng-common-x.x.x.jar // 基础组件包 analytics/analytics_android_x.x.x/umeng-analytics-x.x.x.jar // 统计SDK包 thirdparties/thirdparties_android_1.x.x/utdid4all-1.x.x.x_proguard.jar // 包含设备标识UTDID组件 thirdparties/thirdparties_android_x.x.x/SecurityEnvSDK/. // 金融风控组件，包含一个jar包和多个so库 集成步骤： 选择SDK功能组件并下载，解压.zip文件得到相应组件包（例如：umeng-common-x.x.x.jar、umeng-analytics-x.x.x.jar等），在Android Studio的项目工程libs目录中拷入相关组件jar包。 右键Android Studio的项目工程 —&gt; 选择Open Module Settings —&gt; 在 Project Structure弹出框中 —&gt; 选择 Dependencies选项卡 —&gt; 点击左下“＋” —&gt; 选择组件包类型 —&gt; 引入相应的组件包。 注意：umeng-common-x.x.x.jar为基础组件包，必须导入。 初始化及通用接口初始化在宿主应用application.onCreate函数中调用基础组件包提供的初始化函数： 1234/*注意: 即使您已经在AndroidManifest.xml中配置过appkey和channel值，也需要在App代码中调用初始化接口（如需要使用AndroidManifest.xml中配置好的appkey和channel值，UMConfigure.init调用中appkey和channel参数请置为null）。*/UMConfigure.init(Context context, String appkey, String channel, int deviceType, String pushSecret); 或者 1234/*注意：如果您已经在AndroidManifest.xml中配置过appkey和channel值，可以调用此版本初始化函数。*/UMConfigure.init(Context context, int deviceType, String pushSecret); 设置场景类型接口在初始化的 Activity 中调用： 1MobclickAgent.setScenarioType(mContext, EScenarioType.E_UM_NORMAL); context： 当前宿主进程的ApplicationContext上下文。 etype ： EScenarioType.E_UM_NORMAL 普通统计场景，如果您在埋点过程中没有使用到 U-Game统计接口，请使用普通统计场景。 EScenarioType.E_UM_GAME 游戏场景 ，如果您在埋点过程中需要使用到U-Game 统计接口，则必须设置游戏场景，否则所有的U-Game统计接口不会生效。 设置 secretkey1MobclickAgent.setSecret(mContext, "s10bacedtyz"); context ：当前宿主进程的ApplicationContext上下文。 secretkey ：secretkey需要在【友盟+】网站申请。 设置 Session 启动、App 使用时长等基础数据统计接口 API:在 App 中每个 Activity 的 onResume 方法中调用 MobclickAgent.onResume(context)，在 onPause 方法中调用 MobclickAgent.onPause(context)。 1234567891011@Overridepublic void onResume() &#123; super.onResume(); MobclickAgent.onResume(this);&#125;@Overridepublic void onPause() &#123; super.onPause(); MobclickAgent.onPause(this);&#125; 确保在所有的Activity中都调用 MobclickAgent.onResume() 和onPause()方法，这两个调用不会阻塞应用程序的主线程，也不会影响应用程序的性能。 注意：如果您的Activity之间有继承或者控制关系，请不要同时在父和子Activity中重复添加nPause和nResume方法，否则会造成重复统计，导致启动次数异常增高。(例如：使用TabHost、TabActivity、ActivityGroup时)。 当应用在后台运行超过30秒（默认）再回到前台，将被认为是两次独立的Session(启动)，例如：用户回到home，或进入其他程序，经过一段时间后再返回之前的应用。即被认为是两个独立的Session。 设置 session 间隔时长接口12// 将默认Session间隔时长改为40秒。MobclickAgent.setSessionContinueMillis(1000*40); 消息推送集成在友盟创建应用在 http://message.umeng.com 上使用你的应用包名创建应用（注：Android Studio请使用 applicationId 作为包名）。 自动集成123456//PushSDK必须依赖基础组件库，所以需要加入对应依赖compile 'com.umeng.sdk:common:1.5.3'//PushSDK必须依赖utdid库，所以需要加入对应依赖compile 'com.umeng.sdk:utdid:1.1.5.3'//PushSDKcompile 'com.umeng.sdk:push:4.2.0' 手动集成 访问友盟+官网组件化 SDK 下载地址，选择 Android 平台下载页面，选择对应业务 SDK 进行下载，并把下载的 zip 文件解压缩（解压后的文件路径不能有中文）； 把解压缩后得到的目录下的thirdparties目录里的utdid4all-*.*.*这个 jar 文件拷贝到项目工程的 libs 目录； 把解压缩后得到的目录下的push目录当做 Module 导入到自己的工程，使用 Import Module。 在 Application Module的build.gradle文件的dependencies下添加implementation project(&#39;:push&#39;)。 如果出现 implementation project(&#39;:push&#39;) 不成功，则查看在 settings.gradle 中是否包含有 include &#39;:push&#39; 。 注意： PushSDK 4.0默认只提供armeabi和x86两种so文件夹，若主工程中的so文件夹与PushSDK下的so文件夹不一致，则可以有两种方式处理（选择一种即可）：(1) 删除主工程下多余的so文件夹，与PushSDK下的so文件夹保持一致。(2) 下载全平台so文件，添加缺少的so文件夹至PushSDK模块的libs目录下，使PushSDK的so文件夹与主工程的so文件夹保持一致。全平台SO文件下载 初始化及通用接口初始化在工程的自定义Application类的 onCreate() 方法中调用基础组件包提供的初始化函数。 方法一： 仅使用代码初始化： 1UMConfigure.init(Context context, String appkey, String channel, int deviceType, String pushSecret); 方法二： 如果在AndroidManifest.xml中配置appkey和channel值，可以调用此版本初始化函数。 1UMConfigure.init(Context context, int deviceType, String pushSecret); 在AndroidManifest.xml添加： 123456&lt;meta-data android:name=&quot;UMENG_APPKEY&quot; android:value=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot; /&gt;&lt;!-- Channel ID用来标识App的推广渠道，作为推送消息时给用户分组的一个维度。--&gt;&lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;Channel ID&quot; /&gt; 说明： 若同时在AndroidManifest.xml和代码中设置了Channel，则以代码设置的为准。 若在AndroidManifest.xml和代码里均没有设置，则使用Unknown作为Channel ID。 你可以使用20位以内的英文和数字为渠道定名（不要使用纯数字）。 每台设备仅识别首次安装激活的渠道。 注册推送服务务必在工程的自定义 Application 类的 onCreate() 方法中注册推送服务，无论推送是否开启都需要调用此方法： 1234567891011121314PushAgent mPushAgent = PushAgent.getInstance(this);//注册推送服务，每次调用register方法都会回调该接口mPushAgent.register(new IUmengRegisterCallback() &#123; @Override public void onSuccess(String deviceToken) &#123; //注册成功会返回device token &#125; @Override public void onFailure(String s, String s1) &#123; &#125;&#125;); 注意： 请勿在调用register方法时做进程判断处理（主进程和channel进程均需要调用register方法才能保证长连接的正确建立）。若未按文档要求初始化，则会导致App运行时，弹出toast提示。此时，请参考下文解决。 device token是【友盟+】消息推送生成的用于标识设备的id，长度为44位，不能定制和修改。同一台设备上不同应用对应的device token不一样。 如需手动获取device token，可以调用mPushAgent.getRegistrationId()方法（需在注册成功后调用）。 统计应用启动数据在所有的Activity 的onCreate 方法或在应用的BaseActivity的onCreate方法中添加： 1PushAgent.getInstance(context).onAppStart(); 注意： 此方法与统计分析sdk中统计日活的方法无关！请务必调用此方法！ 如果不调用此方法，不仅会导致按照”几天不活跃”条件来推送失效，还将导致广播发送不成功以及设备描述红色等问题发生。可以只在应用的主Activity中调用此方法，但是由于SDK的日志发送策略，有可能由于主activity的日志没有发送成功，而导致未统计到日活数据。 配置ApplicationId请确保Application Module的build.gradle文件中的applicationId与资源包名package一致（若不一致，请参考高级功能—自定义资源包名） 社会化分享和第三方登录集成自动集成手动集成 下载最新 SDK 文件； 将main文件夹以及platform（选择你想使用的平台即可）文件下，对应的 res 文件和 jar 文件放入你的工程； 记得同步 libs 文件。 添加回调 Activity微信在包名目录下 com.xxx.xxx 创建wxapi文件夹，新建一个名为WXEntryActivity的activity继承WXCallbackActivity QQ 和新浪QQ与新浪不需要添加Activity，但需要在使用QQ分享或者授权的Activity中，添加： 12345@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); UMShareAPI.get(this).onActivityResult(requestCode, resultCode, data);&#125; 注意onActivityResult不可在fragment中实现，如果在fragment中调用登录或分享，需要在fragment依赖的Activity中实现 配置 Android Manifest.XML微信12345&lt;activity android:name=".wxapi.WXEntryActivity" android:configChanges="keyboardHidden|orientation|screenSize" android:exported="true" android:theme="@android:style/Theme.Translucent.NoTitleBar" /&gt; 权限添加如果需要使用QQ纯图分享或避免其它平台纯图分享的时候图片不被压缩，可以增加以下权限： 12&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; Android6.0权限适配12345678910if(Build.VERSION.SDK_INT&gt;=23)&#123; String[] mPermissionList = new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.ACCESS_FINE_LOCATION,Manifest.permission.CALL_PHONE,Manifest.permission.READ_LOGS,Manifest.permission.READ_PHONE_STATE, Manifest.permission.READ_EXTERNAL_STORAGE,Manifest.permission.SET_DEBUG_APP,Manifest.permission.SYSTEM_ALERT_WINDOW,Manifest.permission.GET_ACCOUNTS,Manifest.permission.WRITE_APN_SETTINGS&#125;; ActivityCompat.requestPermissions(this,mPermissionList,123); &#125;@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123;&#125; 初始化初始化需要在您的 Application 中调用我们的初始化接口： 1234567@Override public void onCreate() &#123; super.onCreate(); UMConfigure.init(this,"5a12384aa40fa3551f0001d1" ,"umeng",UMConfigure.DEVICE_TYPE_PHONE,"");//58edcfeb310c93091c000be2 5965ee00734be40b580001a0 &#125; 并且设置各个平台的 appkey 12345&#123; PlatformConfig.setWeixin(…………); PlatformConfig.setSinaWeibo(…………); ……………………&#125; 签名配置分享面板设置在需要引用 activity 中设置。 带面板12new ShareAction(MainActivity.this).withText("hello") .setDisplayList(SHARE_MEDIA.SINA,SHARE_MEDIA.QQ,SHARE_MEDIA.WEIXIN).setCallback(umShareListener).open(); 不带面板12345new ShareAction(MainActivity.this).setPlatform(SHARE_MEDIA.QQ)//传入平台.withText("hello")//分享内容.setCallback(umShareListener)//回调监听器.share(); 回调监听123456789101112131415161718192021222324252627282930313233343536373839private UMShareListener shareListener = new UMShareListener() &#123; /** * @descrption 分享开始的回调 * @param platform 平台类型 */ @Override public void onStart(SHARE_MEDIA platform) &#123; &#125; /** * @descrption 分享成功的回调 * @param platform 平台类型 */ @Override public void onResult(SHARE_MEDIA platform) &#123; Toast.makeText(ShareDetailActivity.this,"成功 了",Toast.LENGTH_LONG).show()； &#125; /** * @descrption 分享失败的回调 * @param platform 平台类型 * @param t 错误原因 */ @Override public void onError(SHARE_MEDIA platform, Throwable t) &#123; Toast.makeText(ShareDetailActivity.this,"失 败"+t.getMessage(),Toast.LENGTH_LONG).show(); &#125; /** * @descrption 分享取消的回调 * @param platform 平台类型 */ @Override public void onCancel(SHARE_MEDIA platform) &#123; Toast.makeText(ShareDetailActivity.this,"取消 了",Toast.LENGTH_LONG).show(); &#125; &#125;; 第三方登录第三方登录包含两种使用场景： 获取用户资料的授权接口，使用该接口可以获取该三方平台返回的所有资料（包括姓名，性别，头像等）目前支持第三方登录的平台包括： 国内平台（微信、新浪微博、QQ、豆瓣、人人） 国外平台（Facebook、Twitter、linkedIn、kakao、VKontakte、Dropbox） 这里推荐直接使用第一种方式实现，因为本质上三方登录最终都需要拉取三方平台的用户资料，从这点来说，直接调用SDK和通过后台服务器请求，安全性是一样的 获取用户资料1UMShareAPI.get(MainActivity.this).getPlatformInfo(MainActivity.this, SHARE_MEDIA.WEIXIN, umAuthListener); 授权回调123456789101112131415161718192021222324252627282930313233343536373839404142434445UMAuthListener authListener = new UMAuthListener() &#123; /** * @desc 授权开始的回调 * @param platform 平台名称 */ @Override public void onStart(SHARE_MEDIA platform) &#123; &#125; /** * @desc 授权成功的回调 * @param platform 平台名称 * @param action 行为序号，开发者用不上 * @param data 用户资料返回 */ @Override public void onComplete(SHARE_MEDIA platform, int action, Map&lt;String, String&gt; data) &#123; Toast.makeText(mContext, "成功了", Toast.LENGTH_LONG).show(); &#125; /** * @desc 授权失败的回调 * @param platform 平台名称 * @param action 行为序号，开发者用不上 * @param t 错误原因 */ @Override public void onError(SHARE_MEDIA platform, int action, Throwable t) &#123; Toast.makeText(mContext, "失败：" + t.getMessage(), Toast.LENGTH_LONG).show(); &#125; /** * @desc 授权取消的回调 * @param platform 平台名称 * @param action 行为序号，开发者用不上 */ @Override public void onCancel(SHARE_MEDIA platform, int action) &#123; Toast.makeText(mContext, "取消了", Toast.LENGTH_LONG).show(); &#125; &#125;; 登录成功后，第三方平台会将用户资料传回， 全部会在Map data中返回 ，由于各个平台对于用户资料的标识不同，因此为了便于开发者使用，我们将一些常用的字段做了统一封装，开发者可以直接获取，不再需要对不同平台的不同字段名做转换，这里列出我们封装的字段及含义。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>友盟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存优化与内存泄露]]></title>
    <url>%2F2018%2F07%2F19%2F%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[概念内存泄漏对象在内存 heap 堆中分配的空间，当不再使用或没有引用指向的情况下，仍不能被垃圾收集器 GC 正常回收的情况。 多数出现在不合理的编码情况下，Android 中常见就是 Activity 被引用，但在调用 finish 之后却没有释放，第二次打开 activity又重新创建，这样的内存泄漏不断的发生，则会导致内存的溢出。 比如在 Activity 中注册了一个广播接收器，但是在页面关闭的时候没有进行unRegister，就会出现内存溢出的现象。通常情况下，大量的内存泄漏会造成 OOM。 OOM（内存溢出）即 Out Of Memoery，顾名思义就是指内存溢出了。 Android 的每个应用程序都会使用一个专有的 Dalvik 虚拟机实例来运行，它是由 Zygote 服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。 Android 为不同类型的进程分配了不同的内存使用上限 。 APP 向系统申请超过最大阀值的内存请求，但系统不会再分配多余的空间，就会造成OOM error。在我们 Android 平台下，多数情况是出现在图片不当处理加载的时候。 Android 内存管理Android 应用层是由 java 开发的，Android 的 davlik 虚拟机与 jvm 也类似，只不过它是基于寄存器的。 在 java 中，通过 new 为对象分配内存，所有对象在 java 堆内分配空间；而内存的释放是由垃圾收集器（GC）来回收的。 Java采用了有向图的原理。Java 将引用关系考虑为图的有向边，有向边从引用者指向引用对象。 线程对象可以作为有向图的起始顶点，该图就是从起始顶点(GC roots)开始的一棵树，根顶点可以到达的对象都是有效对象，GC 不会回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。 Android 内存优化的关键点万恶的 static由于 static 声明变量的生命周期其实是和 APP 的生命周期一 样的，有点类似于 Application。如果大量使用的话，就会占据内存空间不释放，积少成多也会造成内存的不断开销，直至挂掉。 static 的合理使用一般用来修饰基本数据类型或者轻量级对象，尽量避免修饰集合或者大对象，常用作修饰全局配置项、工具类方法、内部类。 无关引用很多情况下，我们需求用到传递引用，但是我们无法确保引用传递出去后能否及时的回收。 比较有代表性的 Context 泄漏，很多情况下当 Activity 结束后，由于仍被其他的对象指向导致一直迟迟不能回收，这就造成了内存泄漏。这时可以考虑第三条建议。 不要让生命周期长于Activity 的对象持有到 Activity 的引用 。 善用 SoftReference/WeakReference/LruCacheJava、Android 中有没有这样一种机制呢，当内存吃紧或者 GC 扫过的情况下，就能及时把一些内存占用给释放掉，从而分配给需要分配的地方。答案是肯定的，java 为我们提供了两个解决方案： 如果对内存的开销比较关注的 APP，可以考虑使用 WeakReference，当 GC 回收扫过这块内存区域时就会回收；如果不是那么关注的话，可以使用 SoftReference，它会在内存申请不足的情况下自动释放，同样也能解决 OOM 问题； Android 自 3.0 以后也推出了 LruCache 类，使用 LRU 算法释放内存，一样的能解决 OOM，如果兼容 3.0 以下的版本，请导入 v4 包。关于 第二条的无关引用的问题，我们传参可以考虑使用 WeakReference 包装一下。 谨慎 handler在处理异步操作的时候，handler + thread 是个不错的选择。但是相信在使用 handler 的时候，大家都会遇到警告的情形，这个就是 lint 为开发者的提醒。handler 运行于 UI 线程，不断处理来自 MessageQueue 的消息，如果 handler 还有消息需要处理但是 Activity 页面已经结束的情况下，Activity 的引用其实并不会被回收，这就造成了内存泄漏。解决方案有 2 种： 在 Activity 的 onDestroy 方法中调用 handler.removeCallbacksAndMessages(null); 取消所有的消息的处理，包括待处理的消息； 声明handler的内部类为static。 Bitmap终极杀手Bitmap 的不当处理极可能造成 OOM，绝大多数情况都是因这个原因出现的。Bitamp 位图是 Android 中当之无愧的胖小子，所以在操作的时候当然是十分的小心了。由于 Dalivk 并不会主动的去回收，需要开发者在 Bitmap 不被使用的时候 recycle 掉。使用的过程中，及时释放是非常重要 的。同时如果需求允许，也可以去 BItmap 进行一定的缩放，通过 BitmapFactory.Options 的 inSampleSize 属性进行控制。 如果仅仅只想获得 Bitmap 的属性，其实并不需要根据 BItmap 的像素去分配内存，只需在解析读取 Bmp 的时候使用 BitmapFactory.Options 的 inJustDecodeBounds 属性。 最后建议大家在加载网络图片的时候，使用软引用或者弱引用并进行本地缓存，推荐使用 android-universal-imageloader 或者 xUtils，牛人出品，必属精品。 Cursor 和 I/O 流及时关闭在查询 SQLite 数据库时，会返回一个 Cursor，当查询完毕后，及时关闭，这样就可以把查询的结果集及时给回收掉。 I/O 流操作完毕，读写结束，记得关闭。 ListView 和 GridView 的 item 缓存对于移动设备，尤其硬件参差不齐的 Android 生态，页面的绘制其实是很耗时的，findViewById 也是蛮慢的。所以不重用 View，在有列表的时候就尤为显著了，经常会出现滑动很卡的现象。 页面背景和图片加载在布局和代码中设置背景和图片的时候，如果是纯色，尽量使用 color；如果是规则图形，尽量使用 shape 画图；如果稍微复杂点，可以使用 9patch 图；如果不能使用 9patch 的情况下，针对几种主流分辨率的机型进行切图。 BroadCastReceiver、Service绑定广播和服务，一定要记得在不需要的时候给解绑。 线程线程不再需要继续执行的时候要记得及时关闭，开启线程数量不易过多，一般和自己机器内核数一样最好，推荐开启线程的时候，使用线程池。 String/StringBuffer当有较多的字符创需要拼接的时候，推荐使用 StringBuffer。 Android内存分配回收机制从宏观角度上来看Android系统可以分为三个层次 Application Framework, Dalvik 虚拟机 Linux内核。 这三个层次都有各自内存相关工作： 参考Android 内存优化总结&amp;实践]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发与滑动冲突]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%B8%8E%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[事件分发机制事件分发过程主要由 dispatchTouchEvent，onInterceptTouchEvent 和 onTouchEvent 三个方法共同完成： public boolean dispatchTouchEvent(MotionEvent ev) 用来进行事件分发，如果事件能够传递给当前 view，则此方法一定调用，返回结果受当前 view 的 onTouchEvent 和下级 view 的 dispatchTouchEvent 方法影响，表示是否消耗了当前事件。 public boolean onInterceptTouchEvent(MotionEvent event) 在 dispatchTouchEvent 内部调用，用来判断是否拦截某个事件。 public boolean onTouchEvent(MotionEvent event) 在 dispatchTouchEvent 内部调用，用来处理点击事件，返回结果表示是否消耗了当前事件，如果不消耗则在同一事件序列中，当前 view 无法再次接受到事件。 点击事件达到顶级 View（一般为 ViewGroup ）后，会调用 viewGroup 的 dispatchTouchEvent 方法， 如果顶级 ViewGroup 的 onInterceptTouchEvent 返回 true，则事件由 ViewGroup 处理，这时如果 ViewGroup 的 mOnTouchListener 被设置，则 onTouch 会被调用，onTouch 若返回 true，ViewGroup 的 onTouchEvent 不会再被调用；若设置了 mOnClickListener，则 onClick 会被调用。 如果顶层 ViewGroup 不拦截事件即 onInterceptTouchEvent 返回 false，则事件传递给子 View，这时子 View 的 dispatchTouchEvent 会被调用，到此为止，事件已经从顶级 View 传递了下一层 View，如此循环，完成整个事件的分发。 如果一个 View 的 onTouchEvent 返回 false，那么它的父容器的 onTouchEvent 将会被调用，表示无法消耗（解决）事件，需要交给上级。 ViewGroup 默认不拦截任何事件，即 Android 源码中 ViewGroup 的 onInterceptTouchEvent 默认返回 false。 View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给它，那么它的 onTouchEvent 方法就会被调用。 伪代码： 123456789public boolean dispatchTouchEvent(MotionEvent ev)&#123; boolean result= false; if(onInterceptTouchEvent(ev))&#123; result = onTouchEvent(ev); &#125;else&#123; result = child.dispatchTouchEvent(ev); &#125; return result;&#125; 滑动冲突在界面中内外两层同时可以滑动，就产生了滑动冲突，如何解决滑动冲突呢？ 常见的滑动冲突 场景 可分为以下 3 种： 外部滑动方向和内部滑动方向不一致 ViewPager 和Fragment 组成的页面中包括一个 ListView，这种情况是有滑动冲突的，但是 ViewPager 内部处理了这种滑动冲突，因此采用 ViewPager 时无须关注这个问题，如果采用的不是 ViewPager 而是 ScrollView，那就必须处理滑动冲突了，否则内外两层就只有一层能滑动。 外部滑动方向和内部滑动方向一致 内外两层在同一个方向都可以滑动，系统无法知道用户到底想让哪一层滑动。 上面两种情况的嵌套 比如 SlideMenu、ScrollView 和 ListView 三者同时出现。 处理规则场景1：根据滑动是水平滑动还是竖直滑动来判断到底由谁来拦截事件。 场景2：虽然无法根据滑动方向来判断，但是这时一般在业务上有状态可以依赖，比如业务上有规定，当处于某种状态时需要外部 View 响应用户滑动，而处于另一种状态时需要内部 View 响应滑动。 场景3：其实很简单，结合场景 1 和场景 2 的处理规则，就能处理场景 3 的滑动冲突。 解决方法 外部拦截法 点击事件先经过父容器的拦截处理，如果父容器需要响应就拦截，不需要就不拦截，拦截处理需要写在父容器的 onInterceptTouchEvent 方法里。 内部拦截法 父容器不拦截任何事件，子 view 需要响应就直接消耗，否则就交由父容器处理。 参考图解 Android 事件分发机制 事件分发和滑动冲突知识点总结]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热修复和增量更新]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%92%8C%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[参考Android热更新之初探 阿里巴巴热修复]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>热修复</tag>
        <tag>增量更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础]]></title>
    <url>%2F2018%2F07%2F15%2FJava%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java 主类结构Java 程序的基本组成单元是类，类体中包括属性和方法。每个程序都必须包含一个 main() 方法，含有 main() 方法的类称为主类。 包声明语句 package xxx 为声明该类所在的包。 声明成员变量和局部变量全局变量（成员变量）：类的属性； 局部变量：方法中的属性； 编写主方法public static void main(String[] args) {……} 方法是主类中的主方法。public 是权限修饰符、static 是静态修饰符、void 是返回值修饰符、String[] args 是一个字符串类型的数组。 基本数据类型分为数值型（整数类型、浮点类型）、字符型、布尔型。 整数类型整型数据在 Java 中有十进制、八进制、十六进制。其中八进制以0开头，十六进制以0X或0x开头。 整型数据根据所占内存大小不同（内存空间 8 位等于 1 字节），分为 byte（8位）、short（16位）、int（32位）、long（64位）。 变量取值范围超出就会报错。 对于 long 型值，若赋给的值大于 int 型的最大最小值，则需要在数字后面加 L 或 l。 浮点类型浮点类型表示有小数部分的数字。分为单精度浮点类型和双精度浮点类型。 浮点数据根据所占内存大小不同（内存空间 8 位等于 1 字节），分为 float（32位）、double（64位）。 默认情况下，小数被看做是 double 型。 float 型小数，数字后面需要加 F 或 f。 字符类型char 型字符类型用于存储单个字符，占用内存空间 16 位（两个字节）。 在定义字符类型变量时，以单引号表示一个字符，双引号表示一个字符串。 转义字符以反斜杠 \ 开头，后跟一个或多个字符。 布尔型通过关键字 boolean 来定义布尔类型变量，只有 true 和 false。 变量和常量标识符和关键字标识符由任意顺序的字母、下划线、美元符号、数字组成，并且第一个字符不能是数字，不能是关键字。 关键字是赋予特定意义的单词。 声明变量声明变量时可以没有赋值，也可以直接赋给初值。 声明常量标准语法： final 数据类型 常量名称[=值] 常量名通常使用大写字母表示。 当定义的 final 变量属于成员变量时，必须在定义时就设定它的初值，否则会编译错误。 变量的有效范围由于变量被定义出来后只是暂存在内存中，等到程序执行到某一个点，改变量会被释放掉。 根据变量的“有效范围”将变量分为 “成员变量” 和“局部变量”。 成员变量（全局变量）类体中定义的变量称为成员变量，在整个类中都有效。分为静态变量和实例变量。 成员变量的类型前面加上关键字 static，则是静态变量。它的有效范围可以跨类，甚至可以达到整个应用程序之内。对于静态变量，除了在定义它的类内存取，还可以“类名.静态变量”方式在其他类内使用。 局部变量局部变量是在类的方法体中定义的。只在当前代码块中有效。 运算符自增和自减运算符是单目运算符。++a（-a） 表示在使用变量 a 之前，先使 a 的值加（减）1a--（a-） 表示在使用变量 a 之后，使 a 的值加（减）1 位运算符按位与 &amp; 按位或 | 按位取反 ~ 按位异或 ^ 移位操作 &lt;&lt; 左移 &gt;&gt; 右移 &gt;&gt;&gt; 无符号右移 三元运算符使用格式： 条件式？值1：值2等价于 if…else 数据类型转换低精度数据类型向高精度数据类型转换，则永远不会溢出，永远成功；高精度数据类型向低精度数据类型转换，则有可能失败。 隐式类型转换低精度类型向高精度类型转换，系统自动执行。 精度从低到高： byte &lt; short &lt; char &lt; int &lt; long &lt; float &lt; double 显示类型转换高精度的变量的值赋给低精度的变量或取值范围超出变量时，必须使用显示类型转换（又称为强制类型转换）。 循环语句while 循环语句先判断，再循环 do…while 循环语句先执行一次，再判断 for 循环语句for 语句for(表达式; 表达式2; 表达式3){ 语句序列} foreach 语句for(元素变量 x : 遍历对象 obj){ 引用了 x 的 java 语句.} 循环控制包括：控制循环变量的变化方式、控制循环的跳转。控制循环的跳转需要 break、continue 两个关键字。break 是中断循环，continue 是执行下一次循环。 break 语句break 可以跳出 switch 结构，也可以跳出当前循环体。若有循环嵌套，则 break 只会跳出包含它的最内层的循环结构，只跳出一层循环。 如果想让 break 跳出外层循环，则使用标签功能： 标签 : 循环体{ break 标签名 } continue 语句不是立即跳出循环体，而是跳过本次循环结束前的语句，回到循环的条件测试部分，重新开始执行循环。 对于 for 循环，首先执行循环的增量部分，再执行条件测试部分。对于 while 和 do…while 循环，则直接回到条件测试部分。 continue 同样支持标签功能。 字符串获取字符串信息字符串查找str.indexOf(substr) 用于返回参数字符串 substr 在指定字符串中首次出现的索引位置。如果没有检索到字符串 substr，则返回值是 -1。 在计算机中 String 对象使用数组表示的。字符串的下标是 0~length()-1 str.lastIndexOf(String str) 用于返回指定字符串最后一次出现的索引位置。如果参数是空字符串（””），则返回的结果是字符串的长度。 获取指定索引位置的字符str.charAt(int index) 返回指定索引处的字符。 字符串操作获取子字符串str.substring(int beginIndex) 返回的是从指定的索引位置开始截取知道该字符串结尾的子串。 substring(int beginIndex, int endIndex) 返回的是字符串某一索引位置开始截取至某一索引位置结束的子串。 去除空格str.trim() 返回字符串的副本，忽略前导空格和尾部空格。 字符串替换str.replace(char oldChar, char newChar) 将指定的字符或字符串所有都替换成新的字符或字符串。 判断字符串的开始和结尾str.stratsWith(String prefix) 判断当前字符串对象的前缀是否为参数指定的字符串。 str.endsWith(String suffix) 判断当前字符串是否以给定的字符串结束。 判断字符串是否相等比较运算符 == 用于比较两个字符串的地址是否相同。即使两个字符串的内容相同，两个对象的内存地址是不相同的，返回 false。 str.equals(String otherstr) 如果两个字符串内容相等（区分大小写），则返回 true。 str.equalsIgnoreCase(String otherstr) 忽略大小写情况下，如果两个字符串内容相等，则返回 true。 按字典顺序比较两个字符串str.compareTo(String otherstr) 按字典顺序比较两个字符串，基于字符串中各个字符的 Unicode 值。如果 String 对象位于参数字符串之前，则返回一个负整数；如果位于之后，则返回一个正整数；如果两者相等，则结果为 0。 字母大小写转换str.toLowerCase 将原字符串中每个字符从大写字母等价转换为小写字母。 str.toUpperCase 将原字符串中每个字符从小写字母等价转换为大写字母。 字符串分割使用 split() 方法可以使字符串按指定的分割字符或字符串对内容进行分割，并将分割后的结果存放在字符串数组中。 str.split(String sign) 根据给定的分隔符对字符串进行拆分。sign 为分割字符串的分隔符，也可以使用正则表达式。 str.split(String sign, int limit) 根据给定的分隔符对字符串进行拆分，并限定拆分的次数。 没有统一的对字符进行分割的符号，如果想定义多个分割符，可以使用符号 |。例如，,|= 表示分割符为 ,和= 。 格式化字符串str.format(String format, Object…args) 使用指定的格式字符串和参数返回一个格式化字符串，格式化后的新字符串使用本地默认的语言环境。 str.format(Local l, String format, Object…args) l : 格式化过程中要应用的语言环境。如果 l 为 null，则不进行本地化 。 format : 格式字符串。 args : 格式字符串中由格式说明符引用的参数。如果还有格式说明符以外的参数，则忽略这些额外的参数。此参数的数目是可变的，可以为 0 。 日期和时间字符串格式化日期格式化12Date date = new Date(); //创建 Date 对象 dateString s = String.format("%te", date); //通过 format() 方法对 date 进行格式化 时间格式化 格式化常见的日期时间组合 常规类型格式化 使用正则表达式正则表达式用于判断语句中，用来检查某一字符串是否满足某一格式。 字符串生成器使用 + 可以达到附加新字符或字符串的目的，但 + 会产生一个新的 String 实例，会在内存中创建新的字符串对象。 如果程序中频繁地附加字符串，建议使用 StringBuilder。 新创建的 StringBuilder 对象初始容量是 16 个字符，可以自行指定初始长度。如果附加的字符超过可容纳的长度，则 StringBuilder 对象将自动增加长度以容纳附加的字符。 StringBuilder 方法 append(content) 用于向字符串生成器中追加内容； insert(int offset, arg) 用于向字符串生成器中的指定位置插入数据内容； delete(int start, int end) 用于移除此序列的字符串中的字符；（左闭右开） 数组一维数组的创建及应用创建一维数组1、先声明，再用 new 运算符进行内存分配 声明一维数组： 数组元素类型 数组名字[] 数组元素类型[] 数组名字 为数组分配内存空间： 数组名字 = new 数组元素的类型[数组元素的个数] 假如创建的数组有 5 个元素，因此数组中元素的下标为 0~4 。 2、声明的同时为数组分配内存 数组元素的类型[] 数组名 = new 数组元素的类型[数组元素的个数] 初始化一维数组数组元素类型[] 数组名字 = new 数组元素类型[]{元素, 元素, …} 数组元素类型[] 数组名字 = {元素, 元素, …} 使用一维数组数组名字[0] = 元素1; 数组名字[1] = 元素2; …… 二维数组的创建及使用二维数组常用于表示表。第一个下标代表元素所在的行，第二个下标代表元素所在的列。 创建二维数组1、先声明，再用 new 运算符进行内存分配 声明二维数组： 数组元素类型 数组名字[][] 数组元素类型[][] 数组名字 为数组分配内存空间： 数组名字 = new 数组元素的类型[数组元素的个数 1][数组元素的个数 2] 12345数组名字 = new 数组元素的类型[数组元素的个数 1][]数组名字[0] = new 数组元素类型[数组元素的个数]数组名字[1] = new 数组元素类型[数组元素的个数]…………数组名字[数组元素的个数 1] = new 数组元素类型[数组元素的个数] 假如创建的数组有 5 个元素，因此数组中元素的下标为 0~4 。 2、声明的同时为数组分配内存 12345数组名字 = new 数组元素的类型[数组元素的个数 1][]数组名字[0] = new 数组元素类型[数组元素的个数]数组名字[1] = new 数组元素类型[数组元素的个数]…………数组名字[数组元素的个数 1] = new 数组元素类型[数组元素的个数] 初始化二维数组数组的基本操作遍历数组遍历二维数组一般使用双层 for 循环，通过数组的 length 属性可获得数组的长度。 填充替换数组元素数组中的元素定义完成后，可通过 Arrays 类的静态方法 fill() 对数组中的元素进行替换。 Arrays.fill(数组类型[] 数组名字, 数组类型 value) 将指定的 value 分配给数组的每个元素。 Arrays.fill(数组类型[] 数组名字, int fromIndex, int toIndex ,数组类型 value) fromIndex 用指定值填充的第一个元素的索引（包括） toIndex 使用指定值填充的最后一个元素的索引（不包括） 对数组进行排序Arrays.sort(object) Java 中的 String 类型数组的排序算法是根据字典编排顺序排序的，因此数字排在字母前面，大写字母排在小写字母前面。 复制数组Arrays.copyOf(数组名字, 数组类型 newlength) Arrays.copyOfRange(数组名字, int fromIndex, int toIndex) 数组查询Arrays 类的 binarySearch() 方法，可使用二分搜索法来搜索指定数组，以获得指定对象。 binarySearch(Object[] a, Object key) a 要搜索的数组 key 要搜索的值 必须在进行此调用之前对数组进行排序。 binarySearch(Object[] a, int fromIndex, int toIndex, Object key) 数组排序算法冒泡排序由小到大排序。依据对比相邻的元素值。 冒泡算法由双层循环实现，外层是比较的轮数 ；内层是每轮比较的次数。 12345678910111213141516171819202122232425262728293031323334353637public class BubbleSort&#123; private static void sort(int array[])&#123; int temp = 0; //记录最后一次交换的位置 int lastExchangeIndex = 0; //无序数列的边界，每次比较只需要比到这里为止 int sortBorder = array.length - 1; for(int i = 0; i &lt; array.length; i++)&#123; //有序标记，每一轮的初始是 true boolean isSorted = true; for(int j = 0; j &lt; sortBorder; j++)&#123; if(array[j] &gt; array[j+1])&#123; temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; //有元素交换，所以不是有序，标记变为 false isSorted = false; //把无序数列的边界更新为最后一次交换元素的位置 lastExchangeIndex = j; &#125; &#125; sortBorder = lastExchangeIndex; if(isSorted)&#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[]&#123;3,4,2,1,5,6,7,8&#125;; //int[] array = new int[]&#123;63,4,24,1,3,15&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 该方法为已经优化后的。 isSorted 避免在所有元素都在有序情况下，坚持走完所有轮数 lastExchangeIndex 记录最后一次元素交换的位置 sortBorder 避免在后面的元素是有序情况下，坚持去比较。之后的元素肯定是有序的，所以不用比较 直接选择排序1234567891011121314151617181920212223public class Gess &#123; private static void sort(int array[])&#123; int index; for (int i = 1; i &lt; array.length; i++) &#123; index = 0; for (int j = 1; j &lt;= array.length-i; j++) &#123; if(array[j] &gt; array[index]) &#123; index = j; &#125; &#125; int temp = array[array.length-i]; array[array.length-i] = array[index]; array[index]=temp; &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[]&#123;63,4,24,1,3,15&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 反转排序类和对象面向对象概述类就是封装对象属性和行为的载体，对象就是类抽象出来的一个实例。其中，对象的属性就是成员变量，行为就是方法。 封装是面向对象编程的核心思想。将对象的属性和行为封装起来，其载体就是类，类通常对客户隐藏其实现细节。保证内部数据结构的完整性，避免外部操作对内部数据的影响。 继承是避免重复去定义属性和行为。 多态就是将父类对象应用于子类的特征。依赖于抽象类和接口。 在多态机制中，父类通常会被定义为抽象类，在抽象类中给出一个方法的标准，而不给出实现的具体流程。 在多态机制中，将抽象类定义为接口更方便。由抽象方法组成的集合就是接口。 类成员变量java 中对象的属性就是成员变量。 成员方法Java 中使用成员方法对应于类对象的行为。 1234权限修饰符 返回值类型 方法名(参数类型 参数名)&#123; …//方法体 return 返回值;&#125; 成员方法可以有参数，这个参数可以是对象，也可以是基本数据类型 成员方法可以有有返回值，也可以有不返回值（使用 void 关键字） 返回值可以是计算结果，也可以是其他数值和对象，但返回值类型要与方法返回的值类型一致 成员方法可以调用其他成员方法和类成员变量 成员方法内可以定义局部变量 权限修饰符对于类的成员变量、成员方法，被修饰为： private 则只能在本类中使用，在子类中是不可见的，并且对其他包的类也是不可见； public 则除了可以在本类中使用，还可以在子类和其他包的类中使用； protected 则只有本包内的该类的子类或其他类可以访问此类中的成员变量和成员方法； 如果在声明类的时候，不使用修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。 局部变量在成员方法中定义的变量。方法被执行时创建，方法执行结束时销毁。 局部变量在使用时必须进行赋值操作或初始化，否则会编译错误 this 关键字在 Java 中规定， 使用 this 关键字来代表本类对象的引用，this 关键字被隐式地用于引用对象的成员变量和方法； 还可以作为方法的返回值。 类的构造方法构造方法是一个与类同名的方法，每当类实例化一个对象时，类都会自动调用构造方法。 构造方法没有返回值； 构造方法的名称要与本类的名称相同； 123public 构造方法名（类名）&#123; …//构造方法体&#125; 在构造方法中可以为成员变量赋值，当实例化一个本类对象时，相应的成员变量也可以初始化。 如果类中没有明确定义构造方法，编译器会自动创建一个不带参数的默认构造方法。但如果类中已经存在带参数的构造方法时，编译器不会自动创建一个不带参数的构造方法。 static 静态变量、常量和方法由 static 声明的变量、常量和方法被称为静态成员。在本类或者其他类中使用类名.静态成员调用。 在静态方法中不可以使用 this 关键字； 在静态方法中不可以直接调用非静态方法； 类的主方法对象对象的创建使用 new 操作符调用构造方法来创建对象。 访问对象的属性和行为对象.类成员 对象的引用类名 对象引用名称 = new 类名() 引用只是存放一个对象的内存地址，并非存放一个对象。严格地说，引用和对象是不同的，但是这种区别可以忽略。 对象的比较 == 比较两个对象引用的地址是否相等； equals() 是 String 类方法，比较两个对象引用所指的内容是否相等； 对象的销毁包装类Integer （Long、Short）构造方法 Integer 变量名 = new Integer(int number) Integer 变量名 = new Integer(String str) 常用方法 toString() 可以将 Integer 对象转换为十进制字符串; toBinaryString() 可以将对象转换为二进制; toHexString() 可以将对象转换为十六进制; toOctalString() 可以将对象转换为八进制; 常量 Boolean构造方法 Boolean 变量名 = new Boolean(boolean value) Boolean 变量名 = new Boolean(String str) str 不为 null 且在忽略大小写时等于 true，则分配一个表示 true 值的 Boolean 对象，否则获得一个 false 值的 Boolean 对象。 常用方法 常量 Byte构造方法 Byte 变量名 = new Byte(byte value) Byte 变量名 = new Byte(String str) str 要使用数值型，否则会报错 常用方法 常量 CharacterDouble (Float)Number数字处理数字格式化Java 主要对浮点型数据进行数字格式化，其中浮点数包括 double 型和 float 型数据。 使用 java.text.DecimalFormat 格式化数字 数学运算Math 类Math 类中提供的众多数学函数方法，都被定义为 static 形式。 Math.数学方法 Math.PI 、Math.E 常用数学运算方法 Math 类三角函数方法 Math 类指数函数方法 Math 类取整函数方法 Math 类取最大值、最小值、绝对值函数方法 随机数Math.random() 方法默认生成大于等于 0.0 且小于 1.0 的 double 型随机数。 Random 类通过实例化 Random 对象创建一个随机数生成器。 大数字运算BigInteger支持任意精度整数。 BigDecimal支持任意精度的定点数，可以用来精确计算货币值。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 屏幕适配]]></title>
    <url>%2F2018%2F07%2F13%2F%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>屏幕适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混合开发]]></title>
    <url>%2F2018%2F07%2F13%2F%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App 设计]]></title>
    <url>%2F2018%2F07%2F13%2FApp%20%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Android 中 vector 用法详解 Android UI：使用矢量图，抛弃PNG 码农如何从零开始做出有设计感的app？]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>设计</tag>
        <tag>Vector Assert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2]]></title>
    <url>%2F2018%2F07%2F11%2FDagger2%2F</url>
    <content type="text"><![CDATA[A fast dependency injector for Android and Java. 添加依赖只要在 app module 的 build.gradle，添加： 123456dependencies &#123; ……………… //dagger2 implementation &apos;com.google.dagger:dagger:版本号&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:版本号&apos;&#125; 开始新建一个无参数的类123456public class Person &#123; public Person() &#123; System.out.println("a person created"); &#125;&#125; 新建一个该类的提供者123456789@Modulepublic class MainModule &#123; @Provides Person providesPerson()&#123; System.out.println("a person created from MainModule"); return new Person(); &#125;&#125; @Module 标注的对象，你可以把它想象成一个工厂，可以向外提供一些类的对象。那么到底提供什么对象呢？ @Provides 标注的方法就是提供对象的，这种方法一般会返回一个对象实例，例如上面返回一个 Person 对象。 新建一个 component 容器12345@Component(modules = &#123;MainModule.class&#125;)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125; 可以把它想成一个容器， module 中产出的东西都放在里面，然后将 component 与我要注入的 MainActivity 做关联，MainActivity 中需要的 person 就可以从 component 中去取出来。 @Component 表示这个接口是一个容器，并且与 MainModule.class 关联，它生产的东西都在这里。 void inject(MainActivity mainActivity); 表示我怎么和要注入的类关联。这个比较抽象！ 在 MainActivity 中将 component 关联进去123456789101112131415public class MainActivity extends AppCompatActivity &#123; @Inject Person person; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MainComponent component = DaggerMainComponent.builder() .mainModule(new MainModule()).build(); component.inject(this); &#125;&#125; @Inject 在 Person 对象上添加一个 @Inject 注解，即可自动注入对象。这个时候系统看到有一个 @Inject 修饰的 Person，就知道在这个 MainComponent 中去找，并且是有 MainModule 的 Provides 修饰的方法提供的。 完成以上步骤，开始重建我们的项目DaggerMainComponent 就是你 build project 的时候，dagger 自己为你生成的具体的 component 类（我们自己定义的是 MainComponent 接口）。 其他注解和情况单例模式 @Singleton（基于Component）基于 Component 的单例模式， 就是在这个 Component 对象中，一个对象是单例对象。如果又新创建了一个Component，那么两个 Component 中的对象是不一样的。 我们再在 MainActivity 中添加一个12@InejctPerson person2 并打印两个 person 对象，发现 person 会被创建两次，并且两个 person 对象也不同。如果我们希望只有一个 person 和 person2，并且都指向同一个 Person 对象，就要使用 @Singleton 注解。 在 MainModule.java 的 provides 方法上需要添加 @Singleton 注解12345678910@Modulepublic class MainModule &#123; @Singleton @Provides Person providesPerson()&#123; System.out.println("a person created from MainModule"); return new Person(); &#125;&#125; 在 MainComponent.java 类上添加 @Singleton 注解123456@Singleton@Component(modules = &#123;MainModule.class&#125;)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125; 再运行，发现 person 只创建了一次，并且两个 person 指向同一个对象。 需要注意的是：单例是基于 Component 的，所以不仅 Provides 的地方要加 @Singleton，Component 上也需要加。并且如果有另外一个 OtherActivity，并且创建了一个 MainComponent，也注入 Person，这个时候 MainActivity 和 OtherActivity 中的 Person 是不构成单例的，因为它们的 Component 是不同的。 带有参数的依赖对象如果构造 Person 类，需要一个参数 Context，我们怎么注入呢？ 要知道注入的时候我们只有一个 @Inject 注解，并不能带参数。所以我们需要再 MainModule 中提供 context，并且由 providesXXX 函数自己去构造。 新建一个带参数的类123456789public class Person &#123; private static final String TAG = "Person"; private Context context; public Person(Context context)&#123; Log.d(TAG, "我是一个带参数的男人" + context); &#125;&#125; 修改该类的提供者12345678910111213141516171819202122@Modulepublic class MainModule &#123; private static final String TAG = "MainModule"; private Context context; public MainModule(Context context)&#123; this.context = context; &#125; @Provides public Context providesContext()&#123; return this.context; &#125; @Singleton @Provides public Person providesPerson(Context context)&#123; Log.d(TAG, "person from module "); return new Person(context); &#125;&#125; providesPerson(Context context) 中的 context 不能直接使用成员变量 this.context，而是要在本类中提供一个1234@Providespublic Context providesContext()&#123; return this.context;&#125; 方法，这样在发现需要 context 的时候会调用 provideContext 来获取，这也是为了解耦。 依赖一个组件自定义标记 @Qualifier 和 ＠Named@Named(“…”)@Qualifier自定义标签懒加载Lazy和强制重新加载Provider@Scope 自定义生命周期参考google/daggerDagger2入门]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ButterKnife]]></title>
    <url>%2F2018%2F07%2F11%2FButterKnife%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ButterKnife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旅游记账助手]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%97%85%E6%B8%B8%E8%AE%B0%E8%B4%A6%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[功能记账（AA 制） 旅游攻略 景点导航 相机 紧急电话 注意事项分享提醒（护照、衣物、登机牌…………）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>旅游</tag>
        <tag>记账</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常捕获代码]]></title>
    <url>%2F2018%2F07%2F06%2F%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Content Provider 内容提供器]]></title>
    <url>%2F2018%2F07%2F06%2FContentProvider%20%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%2F</url>
    <content type="text"><![CDATA[定义内容提供器主要用于在不同的应用程序之间实现数据共享功能，是 Android 实现跨程序共享数据的标准方式。 运行时权限Android 的权限机制每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限所对应的权限组中所有的其他权限也会同时被授权。 在程序运行时申请权限1、 首先判断用户是不是已经给我们授权了： 12345if(ContextCompat.checkSelfPermission(Context, Manifest.permission.权限) != PackageManager.PErMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(Context, new String[]&#123;Manifest.permission.权限&#125;, 常量);&#125;else&#123; //do something&#125; 2、 如果已经授权就执行逻辑操作；如果没有授权，则调用 ActivityCompat.requestPermissions() 方法，最终回调到 onRequestPermissionResult() 方法： 1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case 常量: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PErMISSION_GRANTED)&#123; //do something &#125;else&#123; //do another thing &#125; break; default: &#125;&#125; 访问其他程序中的数据如果想要访问内容提供器中共享的数据，就一定要借助 ContentResolver 类，通过 Context 的 getContentResolver() 方法获得实例。 ContentResolver 的基本用法 insert() ：增加数据 update() ：更新数据 delete() ：删除数据 query() ：查询数据 ContentResolver 中的增删改查方法都不是接受表名参数，而是使用一个 Uri 参数代替，即内容 URI。 关于内容 URI内容 URI 由 authority 和 path 组成。其中： authority 是用于对不同的应用程序做区分的，采用程序包命名。例如：com.example.app.Provider。 path 是对同一程序不同的表做区分的，通常添加到 authority 后面。例如：com.example.app.Provider/table1，com.example.app.Provider/table2。 解析内容 URI 的方法：Uri uri = Uri.parse(&quot;com.example.app.Provider/table1&quot;); 增删改查方法演示查1234567Cursor cursor = getContentResolver().query( uri, projection, selection, selectionArgs, sortOrder ); query() 方法参数 对应 SQL 部分 描述 uri from table_name 指定查询某个应用程序下的某一张表 projection select column1，column2 指定查询的列名 selection where column = value 指定 where 的约束条件 selectionArgs - 为 where 中的占位符提供具体的值 orderBy order by column1,column2 指定查询结果的排序方式 查询完成后返回的仍然是一个 Cursor 对象，将数据从 Cursor 对象中读取： 1234567if(cursor != null)&#123; while(cursor.moveToNext())&#123; String column1 = cursor.getstring(cursor.getColumnIndex("column1")); int column2 = cursor.getInt(cursor.getColumnIndex("column2")); &#125; cursor.close();&#125; 增1234ContentValues values = new ContentValues();values.put("column1", "text");values.put("column2", 1);getContentResolver().insert(uri, values); 改123ContentValues values = new ContentValues();values.put("column1", "");getContentResolver().update(uri, values, "column1 = ? and column2 = ?", new String[] &#123;"text", "1"&#125;); 删getContentResolver().delete(uri, &quot;column2 = ?&quot;, new String[] {&quot;1&quot;}) 创建自己的内容提供器]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内容提供器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView使用]]></title>
    <url>%2F2018%2F07%2F05%2FRecyclerView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Fragment 使用]]></title>
    <url>%2F2018%2F07%2F05%2FFragment%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Fragment 的 add、hide、show 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class FragmentHelper &#123; /** * 添加 Fragment * @param fragmentManager * @param fragment * @param fragmentTag */ public static void addFragment(FragmentManager fragmentManager, Fragment fragment, String fragmentTag)&#123; if (fragmentManager != null)&#123; FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.add(R.id.frag_main, fragment, fragmentTag); transaction.commit(); &#125; &#125; /** * 显示已存在的 Fragment * @param fragmentManager * @param fragment */ public static void showFragment(FragmentManager fragmentManager, Fragment fragment)&#123; FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); if (fragment != null)&#123; fragmentTransaction.show(fragment); fragmentTransaction.commit(); &#125; &#125; /** * 隐藏所有的 Fragment * @param fragmentManager */ public static void hideAllFragment(FragmentManager fragmentManager)&#123; FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); Fragment dashboard_fragment = fragmentManager.findFragmentByTag("dashboard_fragment"); if (dashboard_fragment != null)&#123; fragmentTransaction.hide(dashboard_fragment); &#125; fragmentTransaction.commit(); &#125;&#125; 参考资料 Fragment全解析系列 Fragment你真的熟悉吗？看了才知道 Android基础：Fragment，看这篇就够了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 View]]></title>
    <url>%2F2018%2F07%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"><![CDATA[参考资料 安卓自定义View教程 仿支付宝芝麻信用的仪表盘]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义 View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent使用]]></title>
    <url>%2F2018%2F07%2F05%2FIntent%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Service 和多线程使用]]></title>
    <url>%2F2018%2F07%2F05%2FService%20%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[服务的定义 服务是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而还要求长期运行的任务。 服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。但服务不是运行在一个独立的进程中，而是依赖于创建服务时所在的应用程序。当应用程序进程被杀死，服务也会被停止运行。 服务并不会自动开启线程，默认运行在主线程中。 Android 多线程线程基本用法1.继承的方式耦合性有点高123456789class MyThread extends Thread&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125;new MyThread().start(); 2.实现 Runnable 接口的方式12345678910class MyThread implements Runnable&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125;MyThread myThread = new MyThread();new Thread(myThread).start(); 3.1234567new Thread(new Runnable()&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125;).start(); 在子线程中更新 UIAndroid 是不允许在子线程中更新 UI。但它提供了一套异步消息处理机制，可以解决在子线程中进行 UI 操作。 首先在主线程创建一个 Handler，并重写 handleMessage() 方法： 12345678910private Handler handler = new Handler()&#123; public void handleMessage(Message msg)&#123; switch (msg.what)&#123; case 常量 //在这里进行 UI 操作 break; &#125; &#125;&#125; 在需要更新 UI 的子线程中创建一个 Message 对象： 123Message message = new Message();message.what = 常量;handler.sendMessage(message); //将 Message 对象发送出去 解析异步消息处理机制Android 的异步消息处理机制由 4 部分组成：Message、Handler、MessageQueue、Looper。 MessageMessage 是在线程之间传递消息，可以在内部携带少量消息，用于在不同线程之间交换数据。what 字段携带 String 数据，arg1、arg2 字段携带整型数据，obj 字段携带一个 Object 对象。 Handler主要用于发送和处理消息。发送消息一般用 Handler 的 sendMessage() 方法。接收消息 Handler 的 handleMessage() 方法。 MessageQueueMessageQueue 是消息队列，主要用于存放所有通过 Handler 发送的消息。每个线程只会有一个 MessageQueue 对象。 LooperLooper 是每个线程中的 MessageQueue 管家，调用 Looper 的 loop() 方法后，就会进入一个无限循环，每当发现 MessageQueue 中存在的一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。每个线程只有一个 Looper 对象。 使用 AsyncTask由于 AsyncTask 是一个抽象类，所以我们需要创建一个子类去继承。 AsyncTask 类的 3 个泛型参数： Params ：在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。 Progress ：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型为进度单位。 Result ：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 AsyncTask 几个方法： onPreExecute() ：这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框。 doInBackground(Params…) :1、 所有代码都会在子线程中运行；2、 任务一旦完成就会返回 return 语句，但如果 AsyncTask 第三个泛型参数为 Void，则不返回任务执行结果；3、 这个方法中不可以执行 UI 操作，如果要执行 UI 操作，则可以调用 publishProgress(Progress…) 方法完成； onProgressUpdate(Progress…) ：当后台任务中调用 publishProgress(Progress…) 方法后，onProgressUpdate(Progress…) 方法就会调用。 onPostExcute(Result) ：当后台任务执行完毕并通过 return 语句执行返回时，这个方法就会调用。 AsyncTask 总结doInBackground(Params…) 执行具体的耗时任务；onProgressUpdate(Progress…) 进行更新 UI；onProgressUpdate(Progress…) 执行任务收尾； 启动这个任务：new targetTask().execute(); 线程池参考 ：Android 中常见的4种线程池（保证你能看懂并理解 服务的基本用法定义一个服务创建一个 Service 并在 AndroidManifest 中注册，其中 Exported 属性表示是否允许除了当前程序之外的其他程序访问这个服务，Enabled 属性表示是否启用这个服务。 活动和服务进行通信 创建一个子类继承 Service 123456789101112131415public class xxxService extends Service&#123; private final IBinder mBinder = new LocalBinder(); public class LocalBinder extends Binder &#123; public xxxService getService() &#123; return xxxService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 在 Activity/Fragment 中调用 Service： 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity&#123; private xxxService.LocalBinder localBinder; private xxxService mxxxService; /** * 绑定 xxxService 服务结果回调 */ private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; localBinder = (xxxService.LocalBinder) service; //通过向下转型得到 localBinder 实例 mxxxService = localBinder.getService(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent bindIntent = new Intent(this, xxxService.class); bindService(bindIntent, serviceConnection, Context.BIND_AUTO_CREATE); //绑定服务获取持久连接 &#125; @Override public void onDestroy() &#123; super.onDestroy(); unbindService(serviceConnection); &#125;&#125; 服务的更多技巧使用前台服务前台服务和普通服务最大区别是，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏可以看到更加详细的信息。类似于彩云天气的前台服务效果。 使用 IntentService一个异步的、会自动停止的服务。onHandleIntent(Intent intent) 方法运行在子线程中。 1234567891011121314151617181920public class xxxIntentService extends IntentService&#123; public xxxIntentService()&#123; super("xxxIntentService"); //调用父类的有参构造函数 &#125; @Override protected void onHandleIntent(Intent intent) &#123; //当前的逻辑已经在子线程中运行 //打印当前线程的 id Log.d("xxxIntentService", "Thread id is" + Thread.currentThread().getId()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Broadcast 使用]]></title>
    <url>%2F2018%2F07%2F05%2FBroadcast%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[广播机制 标准广播 完全异步执行，所有广播接收器同时接收 有序广播 同步执行，同一时刻只有一个广播接收器可以接收 接收系统广播动态注册监听网络变化动态注册的广播接收器可以随意地控制注册和注销，但必须要在程序启动之后才能街道广播。 静态注册实现开机启动发送自定义广播发送标准广播发送有序广播使用 sendOrderBrocast() 发送广播，同时需要在 AndroidManifest 中设置优先级 &lt;intent-filter android:priority= &gt; 使用本地广播LocalBroadcastManger 来管理广播。LocalBroadcastManger localBroadcastmanger = LocalBroadcastManger.getInstance(this); 获取 LocalBroadcastManger 实例。localBroadcastmanger.sendBroadcast() 发送广播。localBroadcastmanger.registerReceiver() 注册广播。localBroadcastmanger.unregisterReceiver() 注销广播。 利用广播实现强制下线功能 首先定义一个活动回收器 ActivityCollector 类，创建一个列表来管理活动，ActivityCollector 类里面包含添加活动 addActivity、移除活动 removeActivity、结束活动 finishAll 的方法。 创建一个 BaseActivity 类作为所有活动的父类，同时复写 onCreate 添加 addActivity 方法；复写 onDestroy 添加 removeActivity 方法；复写 onResume 在里面注册广播；复写 onPause 在里面注销广播；在 ForceOfflineReceiver 的 onReceive 方法里面放入 finishAll 方法。 让需要实现强制下线功能的 Activity 继承 BaseActivity 类，同时发送强制下线功能的广播。 利用静态广播实现 APP 开机自动启动]]></content>
  </entry>
  <entry>
    <title><![CDATA[ViewPager使用]]></title>
    <url>%2F2018%2F07%2F05%2FViewPager%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java 获取时间日期方法]]></title>
    <url>%2F2018%2F07%2F05%2FJava%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单个获取年、月、日、时、分 1234567891011121314151617181920212223242526272829303132333435363738394041public static int getYear() &#123; //获取系统的日期 Calendar calendar = Calendar.getInstance(); //年 int year = calendar.get(Calendar.YEAR); return year; &#125; public static int getMonth() &#123; Calendar calendar = Calendar.getInstance(); //月份需要加 1，因为是从 0 开始算的 int month = calendar.get(Calendar.MONTH) + 1; return month; &#125; public static int getDay() &#123; Calendar calendar = Calendar.getInstance(); int day = calendar.get(Calendar.DAY_OF_MONTH); return day; &#125; public static int getHour() &#123; Calendar calendar = Calendar.getInstance(); int hour = calendar.get(Calendar.HOUR_OF_DAY); return hour; &#125; public static int getMinute() &#123; Calendar calendar = Calendar.getInstance(); int minute = calendar.get(Calendar.MINUTE); return minute; &#125; 获取当前时间12345678910/** * 获取当前时间的年月日 * @return */ public static String simpleDate()&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日"); Date date = new Date(System.currentTimeMillis()); return simpleDateFormat.format(date); &#125; 以当前时间为原点，往前或往后查询某一天123456789101112131415161718192021222324/** * 显示某一日的数据 * @param dateIndex * @return */ public static String getDisplayOffsetDate(int dateIndex)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日"); if (dateIndex == 0)&#123; Date date = new Date(System.currentTimeMillis()); return simpleDateFormat.format(date); &#125;else &#123; Date beginDate = new Date();//获取当天 年月日+时间+时区 Calendar date = Calendar.getInstance();//实例化 Calendar 对象 date.setTime(beginDate); date.set(Calendar.DATE, date.get(Calendar.DATE) + dateIndex); Date endDate = null; try &#123; endDate = simpleDateFormat.parse(simpleDateFormat.format(date.getTime())); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return simpleDateFormat.format(endDate); &#125; &#125; 如果查询某一年、某一月，则改变 Calendar.DATE 为 YEAR 或 MONTH。 查询某一个月有多少天1234567891011121314151617/** * 查询某一个月一共有多少天 * @param date * @return */public static int getDaysOfMonth(String date)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月"); Date timeMillis = new Date(); try &#123; timeMillis = simpleDateFormat.parse(date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; Calendar calendar = Calendar.getInstance(); calendar.setTime(timeMillis); return calendar.getActualMaximum(Calendar.DAY_OF_MONTH);&#125; 设置 calendar 的时间为 2000-01-01-00-00，并获取 1970至2000-01-01-00-00时间的毫秒12345678910111213141516171819202122/** * 2000-01-01-00-00 * @return */public static Calendar get20000101Datetime() &#123; Calendar cal_ = Calendar.getInstance(); cal_.set(Calendar.YEAR, 2000); cal_.set(Calendar.MONTH, Calendar.JANUARY); cal_.set(Calendar.DATE, 1); cal_.set(Calendar.HOUR_OF_DAY, 0); cal_.set(Calendar.MINUTE, 0); cal_.set(Calendar.SECOND, 0); cal_.set(Calendar.MILLISECOND, 0); return cal_;&#125;//设置 calendar 的时间为 2000-01-01-00-00Calendar calendar = get20000101Datetime();//setTimeInMillis 为 （1970至2000-01-01-00-00时间的毫秒）calendar.getTimeInMillis(); 把 String 类型的日期，转换为日期的毫秒数12345678910111213141516/** * 把 String 类型的日期，转换为日期的毫秒数 * @param i * @return */public static Long stringToDateMillis(String i)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy年MM月dd日 HH:mm");//24小时制 long timeMillis = 0; try &#123; timeMillis = simpleDateFormat.parse(i).getTime(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return timeMillis;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BLE 开发知识]]></title>
    <url>%2F2018%2F07%2F05%2FBLE%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[开发流程声明 BLE 权限在 AndroidManifest 中添加： 12345&lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;&lt;!-- 6.0 之后需要位置权限--&gt;&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; 获取 BluetoothAdapter 实例12345678910111213141516171819202122/** * 初始化本地蓝牙 * * @return */private boolean initBLE() &#123; if (mBluetoothManager == null) &#123; mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); if (mBluetoothManager == null) &#123; LogUtil.e(TAG, "Unable to initialize BluetoothManager."); return false; &#125; &#125; mBluetoothAdapter = mBluetoothManager.getAdapter(); if (mBluetoothAdapter == null) &#123; LogUtil.e(TAG, "Unable to obtain a BluetoothAdapter."); return false; &#125; return true;&#125; 动态申请定位权限Android 6.0 系统以上开启蓝牙还需要定位权限，定位权限属于危险权限，需要动态申请： 12345678910private void initPermission() &#123; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; …………………… //请求权限 requestPermissions(new String[]&#123;Manifest.permission.WRITE_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION); &#125;&#125; 如果是在 Fragment 中使用，则是 xxxFragment.this.requestPermissions requestPermissions 的回调方法是 123456789@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION: Toast.makeText(getActivity(), "已经可以定位了", Toast.LENGTH_SHORT).show(); &#125;&#125; 请求位置服务判断是否开启定位功能1234567891011121314/** * 开启定位功能 * @param context * @return */private static boolean isLocationEnable(Context context) &#123; LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE); boolean networkProvider = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER); boolean gpsProvider = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER); if (networkProvider || gpsProvider) &#123; return true; &#125; return false;&#125; 开启定位服务123456789/** * 获取定位服务 * * @param context */private static void setLocationService(Context context) &#123; Intent locationIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS); ((Activity) context).startActivityForResult(locationIntent, Global.REQUEST_CODE_LOCATION_SETTINGS);&#125; 扫描设备在 android 6.0 中，使用 BluetoothLeScanner.startScan() 来扫描的： 123456789101112131415161718192021222324252627282930313233343536/** * 扫描 BLE 设备 * @param enable */public void scanDevices(boolean enable) &#123; LogUtil.i(TAG, "BluetoothAdapter 状态：" + mBluetoothAdapter.getState()); if (enable) &#123; /*new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; mBluetoothAdapter.getBluetoothLeScanner().stopScan(mScanCallback); &#125; &#125;, 3000);*/ LogUtil.i(TAG, "正在搜索设备…………"); mBluetoothAdapter.getBluetoothLeScanner().startScan(mScanCallback); &#125; else &#123; LogUtil.i(TAG, "停止搜索设备"); mBluetoothAdapter.getBluetoothLeScanner().stopScan(mScanCallback); &#125;&#125;private ScanCallback mScanCallback = new ScanCallback() &#123; @Override public void onScanResult(int callbackType, ScanResult result) &#123; super.onScanResult(callbackType, result); Bundle data = new Bundle(); data.putParcelable(BluetoothDevice.EXTRA_DEVICE, result.getDevice()); Intent intent = new Intent(); intent.setAction(ACTION_DEVICE_FOUND); intent.putExtras(data); sendBroadcast(intent); &#125;&#125;; 注册广播123456789101112131415/** * 初始化广播 */private void initBroadcastReceiver() &#123; IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); intentFilter.addAction(BluetoothService.ACTION_DEVICE_FOUND); intentFilter.addAction(BluetoothService.ACTION_GATT_SERVICES_DISCOVERED_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_DESCRIPTOR_WRITE_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_CHARACTERISTIC_WRITE_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_CHARACTERISTIC_DATA_REPLY); registerReceiver(broadcastReceiver, intentFilter);&#125; 123456789101112/** * 广播接收器 */private BroadcastReceiver broadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) &#123; ………… &#125; &#125; 连接设备需要获取 BluetoothGATT 再进行操作： 1234567891011121314151617181920212223242526/** * 连接目标 BLE 设备 * * @param address * @return */public boolean connect(final String address) &#123; if (mBluetoothAdapter == null || address == null) &#123; LogUtil.e(TAG, "BluetoothAdapter not initialized or unspecified address."); return false; &#125; final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address); if (device == null) &#123; LogUtil.e(TAG, "Device not found. Unable to connect."); return false; &#125; // We want to directly connect to the device, so we are setting the autoConnect // parameter to false. mBluetoothGatt = device.connectGatt(this, false, mGattCallback); LogUtil.i(TAG, "成功连接上设备：" + device.getName()); LogUtil.i(TAG, "------------Create a new connection.------------"); return true;&#125; 当 GATT 客户端连接上或者连接状态改变时，调用 onConnectionStateChange。 如果使用：device.connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport) 根据源码 @param transport preferred transport for GATT connections to remote dual-mode devices跟双模设备连接，transport 如果不传默认 TRANSPORT_AUTO，6.0系统及以上需要使用 TRANSPORT_LE 这种传输模式。 发现服务当使用 mBluetoothGatt.discoverServices() 时，则调用 onServicesDiscovered。 获取 BluetoothGattService 和 BluetoothGattCharacteristic12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 获取 BluetoothGattService * * @param bluetoothGatt * @param uuid_service * @return */ private BluetoothGattService getBluetoothGATTService(BluetoothGatt bluetoothGatt, UUID uuid_service) &#123; if (mBluetoothGatt != null) &#123; BluetoothGattService bluetoothGattService = mBluetoothGatt.getService(uuid_service); if (bluetoothGattService != null) &#123; //LogUtil.i(TAG, "成功获取 bluetoothGattService：" + uuid_service); return bluetoothGattService; &#125; else &#123; LogUtil.e(TAG, "bluetoothgatt get service uuid:" + uuid_service + " is null"); &#125; &#125; else &#123; LogUtil.e(TAG, "mBluetoothGatt is null"); &#125; return null; &#125; /** * 获取 BluetoothGattCharacteristic * * @param bluetoothGattService * @param uuid_characteristic * @return */ private BluetoothGattCharacteristic getBluetoothGattCharacteristic(BluetoothGattService bluetoothGattService, UUID uuid_characteristic) &#123; if (bluetoothGattService != null) &#123; BluetoothGattCharacteristic bluetoothGattCharacteristic = bluetoothGattService.getCharacteristic(uuid_characteristic); if (bluetoothGattCharacteristic != null) &#123; //LogUtil.i(TAG, "成功获取 bluetoothGattCharacteristic：" + uuid_characteristic); return bluetoothGattCharacteristic; &#125; else &#123; LogUtil.e(TAG, "bluetoothGattService get characteristic uuid:" + uuid_characteristic + " is null"); &#125; &#125; else &#123; LogUtil.e(TAG, "bluetoothGattService is null"); &#125; return null; &#125; 开启通知，并且写入 DescriptorWriteCharacteristic() 后有数据返回，则需要先： 12345678910111213141516171819202122232425/** * 设置 Characteristic 通知属性，并且写上 Descriptor */ private void setCharacteristicNotifyAndWriteDescriptor(UUID uuid_service, UUID uuid_characteristic, UUID uuid_descriptor) &#123; BluetoothGattService mBluetoothGattService = getBluetoothGATTService(mBluetoothGatt, uuid_service); BluetoothGattCharacteristic mBluetoothGattCharacteristic = getBluetoothGattCharacteristic(mBluetoothGattService, uuid_characteristic); if (mBluetoothGatt != null &amp;&amp; mBluetoothGattCharacteristic != null) &#123; mBluetoothGatt.setCharacteristicNotification(mBluetoothGattCharacteristic, true); BluetoothGattDescriptor mBluetoothGattDescriptor = mBluetoothGattCharacteristic.getDescriptor(uuid_descriptor); if (mBluetoothGattDescriptor != null) &#123; LogUtil.i(TAG, "成功设置 mBluetoothGattDescriptor"); mBluetoothGattDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); mBluetoothGatt.writeDescriptor(mBluetoothGattDescriptor); &#125; &#125; else if (mBluetoothGatt == null) &#123; LogUtil.e(TAG, "mBluetoothGatt is null"); &#125; else if (mBluetoothGattCharacteristic == null) &#123; LogUtil.e(TAG, "mBluetoothGattCharacteristic is null"); &#125; &#125; 然后会回调 onDescriptorWrite 写入 Characteristic12345678910111213141516171819202122/** * 写入 Characteristic * @param uuid_service * @param uuid_characteristic * @param value */private void writeCharacteristic(UUID uuid_service, UUID uuid_characteristic, byte[] value) &#123; BluetoothGattService mBluetoothGattService = getBluetoothGATTService(mBluetoothGatt, uuid_service); BluetoothGattCharacteristic mBluetoothGattCharacteristic = getBluetoothGattCharacteristic(mBluetoothGattService, uuid_characteristic); if (mBluetoothGatt != null &amp;&amp; mBluetoothGattCharacteristic != null) &#123; mBluetoothGattCharacteristic.setValue(value); mBluetoothGattCharacteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE); mBluetoothGatt.writeCharacteristic(mBluetoothGattCharacteristic); &#125;else if (mBluetoothGatt == null) &#123; LogUtil.e(TAG, "mBluetoothGatt is null"); &#125; else if (mBluetoothGattCharacteristic == null) &#123; LogUtil.e(TAG, "mBluetoothGattCharacteristic is null"); &#125;&#125; 则先回调 onCharacteristicWrite，然后回调 onCharacteristicChanged。 BluetoothGatt 的回调1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * BluetoothGatt 的回调 */private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; super.onConnectionStateChange(gatt, status, newState); if (newState == BluetoothProfile.STATE_CONNECTED) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; LogUtil.i(TAG, "Connected To GATT Server"); LogUtil.i(TAG, "Attempting To Start Service Discovery:" + mBluetoothGatt.discoverServices()); broadcastUpdate(ACTION_GATT_CONNECTED); &#125; else &#123; disconnect(); close(); &#125; &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123; close(); &#125; &#125; @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; super.onServicesDiscovered(gatt, status); LogUtil.i(TAG, "onServicesDiscovered received: " + status); if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED_SUCCESS); &#125; else &#123; LogUtil.i(TAG, "onServicesDiscovered received: " + status); &#125; &#125; @Override public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorWrite(gatt, descriptor, status); if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_DESCRIPTOR_WRITE_SUCCESS); &#125; &#125; @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicWrite(gatt, characteristic, status); if (status == BluetoothGatt.GATT_SUCCESS)&#123; broadcastUpdate(ACTION_GATT_CHARACTERISTIC_WRITE_SUCCESS); //LogUtil.i(TAG, "onCharacteristicWrite 返回的数据" + Arrays.toString(characteristic.getValue())); &#125; &#125; @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicChanged(gatt, characteristic); LogUtil.i(TAG, "onCharacteristicChanged 返回的数据" + Arrays.toString(characteristic.getValue())); broadcastUpdate(ACTION_GATT_CHARACTERISTIC_DATA_REPLY, KEY_HOUR_DATA, characteristic.getValue()); &#125; @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicRead(gatt, characteristic, status); &#125; @Override public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorRead(gatt, descriptor, status); &#125;&#125;; 发送广播12345678910111213141516/** * 发送广播 * * @param action */private void broadcastUpdate(final String action) &#123; final Intent intent = new Intent(action); sendBroadcast(intent);&#125;private void broadcastUpdate(final String action, String key, byte[] value)&#123; final Intent intent = new Intent(action); intent.putExtra(key, value); sendBroadcast(intent);&#125; 参考资料 Android蓝牙4.0 BLE开发坑总结 Android BLE 多次writeCharacteristic 为什么只有一个回调]]></content>
      <categories>
        <category>Android</category>
        <category>BLE</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BLE 4.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BLE 手环开发总结]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%89%8B%E7%8E%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基础功能 显示步数、距离、卡路里、电量、目标完成状况 功能实现过程 通过手机蓝牙与手环连接，手机 APP 发送个人设置数据给手环；当手环接收数据成功后，更新用户信息，同时返回当前时刻到上一次同步数据时刻的数据（注：数据以1小时为单位，返回的每个1小时数据是每个1小时的累计数据)，这次返回的数据中含有掉电标志字节，用于判断本次数据同步是正常还是掉电后重新上电后的第一次同步。 手机 APP 发送请求同步手环屏幕当前显示数据的数据给手环；手环接收数据成功后，返回步数、距离、卡路里、电量的数据。 手机 APP 发送请求同步手环72个小时数据的数据给手环；手环接收数据成功后，返回步数、卡路里、每个小时的 UTC 秒数的数据。 开发辅助数据库框架greenDAO 简书上面的参考资料： Android Study 之 玩转GreenDao 3.2.2 点滴提升逼格~ 数据库调试Android-Debug-Database 智能刷新框架SmartRefreshLayout 图表显示框架MPAndroidChart CSDN 上面的两篇参考资料： Android图表控件MPAndroidChart的简单介绍（MPAndroidChart3.0 MPAndroidChart 教程 Fragment 切换指示器SpringIndicator 自定义选择器框架AndroidPicker 遇到的问题 BLE 以6.0版本为界限的开发流程、GATT 规范 Java 获取当前时间以及各种转换 ViewPager + Fragment 使用 Activity 和 Fragment 跳转、数据交互 BottomNavigationView 使用 Broadcast 使用 Service 使用 Intent 使用 异步使用 enum 自定义 View 参考：仿支付宝芝麻信用的仪表盘安卓自定义View教程 Fragment 的 add、hide、show。简书收藏几篇文章 由于手环储存的步数数据仅为1个小时的累计，所以当用图表显示月、年的时候，需要对数据进行处理 实时监控手机的网络、蓝牙状态变化 蓝牙、定位、位置服务权限申请 byte[] 数组对应天数开关处理 Fragment 的接口回调 自定义一个 NoScrollViewPagerAdapter 自定义一个 LogUtil RecyclerView 使用 Bundle 使用 改进 引入 ButterKnife 使用异步加载图表数据，现在加载月、年数据比较慢 同步时间过长之后，再次同步一次会出现数据错乱情况 引入网络数据 引入 Google 的 easypermissions 作为权限获取库]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BLE 4.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ICON 资源网站]]></title>
    <url>%2F2018%2F07%2F05%2FICON%20%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Android Asset Studio Material Palette easyicon]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ICON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPAndroidChart 翻译]]></title>
    <url>%2F2018%2F07%2F02%2FMPAndroidChart%20%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[MPAndroidChart 开始本章介绍使用此库的基本设置。 添加依赖作为第一步，将该库的依赖项添加到您的项目中。 如何添加依赖已经在此存储库的用法部分中进行了介绍。 推荐使用 Gradle 方式作为添加依赖的方式。 创建界面使用 LineChart, BarChart, ScatterChart, CandleStickChart, PieChart, BubbleChart or RadarChart ，在 .xml 中定义：1234&lt;com.github.mikephil.charting.charts.LineChart android:id="@+id/chart" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 然后从 Activity, Fragment or whatever 中取回：12// in this example, a LineChart is initialized from xmlLineChart chart = (LineChart) findViewById(R.id.chart); 或者使用代码来创建（跟着在 layout 添加）123456// programmatically create a LineChartLineChart chart = new LineChart(Context);// get a layout defined in xmlRelativeLayout rl = (RelativeLayout) findViewById(R.id.relativeLayout);rl.add(chart); // add the programmatically created chart 添加数据在获得图表实例后，你可以创建数据并且添加到图表。这个例子使用的是 LineChart，Entry 类代表图表中一个点的 X，Y 坐标。其他图表类型，例如 BarChart 使用 BarEntry。添加数据到图表，将每一个数据代入到 Entry 中，例如：123456789YourData[] dataObjects = ...;List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;();for (YourData data : dataObjects) &#123; // turn your data into Entry objects entries.add(new Entry(data.getValueX(), data.getValueY()));&#125; 下一步，将 List 添加到 LineDataSet。DataSet 对象保存数据，同时允许单独设置数据的样式。如果启用，下面使用的“标签”仅具有描述性目的，并显示在图表中。123LineDataSet dataSet = new LineDataSet(entries, "Label"); // add entries to datasetdataSet.setColor(...);dataSet.setValueTextColor(...); // styling, ... 最后一步，添加 LineDataSet 对象到 LineData 对象。这个对象持有 chart 实例的所有数据，并允许有单独样式。在你建立数据对象后，你可以使用它建立图表并刷新：123LineData lineData = new LineData(dataSet);chart.setData(lineData);chart.invalidate(); // refresh 请考虑到上面的仅仅是基本应用。需要更详细的扩展应用，请参考 setting data 部分，其中有很多添加数据到不同 chart 类型图表的例子。 样式有关图表外观和数据的设置和样式的信息，请参考 general settings &amp; styling 部分。关于单个图表类型的更具体的样式和设置，请参考 specific settings &amp; styling。 与图表交互该库允许您完全自定义与图表视图的可能触摸（和手势）交互，并通过回调方法对交互作出反应。 启用/禁用交互 setTouchEnabled(boolean enabled) 允许启用/禁用与图表的所有可能的触摸交互。 setDragEnabled(boolean enabled) 启用/禁用图表的拖动（平移）。 setScaleEnabled(boolean enabled) 启用/禁用两个轴上的图表缩放。 setScaleXEnabled(boolean enabled) 启用/禁用 X 轴缩放。 setScaleYEnabled(boolean enabled) 启用/禁用 Y 轴缩放。 setPinchZoom(boolean enabled) 如果设置为 true，则启用缩放。如果禁用，则可以单独缩放 X 轴和 Y 轴。 setDoubleTapToZoomEnabled(boolean enabled) 将此设置为 false 以禁止通过双击来缩放图表。 图表抛物线/减速 setDragDecelerationEnabled(boolean enabled) 如果设置为 true，则图表会在触摸后继续滚动。 默认值：true。 setDragDecelerationFrictionCoef(float coef) 减速摩擦系数在 [0; 1] 之间，较高的值表示速度将缓慢下降，例如，如果设置为 0，它将立即停止。 1 是无效值，将自动转换为 0.9999。 突出显示值如何允许通过点击手势和编程方式，突出显示条目在 highlightning section 中进行了描述。 手势回调OnChartGestureListener 将允许您对图表上的手势做出反应： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface OnChartGestureListener &#123; /** * Callbacks when a touch-gesture has started on the chart (ACTION_DOWN) * * @param me * @param lastPerformedGesture */ void onChartGestureStart(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when a touch-gesture has ended on the chart (ACTION_UP, ACTION_CANCEL) * * @param me * @param lastPerformedGesture */ void onChartGestureEnd(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when the chart is longpressed. * * @param me */ public void onChartLongPressed(MotionEvent me); /** * Callbacks when the chart is double-tapped. * * @param me */ public void onChartDoubleTapped(MotionEvent me); /** * Callbacks when the chart is single-tapped. * * @param me */ public void onChartSingleTapped(MotionEvent me); /** * Callbacks then a fling gesture is made on the chart. * * @param me1 * @param me2 * @param velocityX * @param velocityY */ public void onChartFling(MotionEvent me1, MotionEvent me2, float velocityX, float velocityY); /** * Callbacks when the chart is scaled / zoomed via pinch zoom gesture. * * @param me * @param scaleX scalefactor on the x-axis * @param scaleY scalefactor on the y-axis */ public void onChartScale(MotionEvent me, float scaleX, float scaleY); /** * Callbacks when the chart is moved / translated via drag gesture. * * @param me * @param dX translation distance on the x-axis * @param dY translation distance on the y-axis */ public void onChartTranslate(MotionEvent me, float dX, float dY);&#125; 只需让你接收回调的类实现这个接口，并将其设置为图表的监听器：1chart.setOnChartGestureListener(this); 高亮显示值本节重点介绍通过 tap-gesture 和基于发行版 v3.0.0 以编程方式，高亮显示图表中条目的主题。 启用/禁用高亮显示 setHighlightPerDragEnabled(boolean enabled) 在图表上将此设置为 true，以便在完全缩小时，在图表表面上进行每次拖动时高亮显示。 默认值： true setHighlightPerTapEnabled(boolean enabled) 在图表上将此设置为 false，以防止通过点击手势高亮显示值。 但仍可通过拖动或以编程方式高亮显示值。 默认值： true setMaxHighlightDistance(float distanceDp) 在 dp 中设置最大的高光距离。在图表上轻敲远离条目的距离，不会触发高亮显示。 默认值： 500dp 除此之外，还可以为各个 DataSet 对象配置高亮显示：123456dataSet.setHighlightEnabled(true); // allow highlighting for DataSet // set this to false to disable the drawing of highlight indicator (lines) dataSet.setDrawHighlightIndicators(true); dataSet.setHighlightColor(Color.BLACK); // color for highlight indicator // and more... 以编程方式突出显示 highlightValue(float x, int dataSetIndex, boolean callListener) 高亮显示给定 DataSet 中给定 x位置的值。 提供 -1 作为 dataSetIndex 以撤消所有高亮显示。布尔标志确定是否应该调用选择侦听器。 highlightValue(Highlight high, boolean callListener) 高亮显示提供的 Highlight对象 所代表的值。提供 null 以撤消所有高亮显示。布尔标志确定是否应该调用选择侦听器。 highlightValues(Highlight[] highs) 高亮显示给定 Highlight [] 数组所表示的值。提供 null 或空数组以撤消所有高亮显示。 getHighlighted() 返回 Highlight [] 数组，其中包含有关所有高亮显示的条目，x-index 和 dataset-index 的信息。 选择回调该库在交互时为回调提供了许多侦听器。 其中一个是 OnChartValueSelectedListener，用于通过触控高亮显示值时的回调： 1234567891011121314 public interface OnChartValueSelectedListener &#123; /** * Called when a value has been selected inside the chart. * * @param e The selected Entry. * @param h The corresponding highlight object that contains information * about the highlighted position */ public void onValueSelected(Entry e, Highlight h); /** * Called when nothing has been selected or an "un-select" has been made. */ public void onNothingSelected();&#125; 只需让你的接收回调的类，实现这个接口并将其设置为图表的监听器：chart.setOnChartValueSelectedListener(this); 高亮的类Highlight类 表示与高亮显示的 Entry 关联的所有数据，例如高亮显示的 Entry对象 本身，它所属的 DataSet，它在绘图表面上的位置等等。它可用于获取有关已高亮显示的条目的信息，或用于向图表提供要高亮显示的条目的信息。关于这个目的，Highlight类 提供了两个构造函数：12345/** constructor for standard highlight */public Highlight(float x, int dataSetIndex) &#123; ... &#125;/** constructor for stacked BarEntry highlight */public Highlight(float x, int dataSetIndex, int stackIndex) &#123; ... &#125; 这些构造函数可用于创建 Highlight对象，该对象允许以编程方式执行突出显示：1234// highlight the entry and x-position 50 in the first (0) DataSetHighlight highlight = new Highlight(50f, 0);chart.highlightValue(highlight, false); // highlight this value, don't call listener 自定义高亮所有用户输入的高亮手势形式，都由默认的 ChartHighlighter类 在内部处理。使用以下方法，用自定义实现替换默认的 highligher： setHighlighter（ChartHighlighter highlighter） 为图表设置自定义 highligher对象，以处理在图表视图上执行的所有高亮触摸事件。您自定义的 highlighter对象 需要继承 ChartHighlighter类。]]></content>
      <categories>
        <category>Android</category>
        <category>Chart</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Chart</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON 数据解析]]></title>
    <url>%2F2018%2F06%2F26%2FJSON%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[JSONObject 及 JSONArray 取值String 转 JSONObject 或 JSONArrayJSONArray jsonArray = JSONArray.fromObject(str); JSONObject jsonObject = JSONObject.fromObject(str); JSONObject 中获取 JSONArray 或 StringJSONObject jsonObject = new JSONObject(resource); String str = jsonObject.getString(&quot;str&quot;); //获取 sequences的值 JSONArray sequencesArray = jsonObject.getJSONArray(&quot;sequences&quot;); JSONObject 中还有其它 get 方法。 JSONArray 中获取 JSONObject 或 StringJSONArray jsonArray = new JSONArray(resource); String str = jsonArray.getString(0); JSONObject jsonObject = jsonArray.getJSONObject(0); 解析 json 格式的数据时要看清楚，最外面为 { 的是 JSONObject ，为 [ 的是JSONArray。 实例JSONArray 中获取 JSONObject1234567891011121314151617181920212223242526272829303132public class Province extends DataSupport &#123; private int id; private String provinceName; private int provinceCode; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getProvinceName() &#123; return provinceName; &#125; public void setProvinceName(String provinceName) &#123; this.provinceName = provinceName; &#125; public int getProvinceCode() &#123; return provinceCode; &#125; public void setProvinceCode(int provinceCode) &#123; this.provinceCode = provinceCode; &#125;&#125; 1JSON 数组 [&#123;&quot;id&quot;:1, &quot;name&quot;:北京&#125;,&#123;&quot;id&quot;:2, &quot;name&quot;:上海&#125;,&#123;&quot;id&quot;:3, &quot;name&quot;:天津&#125;,&#123;&quot;id&quot;:4, &quot;name&quot;:重庆&#125;,&#123;&quot;id&quot;:5, &quot;name&quot;:香港&#125;] 123456789101112131415161718public static boolean handleProvinceResponse(String response) &#123; if (!TextUtils.isEmpty(response)) &#123; try &#123; JSONArray allProvinces = new JSONArray(response); for (int i = 0; i &lt; allProvinces.length(); i++) &#123; JSONObject provinceObject = allProvinces.getJSONObject(i); Province province = new Province(); province.setProvinceName(provinceObject.getString("name")); province.setProvinceCode(provinceObject.getInt("id")); province.save(); &#125; return true; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; JSONObject 中获取 JSONArray，然后在从 JSONArray 中获取 JSONObject12345678910111213141516public class Weather &#123; public String status; public Basic basic; public AQI aqi; public Now now; public Suggestion suggestion; @SerializedName("daily_forecast") public List&lt;Forecast&gt; forecastList;&#125; 1&#123;&quot;HeWeather&quot;: [&#123;&quot;basic&quot;:&#123;&quot;cid&quot;:&quot;CN101300105&quot;,&quot;location&quot;:&quot;隆安&quot;,&quot;parent_city&quot;:&quot;南宁&quot;,&quot;admin_area&quot;:&quot;广西&quot;,&quot;cnty&quot;:&quot;中国&quot;,&quot;lat&quot;:&quot;23.17476273&quot;,&quot;lon&quot;:&quot;107.68865967&quot;,&quot;tz&quot;:&quot;+8.00&quot;,&quot;city&quot;:&quot;隆安&quot;,&quot;id&quot;:&quot;CN101300105&quot;,&quot;update&quot;:&#123;&quot;loc&quot;:&quot;2018-05-02 11:47&quot;,&quot;utc&quot;:&quot;2018-05-02 03:47&quot;&#125;&#125;,&quot;update&quot;:&#123;&quot;loc&quot;:&quot;2018-05-02 11:47&quot;,&quot;utc&quot;:&quot;2018-05-02 03:47&quot;&#125;,&quot;status&quot;:&quot;ok&quot;,&quot;now&quot;:&#123;&quot;cloud&quot;:&quot;25&quot;,&quot;cond_code&quot;:&quot;300&quot;,&quot;cond_txt&quot;:&quot;阵雨&quot;,&quot;fl&quot;:&quot;32&quot;,&quot;hum&quot;:&quot;71&quot;,&quot;pcpn&quot;:&quot;0.0&quot;,&quot;pres&quot;:&quot;1014&quot;,&quot;tmp&quot;:&quot;29&quot;,&quot;vis&quot;:&quot;10&quot;,&quot;wind_deg&quot;:&quot;107&quot;,&quot;wind_dir&quot;:&quot;东南风&quot;,&quot;wind_sc&quot;:&quot;1&quot;,&quot;wind_spd&quot;:&quot;4&quot;,&quot;cond&quot;:&#123;&quot;code&quot;:&quot;300&quot;,&quot;txt&quot;:&quot;阵雨&quot;&#125;&#125;,&quot;daily_forecast&quot;:[&#123;&quot;date&quot;:&quot;2018-05-02&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;中雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;30&quot;,&quot;min&quot;:&quot;23&quot;&#125;&#125;,&#123;&quot;date&quot;:&quot;2018-05-03&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;阵雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;27&quot;,&quot;min&quot;:&quot;22&quot;&#125;&#125;,&#123;&quot;date&quot;:&quot;2018-05-04&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;阵雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;28&quot;,&quot;min&quot;:&quot;23&quot;&#125;&#125;],&quot;hourly&quot;:[&#123;&quot;cloud&quot;:&quot;90&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;26&quot;,&quot;hum&quot;:&quot;83&quot;,&quot;pop&quot;:&quot;58&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-02 13:00&quot;,&quot;tmp&quot;:&quot;30&quot;,&quot;wind_deg&quot;:&quot;188&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;11&quot;&#125;,&#123;&quot;cloud&quot;:&quot;95&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;24&quot;,&quot;hum&quot;:&quot;85&quot;,&quot;pop&quot;:&quot;49&quot;,&quot;pres&quot;:&quot;1010&quot;,&quot;time&quot;:&quot;2018-05-02 16:00&quot;,&quot;tmp&quot;:&quot;30&quot;,&quot;wind_deg&quot;:&quot;172&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;1&quot;&#125;,&#123;&quot;cloud&quot;:&quot;98&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;24&quot;,&quot;hum&quot;:&quot;87&quot;,&quot;pop&quot;:&quot;25&quot;,&quot;pres&quot;:&quot;1010&quot;,&quot;time&quot;:&quot;2018-05-02 19:00&quot;,&quot;tmp&quot;:&quot;29&quot;,&quot;wind_deg&quot;:&quot;173&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;8&quot;&#125;,&#123;&quot;cloud&quot;:&quot;99&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;23&quot;,&quot;hum&quot;:&quot;89&quot;,&quot;pop&quot;:&quot;20&quot;,&quot;pres&quot;:&quot;1013&quot;,&quot;time&quot;:&quot;2018-05-02 22:00&quot;,&quot;tmp&quot;:&quot;28&quot;,&quot;wind_deg&quot;:&quot;27&quot;,&quot;wind_dir&quot;:&quot;东北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;9&quot;&#125;,&#123;&quot;cloud&quot;:&quot;99&quot;,&quot;cond_code&quot;:&quot;104&quot;,&quot;cond_txt&quot;:&quot;阴&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;90&quot;,&quot;pop&quot;:&quot;71&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-03 01:00&quot;,&quot;tmp&quot;:&quot;25&quot;,&quot;wind_deg&quot;:&quot;5&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;6&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;306&quot;,&quot;cond_txt&quot;:&quot;中雨&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;93&quot;,&quot;pop&quot;:&quot;49&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-03 04:00&quot;,&quot;tmp&quot;:&quot;24&quot;,&quot;wind_deg&quot;:&quot;2&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;6&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;104&quot;,&quot;cond_txt&quot;:&quot;阴&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;93&quot;,&quot;pop&quot;:&quot;34&quot;,&quot;pres&quot;:&quot;1013&quot;,&quot;time&quot;:&quot;2018-05-03 07:00&quot;,&quot;tmp&quot;:&quot;23&quot;,&quot;wind_deg&quot;:&quot;11&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;10&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;86&quot;,&quot;pop&quot;:&quot;70&quot;,&quot;pres&quot;:&quot;1015&quot;,&quot;time&quot;:&quot;2018-05-03 10:00&quot;,&quot;tmp&quot;:&quot;23&quot;,&quot;wind_deg&quot;:&quot;3&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;2&quot;&#125;],&quot;aqi&quot;:&#123;&quot;city&quot;:&#123;&quot;aqi&quot;:&quot;51&quot;,&quot;pm25&quot;:&quot;29&quot;,&quot;qlty&quot;:&quot;良&quot;&#125;&#125;,&quot;suggestion&quot;:&#123;&quot;comf&quot;:&#123;&quot;type&quot;:&quot;comf&quot;,&quot;brf&quot;:&quot;较舒适&quot;,&quot;txt&quot;:&quot;白天有雨，从而使空气湿度加大，会使人们感觉有点儿闷热，但早晚的天气很凉爽、舒适。&quot;&#125;,&quot;sport&quot;:&#123;&quot;type&quot;:&quot;sport&quot;,&quot;brf&quot;:&quot;较不宜&quot;,&quot;txt&quot;:&quot;有较强降水，建议您选择在室内进行健身休闲运动。&quot;&#125;,&quot;cw&quot;:&#123;&quot;type&quot;:&quot;cw&quot;,&quot;brf&quot;:&quot;不宜&quot;,&quot;txt&quot;:&quot;不宜洗车，未来24小时内有雨，如果在此期间洗车，雨水和路上的泥水可能会再次弄脏您的爱车。&quot;&#125;&#125;&#125;]&#125; 12345678910111213141516/** * 将返回的 JSON 数据解析成 Weather 实体类 */public static Weather parseWeatherResponse(String response) &#123; try &#123; JSONObject jsonObject = new JSONObject(response); JSONArray jsonArray = jsonObject.getJSONArray("HeWeather"); String weatherContent = jsonArray.getJSONObject(0).toString(); return new Gson().fromJson(weatherContent, Weather.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
</search>
