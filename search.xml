<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[异常捕获代码]]></title>
    <url>%2F2018%2F07%2F06%2F%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Content Provider 内容提供器]]></title>
    <url>%2F2018%2F07%2F06%2FContentProvider%20%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E5%99%A8%2F</url>
    <content type="text"><![CDATA[定义内容提供器主要用于在不同的应用程序之间实现数据共享功能，是 Android 实现跨程序共享数据的标准方式。 运行时权限Android 的权限机制每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限所对应的权限组中所有的其他权限也会同时被授权。 在程序运行时申请权限1、 首先判断用户是不是已经给我们授权了： 12345if(ContextCompat.checkSelfPermission(Context, Manifest.permission.权限) != PackageManager.PErMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(Context, new String[]&#123;Manifest.permission.权限&#125;, 常量);&#125;else&#123; //do something&#125; 2、 如果已经授权就执行逻辑操作；如果没有授权，则调用 ActivityCompat.requestPermissions() 方法，最终回调到 onRequestPermissionResult() 方法： 1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case 常量: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PErMISSION_GRANTED)&#123; //do something &#125;else&#123; //do another thing &#125; break; default: &#125;&#125; 访问其他程序中的数据如果想要访问内容提供器中共享的数据，就一定要借助 ContentResolver 类，通过 Context 的 getContentResolver() 方法获得实例。 ContentResolver 的基本用法 insert() ：增加数据 update() ：更新数据 delete() ：删除数据 query() ：查询数据 ContentResolver 中的增删改查方法都不是接受表名参数，而是使用一个 Uri 参数代替，即内容 URI。 关于内容 URI内容 URI 由 authority 和 path 组成。其中： authority 是用于对不同的应用程序做区分的，采用程序包命名。例如：com.example.app.Provider。 path 是对同一程序不同的表做区分的，通常添加到 authority 后面。例如：com.example.app.Provider/table1，com.example.app.Provider/table2。 解析内容 URI 的方法：Uri uri = Uri.parse(&quot;com.example.app.Provider/table1&quot;); 增删改查方法演示查1234567Cursor cursor = getContentResolver().query( uri, projection, selection, selectionArgs, sortOrder ); query() 方法参数 对应 SQL 部分 描述 uri from table_name 指定查询某个应用程序下的某一张表 projection select column1，column2 指定查询的列名 selection where column = value 指定 where 的约束条件 selectionArgs - 为 where 中的占位符提供具体的值 orderBy order by column1,column2 指定查询结果的排序方式 查询完成后返回的仍然是一个 Cursor 对象，将数据从 Cursor 对象中读取： 1234567if(cursor != null)&#123; while(cursor.moveToNext())&#123; String column1 = cursor.getstring(cursor.getColumnIndex(&quot;column1&quot;)); int column2 = cursor.getInt(cursor.getColumnIndex(&quot;column2&quot;)); &#125; cursor.close();&#125; 增1234ContentValues values = new ContentValues();values.put(&quot;column1&quot;, &quot;text&quot;);values.put(&quot;column2&quot;, 1);getContentResolver().insert(uri, values); 改123ContentValues values = new ContentValues();values.put(&quot;column1&quot;, &quot;&quot;);getContentResolver().update(uri, values, &quot;column1 = ? and column2 = ?&quot;, new String[] &#123;&quot;text&quot;, &quot;1&quot;&#125;); 删getContentResolver().delete(uri, &quot;column2 = ?&quot;, new String[] {&quot;1&quot;}) 创建自己的内容提供器]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内容提供器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView使用]]></title>
    <url>%2F2018%2F07%2F05%2FRecyclerView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Fragment 使用]]></title>
    <url>%2F2018%2F07%2F05%2FFragment%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Fragment 的 add、hide、show123456789101112131415161718192021222324252627282930313233343536373839404142434445public class FragmentHelper &#123; /** * 添加 Fragment * @param fragmentManager * @param fragment * @param fragmentTag */ public static void addFragment(FragmentManager fragmentManager, Fragment fragment, String fragmentTag)&#123; if (fragmentManager != null)&#123; FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.add(R.id.frag_main, fragment, fragmentTag); transaction.commit(); &#125; &#125; /** * 显示已存在的 Fragment * @param fragmentManager * @param fragment */ public static void showFragment(FragmentManager fragmentManager, Fragment fragment)&#123; FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); if (fragment != null)&#123; fragmentTransaction.show(fragment); fragmentTransaction.commit(); &#125; &#125; /** * 隐藏所有的 Fragment * @param fragmentManager */ public static void hideAllFragment(FragmentManager fragmentManager)&#123; FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); Fragment dashboard_fragment = fragmentManager.findFragmentByTag(&quot;dashboard_fragment&quot;); if (dashboard_fragment != null)&#123; fragmentTransaction.hide(dashboard_fragment); &#125; fragmentTransaction.commit(); &#125;&#125; 参考资料 Fragment全解析系列 Fragment你真的熟悉吗？看了才知道 Android基础：Fragment，看这篇就够了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 View]]></title>
    <url>%2F2018%2F07%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"><![CDATA[参考资料 安卓自定义View教程 仿支付宝芝麻信用的仪表盘]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义 View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent使用]]></title>
    <url>%2F2018%2F07%2F05%2FIntent%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Service 使用]]></title>
    <url>%2F2018%2F07%2F05%2FService%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[定义 服务是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而还要求长期运行的任务。 服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。但服务不是运行在一个独立的进程中，而是依赖于创建服务时所在的应用程序。当应用程序进程被杀死，服务也会被停止运行。 服务并不会自动开启线程，默认运行在主线程中。 Android 多线程线程基本用法1.继承的方式耦合性有点高123456789class MyThread extends Thread&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125;new MyThread().start(); 2.实现 Runnable 接口的方式12345678910class MyThread implements Runnable&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125;MyThread myThread = new MyThread();new Thread(myThread).start(); 3.1234567new Thread(new Runnable()&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125;).start(); 在子线程中更新 UIAndroid 是不允许在子线程中更新 UI。但它提供了一套异步消息处理机制，可以解决在子线程中进行 UI 操作。 首先在主线程创建一个 Handler，并重写 handleMessage() 方法： 12345678910private Handler handler = new Handler()&#123; public void handleMessage(Message msg)&#123; switch (msg.what)&#123; case 常量 //在这里进行 UI 操作 break; &#125; &#125;&#125; 在需要更新 UI 的子线程中创建一个 Message 对象： 123Message message = new Message();message.what = 常量;handler.sendMessage(message); //将 Message 对象发送出去 解析异步消息处理机制Android 的异步消息处理机制由 4 部分组成：Message、Handler、MessageQueue、Looper。 MessageMessage 是在线程之间传递消息，可以在内部携带少量消息，用于在不同线程之间交换数据。what 字段携带 String 数据，arg1、arg2 字段携带整型数据，obj 字段携带一个 Object 对象。 Handler主要用于发送和处理消息。发送消息一般用 Handler 的 sendMessage() 方法。接收消息 Handler 的 handleMessage() 方法。 MessageQueueMessageQueue 是消息队列，主要用于存放所有通过 Handler 发送的消息。每个线程只会有一个 MessageQueue 对象。 LooperLooper 是每个线程中的 MessageQueue 管家，调用 Looper 的 loop() 方法后，就会进入一个无限循环，每当发现 MessageQueue 中存在的一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。每个线程只有一个 Looper 对象。 使用 AsyncTask由于 AsyncTask 是一个抽象类，所以我们需要创建一个子类去继承。 AsyncTask 类的 3 个泛型参数： Params ：在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。 Progress ：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型为进度单位。 Result ：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 AsyncTask 几个方法： onPreExecute() ：这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框。 doInBackground(Params…) :1、 所有代码都会在子线程中运行；2、 任务一旦完成就会返回 return 语句，但如果 AsyncTask 第三个泛型参数为 Void，则不返回任务执行结果；3、 这个方法中不可以执行 UI 操作，如果要执行 UI 操作，则可以调用 publishProgress(Progress…) 方法完成； onProgressUpdate(Progress…) ：当后台任务中调用 publishProgress(Progress…) 方法后，onProgressUpdate(Progress…) 方法就会调用。 onPostExcute(Result) ：当后台任务执行完毕并通过 return 语句执行返回时，这个方法就会调用。 AsyncTask 总结doInBackground(Params…) 执行具体的耗时任务；onProgressUpdate(Progress…) 进行更新 UI；onProgressUpdate(Progress…) 执行任务收尾； 启动这个任务：new targetTask().execute(); 服务的基本用法定义一个服务创建一个 Service 并在 AndroidManifest 中注册，其中 Exported 属性表示是否允许除了当前程序之外的其他程序访问这个服务，Enabled 属性表示是否启用这个服务。 活动和服务进行通信 创建一个子类继承 Service 123456789101112131415public class xxxService extends Service&#123; private final IBinder mBinder = new LocalBinder(); public class LocalBinder extends Binder &#123; public xxxService getService() &#123; return xxxService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 在 Activity/Fragment 中调用 Service： 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity&#123; private xxxService.LocalBinder localBinder; private xxxService mxxxService; /** * 绑定 xxxService 服务结果回调 */ private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; localBinder = (xxxService.LocalBinder) service; //通过向下转型得到 localBinder 实例 mxxxService = localBinder.getService(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent bindIntent = new Intent(this, xxxService.class); bindService(bindIntent, serviceConnection, Context.BIND_AUTO_CREATE); //绑定服务获取持久连接 &#125; @Override public void onDestroy() &#123; super.onDestroy(); unbindService(serviceConnection); &#125;&#125; 服务的更多技巧使用前台服务前台服务和普通服务最大区别是，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏可以看到更加详细的信息。类似于彩云天气的前台服务效果。 使用 IntentService一个异步的、会自动停止的服务。onHandleIntent(Intent intent) 方法运行在子线程中。 1234567891011121314151617181920public class xxxIntentService extends IntentService&#123; public xxxIntentService()&#123; super(&quot;xxxIntentService&quot;); //调用父类的有参构造函数 &#125; @Override protected void onHandleIntent(Intent intent) &#123; //当前的逻辑已经在子线程中运行 //打印当前线程的 id Log.d(&quot;xxxIntentService&quot;, &quot;Thread id is&quot; + Thread.currentThread().getId()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Broadcast 使用]]></title>
    <url>%2F2018%2F07%2F05%2FBroadcast%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[广播机制 标准广播 完全异步执行，所有广播接收器同时接收 有序广播 同步执行，同一时刻只有一个广播接收器可以接收 接收系统广播动态注册监听网络变化动态注册的广播接收器可以随意地控制注册和注销，但必须要在程序启动之后才能街道广播。 静态注册实现开机启动发送自定义广播发送标准广播发送有序广播使用 sendOrderBrocast() 发送广播，同时需要在 AndroidManifest 中设置优先级 &lt;intent-filter android:priority= &gt; 使用本地广播LocalBroadcastManger 来管理广播。LocalBroadcastManger localBroadcastmanger = LocalBroadcastManger.getInstance(this); 获取 LocalBroadcastManger 实例。localBroadcastmanger.sendBroadcast() 发送广播。localBroadcastmanger.registerReceiver() 注册广播。localBroadcastmanger.unregisterReceiver() 注销广播。 利用广播实现强制下线功能 首先定义一个活动回收器 ActivityCollector 类，创建一个列表来管理活动，ActivityCollector 类里面包含添加活动 addActivity、移除活动 removeActivity、结束活动 finishAll 的方法。 创建一个 BaseActivity 类作为所有活动的父类，同时复写 onCreate 添加 addActivity 方法；复写 onDestroy 添加 removeActivity 方法；复写 onResume 在里面注册广播；复写 onPause 在里面注销广播；在 ForceOfflineReceiver 的 onReceive 方法里面放入 finishAll 方法。 让需要实现强制下线功能的 Activity 继承 BaseActivity 类，同时发送强制下线功能的广播。 利用静态广播实现 APP 开机自动启动]]></content>
  </entry>
  <entry>
    <title><![CDATA[ViewPager使用]]></title>
    <url>%2F2018%2F07%2F05%2FViewPager%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java 获取时间日期方法]]></title>
    <url>%2F2018%2F07%2F05%2FJava%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单个获取年、月、日、时、分1234567891011121314151617181920212223242526272829303132333435363738394041public static int getYear() &#123; //获取系统的日期 Calendar calendar = Calendar.getInstance(); //年 int year = calendar.get(Calendar.YEAR); return year; &#125; public static int getMonth() &#123; Calendar calendar = Calendar.getInstance(); //月份需要加 1，因为是从 0 开始算的 int month = calendar.get(Calendar.MONTH) + 1; return month; &#125; public static int getDay() &#123; Calendar calendar = Calendar.getInstance(); int day = calendar.get(Calendar.DAY_OF_MONTH); return day; &#125; public static int getHour() &#123; Calendar calendar = Calendar.getInstance(); int hour = calendar.get(Calendar.HOUR_OF_DAY); return hour; &#125; public static int getMinute() &#123; Calendar calendar = Calendar.getInstance(); int minute = calendar.get(Calendar.MINUTE); return minute; &#125; 获取当前时间12345678910/** * 获取当前时间的年月日 * @return */ public static String simpleDate()&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); Date date = new Date(System.currentTimeMillis()); return simpleDateFormat.format(date); &#125; 以当前时间为原点，往前或往后查询某一天123456789101112131415161718192021222324/** * 显示某一日的数据 * @param dateIndex * @return */ public static String getDisplayOffsetDate(int dateIndex)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); if (dateIndex == 0)&#123; Date date = new Date(System.currentTimeMillis()); return simpleDateFormat.format(date); &#125;else &#123; Date beginDate = new Date();//获取当天 年月日+时间+时区 Calendar date = Calendar.getInstance();//获取当天更加详细时间 date.setTime(beginDate); date.set(Calendar.DATE, date.get(Calendar.DATE) + dateIndex); Date endDate = null; try &#123; endDate = simpleDateFormat.parse(simpleDateFormat.format(date.getTime())); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return simpleDateFormat.format(endDate); &#125; &#125; 如果查询某一年、某一月，则改变 Calendar.DATE 为 YEAR 或 MONTH。 查询某一个月有多少天1234567891011121314151617/** * 查询某一个月一共有多少天 * @param date * @return */public static int getDaysOfMonth(String date)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月&quot;); Date timeMillis = new Date(); try &#123; timeMillis = simpleDateFormat.parse(date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; Calendar calendar = Calendar.getInstance(); calendar.setTime(timeMillis); return calendar.getActualMaximum(Calendar.DAY_OF_MONTH);&#125; 设置 calendar 的时间为 2000-01-01-00-00，并获取 1970至2000-01-01-00-00时间的毫秒12345678910111213141516171819202122/** * 2000-01-01-00-00 * @return */public static Calendar get20000101Datetime() &#123; Calendar cal_ = Calendar.getInstance(); cal_.set(Calendar.YEAR, 2000); cal_.set(Calendar.MONTH, Calendar.JANUARY); cal_.set(Calendar.DATE, 1); cal_.set(Calendar.HOUR_OF_DAY, 0); cal_.set(Calendar.MINUTE, 0); cal_.set(Calendar.SECOND, 0); cal_.set(Calendar.MILLISECOND, 0); return cal_;&#125;//设置 calendar 的时间为 2000-01-01-00-00Calendar calendar = get20000101Datetime();//setTimeInMillis 为 （1970至2000-01-01-00-00时间的毫秒）calendar.getTimeInMillis(); 把 String 类型的日期，转换为日期的毫秒数12345678910111213141516/** * 把 String 类型的日期，转换为日期的毫秒数 * @param i * @return */public static Long stringToDateMillis(String i)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm&quot;);//24小时制 long timeMillis = 0; try &#123; timeMillis = simpleDateFormat.parse(i).getTime(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return timeMillis;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BLE 开发知识]]></title>
    <url>%2F2018%2F07%2F05%2FBLE%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[开发流程声明 BLE 权限在 AndroidManifest 中添加： 12345&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;&lt;!-- 6.0 之后需要位置权限--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; 获取 BluetoothAdapter 实例12345678910111213141516171819202122/** * 初始化本地蓝牙 * * @return */private boolean initBLE() &#123; if (mBluetoothManager == null) &#123; mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); if (mBluetoothManager == null) &#123; LogUtil.e(TAG, &quot;Unable to initialize BluetoothManager.&quot;); return false; &#125; &#125; mBluetoothAdapter = mBluetoothManager.getAdapter(); if (mBluetoothAdapter == null) &#123; LogUtil.e(TAG, &quot;Unable to obtain a BluetoothAdapter.&quot;); return false; &#125; return true;&#125; 动态申请定位权限Android 6.0 系统以上开启蓝牙还需要定位权限，定位权限属于危险权限，需要动态申请： 12345678910private void initPermission() &#123; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; …………………… //请求权限 requestPermissions(new String[]&#123;Manifest.permission.WRITE_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION); &#125;&#125; 如果是在 Fragment 中使用，则是 xxxFragment.this.requestPermissions requestPermissions 的回调方法是 123456789@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION: Toast.makeText(getActivity(), &quot;已经可以定位了&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 请求位置服务判断是否开启定位功能1234567891011121314/** * 开启定位功能 * @param context * @return */private static boolean isLocationEnable(Context context) &#123; LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE); boolean networkProvider = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER); boolean gpsProvider = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER); if (networkProvider || gpsProvider) &#123; return true; &#125; return false;&#125; 开启定位服务123456789/** * 获取定位服务 * * @param context */private static void setLocationService(Context context) &#123; Intent locationIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS); ((Activity) context).startActivityForResult(locationIntent, Global.REQUEST_CODE_LOCATION_SETTINGS);&#125; 扫描设备在 android 6.0 中，使用 BluetoothLeScanner.startScan() 来扫描的： 123456789101112131415161718192021222324252627282930313233343536/** * 扫描 BLE 设备 * @param enable */public void scanDevices(boolean enable) &#123; LogUtil.i(TAG, &quot;BluetoothAdapter 状态：&quot; + mBluetoothAdapter.getState()); if (enable) &#123; /*new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; mBluetoothAdapter.getBluetoothLeScanner().stopScan(mScanCallback); &#125; &#125;, 3000);*/ LogUtil.i(TAG, &quot;正在搜索设备…………&quot;); mBluetoothAdapter.getBluetoothLeScanner().startScan(mScanCallback); &#125; else &#123; LogUtil.i(TAG, &quot;停止搜索设备&quot;); mBluetoothAdapter.getBluetoothLeScanner().stopScan(mScanCallback); &#125;&#125;private ScanCallback mScanCallback = new ScanCallback() &#123; @Override public void onScanResult(int callbackType, ScanResult result) &#123; super.onScanResult(callbackType, result); Bundle data = new Bundle(); data.putParcelable(BluetoothDevice.EXTRA_DEVICE, result.getDevice()); Intent intent = new Intent(); intent.setAction(ACTION_DEVICE_FOUND); intent.putExtras(data); sendBroadcast(intent); &#125;&#125;; 注册广播123456789101112131415/** * 初始化广播 */private void initBroadcastReceiver() &#123; IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); intentFilter.addAction(BluetoothService.ACTION_DEVICE_FOUND); intentFilter.addAction(BluetoothService.ACTION_GATT_SERVICES_DISCOVERED_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_DESCRIPTOR_WRITE_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_CHARACTERISTIC_WRITE_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_CHARACTERISTIC_DATA_REPLY); registerReceiver(broadcastReceiver, intentFilter);&#125; 123456789101112/** * 广播接收器 */private BroadcastReceiver broadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) &#123; ………… &#125; &#125; 连接设备需要获取 BluetoothGATT 再进行操作： 1234567891011121314151617181920212223242526/** * 连接目标 BLE 设备 * * @param address * @return */public boolean connect(final String address) &#123; if (mBluetoothAdapter == null || address == null) &#123; LogUtil.e(TAG, &quot;BluetoothAdapter not initialized or unspecified address.&quot;); return false; &#125; final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address); if (device == null) &#123; LogUtil.e(TAG, &quot;Device not found. Unable to connect.&quot;); return false; &#125; // We want to directly connect to the device, so we are setting the autoConnect // parameter to false. mBluetoothGatt = device.connectGatt(this, false, mGattCallback); LogUtil.i(TAG, &quot;成功连接上设备：&quot; + device.getName()); LogUtil.i(TAG, &quot;------------Create a new connection.------------&quot;); return true;&#125; 当 GATT 客户端连接上或者连接状态改变时，调用 onConnectionStateChange。 如果使用：device.connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport) 根据源码 @param transport preferred transport for GATT connections to remote dual-mode devices跟双模设备连接，transport 如果不传默认 TRANSPORT_AUTO，6.0系统及以上需要使用 TRANSPORT_LE 这种传输模式。 发现服务当使用 mBluetoothGatt.discoverServices() 时，则调用 onServicesDiscovered。 获取 BluetoothGattService 和 BluetoothGattCharacteristic12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 获取 BluetoothGattService * * @param bluetoothGatt * @param uuid_service * @return */ private BluetoothGattService getBluetoothGATTService(BluetoothGatt bluetoothGatt, UUID uuid_service) &#123; if (mBluetoothGatt != null) &#123; BluetoothGattService bluetoothGattService = mBluetoothGatt.getService(uuid_service); if (bluetoothGattService != null) &#123; //LogUtil.i(TAG, &quot;成功获取 bluetoothGattService：&quot; + uuid_service); return bluetoothGattService; &#125; else &#123; LogUtil.e(TAG, &quot;bluetoothgatt get service uuid:&quot; + uuid_service + &quot; is null&quot;); &#125; &#125; else &#123; LogUtil.e(TAG, &quot;mBluetoothGatt is null&quot;); &#125; return null; &#125; /** * 获取 BluetoothGattCharacteristic * * @param bluetoothGattService * @param uuid_characteristic * @return */ private BluetoothGattCharacteristic getBluetoothGattCharacteristic(BluetoothGattService bluetoothGattService, UUID uuid_characteristic) &#123; if (bluetoothGattService != null) &#123; BluetoothGattCharacteristic bluetoothGattCharacteristic = bluetoothGattService.getCharacteristic(uuid_characteristic); if (bluetoothGattCharacteristic != null) &#123; //LogUtil.i(TAG, &quot;成功获取 bluetoothGattCharacteristic：&quot; + uuid_characteristic); return bluetoothGattCharacteristic; &#125; else &#123; LogUtil.e(TAG, &quot;bluetoothGattService get characteristic uuid:&quot; + uuid_characteristic + &quot; is null&quot;); &#125; &#125; else &#123; LogUtil.e(TAG, &quot;bluetoothGattService is null&quot;); &#125; return null; &#125; 开启通知，并且写入 DescriptorWriteCharacteristic() 后有数据返回，则需要先： 12345678910111213141516171819202122232425/** * 设置 Characteristic 通知属性，并且写上 Descriptor */ private void setCharacteristicNotifyAndWriteDescriptor(UUID uuid_service, UUID uuid_characteristic, UUID uuid_descriptor) &#123; BluetoothGattService mBluetoothGattService = getBluetoothGATTService(mBluetoothGatt, uuid_service); BluetoothGattCharacteristic mBluetoothGattCharacteristic = getBluetoothGattCharacteristic(mBluetoothGattService, uuid_characteristic); if (mBluetoothGatt != null &amp;&amp; mBluetoothGattCharacteristic != null) &#123; mBluetoothGatt.setCharacteristicNotification(mBluetoothGattCharacteristic, true); BluetoothGattDescriptor mBluetoothGattDescriptor = mBluetoothGattCharacteristic.getDescriptor(uuid_descriptor); if (mBluetoothGattDescriptor != null) &#123; LogUtil.i(TAG, &quot;成功设置 mBluetoothGattDescriptor&quot;); mBluetoothGattDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); mBluetoothGatt.writeDescriptor(mBluetoothGattDescriptor); &#125; &#125; else if (mBluetoothGatt == null) &#123; LogUtil.e(TAG, &quot;mBluetoothGatt is null&quot;); &#125; else if (mBluetoothGattCharacteristic == null) &#123; LogUtil.e(TAG, &quot;mBluetoothGattCharacteristic is null&quot;); &#125; &#125; 然后会回调 onDescriptorWrite 写入 Characteristic12345678910111213141516171819202122/** * 写入 Characteristic * @param uuid_service * @param uuid_characteristic * @param value */private void writeCharacteristic(UUID uuid_service, UUID uuid_characteristic, byte[] value) &#123; BluetoothGattService mBluetoothGattService = getBluetoothGATTService(mBluetoothGatt, uuid_service); BluetoothGattCharacteristic mBluetoothGattCharacteristic = getBluetoothGattCharacteristic(mBluetoothGattService, uuid_characteristic); if (mBluetoothGatt != null &amp;&amp; mBluetoothGattCharacteristic != null) &#123; mBluetoothGattCharacteristic.setValue(value); mBluetoothGattCharacteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE); mBluetoothGatt.writeCharacteristic(mBluetoothGattCharacteristic); &#125;else if (mBluetoothGatt == null) &#123; LogUtil.e(TAG, &quot;mBluetoothGatt is null&quot;); &#125; else if (mBluetoothGattCharacteristic == null) &#123; LogUtil.e(TAG, &quot;mBluetoothGattCharacteristic is null&quot;); &#125;&#125; 则先回调 onCharacteristicWrite，然后回调 onCharacteristicChanged。 BluetoothGatt 的回调1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * BluetoothGatt 的回调 */private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; super.onConnectionStateChange(gatt, status, newState); if (newState == BluetoothProfile.STATE_CONNECTED) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; LogUtil.i(TAG, &quot;Connected To GATT Server&quot;); LogUtil.i(TAG, &quot;Attempting To Start Service Discovery:&quot; + mBluetoothGatt.discoverServices()); broadcastUpdate(ACTION_GATT_CONNECTED); &#125; else &#123; disconnect(); close(); &#125; &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123; close(); &#125; &#125; @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; super.onServicesDiscovered(gatt, status); LogUtil.i(TAG, &quot;onServicesDiscovered received: &quot; + status); if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED_SUCCESS); &#125; else &#123; LogUtil.i(TAG, &quot;onServicesDiscovered received: &quot; + status); &#125; &#125; @Override public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorWrite(gatt, descriptor, status); if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_DESCRIPTOR_WRITE_SUCCESS); &#125; &#125; @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicWrite(gatt, characteristic, status); if (status == BluetoothGatt.GATT_SUCCESS)&#123; broadcastUpdate(ACTION_GATT_CHARACTERISTIC_WRITE_SUCCESS); //LogUtil.i(TAG, &quot;onCharacteristicWrite 返回的数据&quot; + Arrays.toString(characteristic.getValue())); &#125; &#125; @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicChanged(gatt, characteristic); LogUtil.i(TAG, &quot;onCharacteristicChanged 返回的数据&quot; + Arrays.toString(characteristic.getValue())); broadcastUpdate(ACTION_GATT_CHARACTERISTIC_DATA_REPLY, KEY_HOUR_DATA, characteristic.getValue()); &#125; @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicRead(gatt, characteristic, status); &#125; @Override public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorRead(gatt, descriptor, status); &#125;&#125;; 发送广播12345678910111213141516/** * 发送广播 * * @param action */private void broadcastUpdate(final String action) &#123; final Intent intent = new Intent(action); sendBroadcast(intent);&#125;private void broadcastUpdate(final String action, String key, byte[] value)&#123; final Intent intent = new Intent(action); intent.putExtra(key, value); sendBroadcast(intent);&#125; 参考资料 Android蓝牙4.0 BLE开发坑总结 Android BLE 多次writeCharacteristic 为什么只有一个回调]]></content>
      <categories>
        <category>Android</category>
        <category>BLE</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BLE 4.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BLE 手环开发总结]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%89%8B%E7%8E%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基础功能 显示步数、距离、卡路里、电量、目标完成状况 功能实现过程 通过手机蓝牙与手环连接，手机 APP 发送个人设置数据给手环；当手环接收数据成功后，更新用户信息，同时返回当前时刻到上一次同步数据时刻的数据（注：数据以1小时为单位，返回的每个1小时数据是每个1小时的累计数据)，这次返回的数据中含有掉电标志字节，用于判断本次数据同步是正常还是掉电后重新上电后的第一次同步。 手机 APP 发送请求同步手环屏幕当前显示数据的数据给手环；手环接收数据成功后，返回步数、距离、卡路里、电量的数据。 手机 APP 发送请求同步手环72个小时数据的数据给手环；手环接收数据成功后，返回步数、卡路里、每个小时的 UTC 秒数的数据。 开发辅助数据库框架greenDAO 简书上面的参考资料： Android Study 之 玩转GreenDao 3.2.2 点滴提升逼格~ 数据库调试Android-Debug-Database 智能刷新框架SmartRefreshLayout 图表显示框架MPAndroidChart CSDN 上面的两篇参考资料： Android图表控件MPAndroidChart的简单介绍（MPAndroidChart3.0 MPAndroidChart 教程 Fragment 切换指示器SpringIndicator 自定义选择器框架AndroidPicker 遇到的问题 BLE 以6.0版本为界限的开发流程、GATT 规范 Java 获取当前时间以及各种转换 ViewPager + Fragment 使用 Activity 和 Fragment 跳转、数据交互 BottomNavigationView 使用 Broadcast 使用 Service 使用 Intent 使用 异步使用 enum 自定义 View 参考：仿支付宝芝麻信用的仪表盘安卓自定义View教程 Fragment 的 add、hide、show。简书收藏几篇文章 由于手环储存的步数数据仅为1个小时的累计，所以当用图表显示月、年的时候，需要对数据进行处理 实时监控手机的网络、蓝牙状态变化 蓝牙、定位、位置服务权限申请 byte[] 数组对应天数开关处理 Fragment 的接口回调 自定义一个 NoScrollViewPagerAdapter 自定义一个 LogUtil RecyclerView 使用 Bundle 使用 改进 引入 ButterKnife 使用异步加载图表数据，现在加载月、年数据比较慢 同步时间过长之后，再次同步一次会出现数据错乱情况 引入网络数据 引入 Google 的 easypermissions 作为权限获取库]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BLE 4.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ICON 资源网站]]></title>
    <url>%2F2018%2F07%2F05%2FICON%20%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Android Asset Studio Material Palette easyicon]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ICON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPAndroidChart 翻译]]></title>
    <url>%2F2018%2F07%2F02%2FMPAndroidChart%20%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[MPAndroidChart 开始本章介绍使用此库的基本设置。 添加依赖作为第一步，将该库的依赖项添加到您的项目中。 如何添加依赖已经在此存储库的用法部分中进行了介绍。 推荐使用 Gradle 方式作为添加依赖的方式。 创建界面使用 LineChart, BarChart, ScatterChart, CandleStickChart, PieChart, BubbleChart or RadarChart ，在 .xml 中定义：1234&lt;com.github.mikephil.charting.charts.LineChart android:id=&quot;@+id/chart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 然后从 Activity, Fragment or whatever 中取回：12// in this example, a LineChart is initialized from xmlLineChart chart = (LineChart) findViewById(R.id.chart); 或者使用代码来创建（跟着在 layout 添加）123456// programmatically create a LineChartLineChart chart = new LineChart(Context);// get a layout defined in xmlRelativeLayout rl = (RelativeLayout) findViewById(R.id.relativeLayout);rl.add(chart); // add the programmatically created chart 添加数据在获得图表实例后，你可以创建数据并且添加到图表。这个例子使用的是 LineChart，Entry 类代表图表中一个点的 X，Y 坐标。其他图表类型，例如 BarChart 使用 BarEntry。添加数据到图表，将每一个数据代入到 Entry 中，例如：123456789YourData[] dataObjects = ...;List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;();for (YourData data : dataObjects) &#123; // turn your data into Entry objects entries.add(new Entry(data.getValueX(), data.getValueY()));&#125; 下一步，将 List 添加到 LineDataSet。DataSet 对象保存数据，同时允许单独设置数据的样式。如果启用，下面使用的“标签”仅具有描述性目的，并显示在图表中。123LineDataSet dataSet = new LineDataSet(entries, &quot;Label&quot;); // add entries to datasetdataSet.setColor(...);dataSet.setValueTextColor(...); // styling, ... 最后一步，添加 LineDataSet 对象到 LineData 对象。这个对象持有 chart 实例的所有数据，并允许有单独样式。在你建立数据对象后，你可以使用它建立图表并刷新：123LineData lineData = new LineData(dataSet);chart.setData(lineData);chart.invalidate(); // refresh 请考虑到上面的仅仅是基本应用。需要更详细的扩展应用，请参考 setting data 部分，其中有很多添加数据到不同 chart 类型图表的例子。 样式有关图表外观和数据的设置和样式的信息，请参考 general settings &amp; styling 部分。关于单个图表类型的更具体的样式和设置，请参考 specific settings &amp; styling。 与图表交互该库允许您完全自定义与图表视图的可能触摸（和手势）交互，并通过回调方法对交互作出反应。 启用/禁用交互 setTouchEnabled(boolean enabled) 允许启用/禁用与图表的所有可能的触摸交互。 setDragEnabled(boolean enabled) 启用/禁用图表的拖动（平移）。 setScaleEnabled(boolean enabled) 启用/禁用两个轴上的图表缩放。 setScaleXEnabled(boolean enabled) 启用/禁用 X 轴缩放。 setScaleYEnabled(boolean enabled) 启用/禁用 Y 轴缩放。 setPinchZoom(boolean enabled) 如果设置为 true，则启用缩放。如果禁用，则可以单独缩放 X 轴和 Y 轴。 setDoubleTapToZoomEnabled(boolean enabled) 将此设置为 false 以禁止通过双击来缩放图表。 图表抛物线/减速 setDragDecelerationEnabled(boolean enabled) 如果设置为 true，则图表会在触摸后继续滚动。 默认值：true。 setDragDecelerationFrictionCoef(float coef) 减速摩擦系数在 [0; 1] 之间，较高的值表示速度将缓慢下降，例如，如果设置为 0，它将立即停止。 1 是无效值，将自动转换为 0.9999。 突出显示值如何允许通过点击手势和编程方式，突出显示条目在 highlightning section 中进行了描述。 手势回调OnChartGestureListener 将允许您对图表上的手势做出反应： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface OnChartGestureListener &#123; /** * Callbacks when a touch-gesture has started on the chart (ACTION_DOWN) * * @param me * @param lastPerformedGesture */ void onChartGestureStart(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when a touch-gesture has ended on the chart (ACTION_UP, ACTION_CANCEL) * * @param me * @param lastPerformedGesture */ void onChartGestureEnd(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when the chart is longpressed. * * @param me */ public void onChartLongPressed(MotionEvent me); /** * Callbacks when the chart is double-tapped. * * @param me */ public void onChartDoubleTapped(MotionEvent me); /** * Callbacks when the chart is single-tapped. * * @param me */ public void onChartSingleTapped(MotionEvent me); /** * Callbacks then a fling gesture is made on the chart. * * @param me1 * @param me2 * @param velocityX * @param velocityY */ public void onChartFling(MotionEvent me1, MotionEvent me2, float velocityX, float velocityY); /** * Callbacks when the chart is scaled / zoomed via pinch zoom gesture. * * @param me * @param scaleX scalefactor on the x-axis * @param scaleY scalefactor on the y-axis */ public void onChartScale(MotionEvent me, float scaleX, float scaleY); /** * Callbacks when the chart is moved / translated via drag gesture. * * @param me * @param dX translation distance on the x-axis * @param dY translation distance on the y-axis */ public void onChartTranslate(MotionEvent me, float dX, float dY);&#125; 只需让你接收回调的类实现这个接口，并将其设置为图表的监听器：1chart.setOnChartGestureListener(this); 高亮显示值本节重点介绍通过 tap-gesture 和基于发行版 v3.0.0 以编程方式，高亮显示图表中条目的主题。 启用/禁用高亮显示 setHighlightPerDragEnabled(boolean enabled) 在图表上将此设置为 true，以便在完全缩小时，在图表表面上进行每次拖动时高亮显示。 默认值： true setHighlightPerTapEnabled(boolean enabled) 在图表上将此设置为 false，以防止通过点击手势高亮显示值。 但仍可通过拖动或以编程方式高亮显示值。 默认值： true setMaxHighlightDistance(float distanceDp) 在 dp 中设置最大的高光距离。在图表上轻敲远离条目的距离，不会触发高亮显示。 默认值： 500dp 除此之外，还可以为各个 DataSet 对象配置高亮显示：123456dataSet.setHighlightEnabled(true); // allow highlighting for DataSet // set this to false to disable the drawing of highlight indicator (lines) dataSet.setDrawHighlightIndicators(true); dataSet.setHighlightColor(Color.BLACK); // color for highlight indicator // and more... 以编程方式突出显示 highlightValue(float x, int dataSetIndex, boolean callListener) 高亮显示给定 DataSet 中给定 x位置的值。 提供 -1 作为 dataSetIndex 以撤消所有高亮显示。布尔标志确定是否应该调用选择侦听器。 highlightValue(Highlight high, boolean callListener) 高亮显示提供的 Highlight对象 所代表的值。提供 null 以撤消所有高亮显示。布尔标志确定是否应该调用选择侦听器。 highlightValues(Highlight[] highs) 高亮显示给定 Highlight [] 数组所表示的值。提供 null 或空数组以撤消所有高亮显示。 getHighlighted() 返回 Highlight [] 数组，其中包含有关所有高亮显示的条目，x-index 和 dataset-index 的信息。 选择回调该库在交互时为回调提供了许多侦听器。 其中一个是 OnChartValueSelectedListener，用于通过触控高亮显示值时的回调： 1234567891011121314 public interface OnChartValueSelectedListener &#123; /** * Called when a value has been selected inside the chart. * * @param e The selected Entry. * @param h The corresponding highlight object that contains information * about the highlighted position */ public void onValueSelected(Entry e, Highlight h); /** * Called when nothing has been selected or an &quot;un-select&quot; has been made. */ public void onNothingSelected();&#125; 只需让你的接收回调的类，实现这个接口并将其设置为图表的监听器：chart.setOnChartValueSelectedListener(this); 高亮的类Highlight类 表示与高亮显示的 Entry 关联的所有数据，例如高亮显示的 Entry对象 本身，它所属的 DataSet，它在绘图表面上的位置等等。它可用于获取有关已高亮显示的条目的信息，或用于向图表提供要高亮显示的条目的信息。关于这个目的，Highlight类 提供了两个构造函数：12345/** constructor for standard highlight */public Highlight(float x, int dataSetIndex) &#123; ... &#125;/** constructor for stacked BarEntry highlight */public Highlight(float x, int dataSetIndex, int stackIndex) &#123; ... &#125; 这些构造函数可用于创建 Highlight对象，该对象允许以编程方式执行突出显示：1234// highlight the entry and x-position 50 in the first (0) DataSetHighlight highlight = new Highlight(50f, 0);chart.highlightValue(highlight, false); // highlight this value, don&apos;t call listener 自定义高亮所有用户输入的高亮手势形式，都由默认的 ChartHighlighter类 在内部处理。使用以下方法，用自定义实现替换默认的 highligher： setHighlighter（ChartHighlighter highlighter） 为图表设置自定义 highligher对象，以处理在图表视图上执行的所有高亮触摸事件。您自定义的 highlighter对象 需要继承 ChartHighlighter类。]]></content>
      <categories>
        <category>Android</category>
        <category>Chart</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Chart</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON 数据解析]]></title>
    <url>%2F2018%2F06%2F26%2FJSON%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[JSONObject 及 JSONArray 取值String 转 JSONObject 或 JSONArrayJSONArray jsonArray = JSONArray.fromObject(str); JSONObject jsonObject = JSONObject.fromObject(str); JSONObject 中获取 JSONArray 或 StringJSONObject jsonObject = new JSONObject(resource); String str = jsonObject.getString(&quot;str&quot;); //获取 sequences的值 JSONArray sequencesArray = jsonObject.getJSONArray(&quot;sequences&quot;); JSONObject 中还有其它 get 方法。 JSONArray 中获取 JSONObject 或 StringJSONArray jsonArray = new JSONArray(resource); String str = jsonArray.getString(0); JSONObject jsonObject = jsonArray.getJSONObject(0); 解析 json 格式的数据时要看清楚，最外面为 { 的是 JSONObject ，为 [ 的是JSONArray。 实例JSONArray 中获取 JSONObject1234567891011121314151617181920212223242526272829303132public class Province extends DataSupport &#123; private int id; private String provinceName; private int provinceCode; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getProvinceName() &#123; return provinceName; &#125; public void setProvinceName(String provinceName) &#123; this.provinceName = provinceName; &#125; public int getProvinceCode() &#123; return provinceCode; &#125; public void setProvinceCode(int provinceCode) &#123; this.provinceCode = provinceCode; &#125;&#125; 1JSON 数组 [&#123;&quot;id&quot;:1, &quot;name&quot;:北京&#125;,&#123;&quot;id&quot;:2, &quot;name&quot;:上海&#125;,&#123;&quot;id&quot;:3, &quot;name&quot;:天津&#125;,&#123;&quot;id&quot;:4, &quot;name&quot;:重庆&#125;,&#123;&quot;id&quot;:5, &quot;name&quot;:香港&#125;] 123456789101112131415161718public static boolean handleProvinceResponse(String response) &#123; if (!TextUtils.isEmpty(response)) &#123; try &#123; JSONArray allProvinces = new JSONArray(response); for (int i = 0; i &lt; allProvinces.length(); i++) &#123; JSONObject provinceObject = allProvinces.getJSONObject(i); Province province = new Province(); province.setProvinceName(provinceObject.getString(&quot;name&quot;)); province.setProvinceCode(provinceObject.getInt(&quot;id&quot;)); province.save(); &#125; return true; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; JSONObject 中获取 JSONArray，然后在从 JSONArray 中获取 JSONObject12345678910111213141516public class Weather &#123; public String status; public Basic basic; public AQI aqi; public Now now; public Suggestion suggestion; @SerializedName(&quot;daily_forecast&quot;) public List&lt;Forecast&gt; forecastList;&#125; 1&#123;&quot;HeWeather&quot;: [&#123;&quot;basic&quot;:&#123;&quot;cid&quot;:&quot;CN101300105&quot;,&quot;location&quot;:&quot;隆安&quot;,&quot;parent_city&quot;:&quot;南宁&quot;,&quot;admin_area&quot;:&quot;广西&quot;,&quot;cnty&quot;:&quot;中国&quot;,&quot;lat&quot;:&quot;23.17476273&quot;,&quot;lon&quot;:&quot;107.68865967&quot;,&quot;tz&quot;:&quot;+8.00&quot;,&quot;city&quot;:&quot;隆安&quot;,&quot;id&quot;:&quot;CN101300105&quot;,&quot;update&quot;:&#123;&quot;loc&quot;:&quot;2018-05-02 11:47&quot;,&quot;utc&quot;:&quot;2018-05-02 03:47&quot;&#125;&#125;,&quot;update&quot;:&#123;&quot;loc&quot;:&quot;2018-05-02 11:47&quot;,&quot;utc&quot;:&quot;2018-05-02 03:47&quot;&#125;,&quot;status&quot;:&quot;ok&quot;,&quot;now&quot;:&#123;&quot;cloud&quot;:&quot;25&quot;,&quot;cond_code&quot;:&quot;300&quot;,&quot;cond_txt&quot;:&quot;阵雨&quot;,&quot;fl&quot;:&quot;32&quot;,&quot;hum&quot;:&quot;71&quot;,&quot;pcpn&quot;:&quot;0.0&quot;,&quot;pres&quot;:&quot;1014&quot;,&quot;tmp&quot;:&quot;29&quot;,&quot;vis&quot;:&quot;10&quot;,&quot;wind_deg&quot;:&quot;107&quot;,&quot;wind_dir&quot;:&quot;东南风&quot;,&quot;wind_sc&quot;:&quot;1&quot;,&quot;wind_spd&quot;:&quot;4&quot;,&quot;cond&quot;:&#123;&quot;code&quot;:&quot;300&quot;,&quot;txt&quot;:&quot;阵雨&quot;&#125;&#125;,&quot;daily_forecast&quot;:[&#123;&quot;date&quot;:&quot;2018-05-02&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;中雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;30&quot;,&quot;min&quot;:&quot;23&quot;&#125;&#125;,&#123;&quot;date&quot;:&quot;2018-05-03&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;阵雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;27&quot;,&quot;min&quot;:&quot;22&quot;&#125;&#125;,&#123;&quot;date&quot;:&quot;2018-05-04&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;阵雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;28&quot;,&quot;min&quot;:&quot;23&quot;&#125;&#125;],&quot;hourly&quot;:[&#123;&quot;cloud&quot;:&quot;90&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;26&quot;,&quot;hum&quot;:&quot;83&quot;,&quot;pop&quot;:&quot;58&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-02 13:00&quot;,&quot;tmp&quot;:&quot;30&quot;,&quot;wind_deg&quot;:&quot;188&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;11&quot;&#125;,&#123;&quot;cloud&quot;:&quot;95&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;24&quot;,&quot;hum&quot;:&quot;85&quot;,&quot;pop&quot;:&quot;49&quot;,&quot;pres&quot;:&quot;1010&quot;,&quot;time&quot;:&quot;2018-05-02 16:00&quot;,&quot;tmp&quot;:&quot;30&quot;,&quot;wind_deg&quot;:&quot;172&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;1&quot;&#125;,&#123;&quot;cloud&quot;:&quot;98&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;24&quot;,&quot;hum&quot;:&quot;87&quot;,&quot;pop&quot;:&quot;25&quot;,&quot;pres&quot;:&quot;1010&quot;,&quot;time&quot;:&quot;2018-05-02 19:00&quot;,&quot;tmp&quot;:&quot;29&quot;,&quot;wind_deg&quot;:&quot;173&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;8&quot;&#125;,&#123;&quot;cloud&quot;:&quot;99&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;23&quot;,&quot;hum&quot;:&quot;89&quot;,&quot;pop&quot;:&quot;20&quot;,&quot;pres&quot;:&quot;1013&quot;,&quot;time&quot;:&quot;2018-05-02 22:00&quot;,&quot;tmp&quot;:&quot;28&quot;,&quot;wind_deg&quot;:&quot;27&quot;,&quot;wind_dir&quot;:&quot;东北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;9&quot;&#125;,&#123;&quot;cloud&quot;:&quot;99&quot;,&quot;cond_code&quot;:&quot;104&quot;,&quot;cond_txt&quot;:&quot;阴&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;90&quot;,&quot;pop&quot;:&quot;71&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-03 01:00&quot;,&quot;tmp&quot;:&quot;25&quot;,&quot;wind_deg&quot;:&quot;5&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;6&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;306&quot;,&quot;cond_txt&quot;:&quot;中雨&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;93&quot;,&quot;pop&quot;:&quot;49&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-03 04:00&quot;,&quot;tmp&quot;:&quot;24&quot;,&quot;wind_deg&quot;:&quot;2&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;6&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;104&quot;,&quot;cond_txt&quot;:&quot;阴&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;93&quot;,&quot;pop&quot;:&quot;34&quot;,&quot;pres&quot;:&quot;1013&quot;,&quot;time&quot;:&quot;2018-05-03 07:00&quot;,&quot;tmp&quot;:&quot;23&quot;,&quot;wind_deg&quot;:&quot;11&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;10&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;86&quot;,&quot;pop&quot;:&quot;70&quot;,&quot;pres&quot;:&quot;1015&quot;,&quot;time&quot;:&quot;2018-05-03 10:00&quot;,&quot;tmp&quot;:&quot;23&quot;,&quot;wind_deg&quot;:&quot;3&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;2&quot;&#125;],&quot;aqi&quot;:&#123;&quot;city&quot;:&#123;&quot;aqi&quot;:&quot;51&quot;,&quot;pm25&quot;:&quot;29&quot;,&quot;qlty&quot;:&quot;良&quot;&#125;&#125;,&quot;suggestion&quot;:&#123;&quot;comf&quot;:&#123;&quot;type&quot;:&quot;comf&quot;,&quot;brf&quot;:&quot;较舒适&quot;,&quot;txt&quot;:&quot;白天有雨，从而使空气湿度加大，会使人们感觉有点儿闷热，但早晚的天气很凉爽、舒适。&quot;&#125;,&quot;sport&quot;:&#123;&quot;type&quot;:&quot;sport&quot;,&quot;brf&quot;:&quot;较不宜&quot;,&quot;txt&quot;:&quot;有较强降水，建议您选择在室内进行健身休闲运动。&quot;&#125;,&quot;cw&quot;:&#123;&quot;type&quot;:&quot;cw&quot;,&quot;brf&quot;:&quot;不宜&quot;,&quot;txt&quot;:&quot;不宜洗车，未来24小时内有雨，如果在此期间洗车，雨水和路上的泥水可能会再次弄脏您的爱车。&quot;&#125;&#125;&#125;]&#125; 12345678910111213141516/** * 将返回的 JSON 数据解析成 Weather 实体类 */public static Weather parseWeatherResponse(String response) &#123; try &#123; JSONObject jsonObject = new JSONObject(response); JSONArray jsonArray = jsonObject.getJSONArray(&quot;HeWeather&quot;); String weatherContent = jsonArray.getJSONObject(0).toString(); return new Gson().fromJson(weatherContent, Weather.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
</search>
