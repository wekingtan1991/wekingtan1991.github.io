<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RecyclerView使用]]></title>
    <url>%2F2018%2F07%2F05%2FRecyclerView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Fragment 使用]]></title>
    <url>%2F2018%2F07%2F05%2FFragment%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Fragment 的 add、hide、show123456789101112131415161718192021222324252627282930313233343536373839404142434445public class FragmentHelper &#123; /** * 添加 Fragment * @param fragmentManager * @param fragment * @param fragmentTag */ public static void addFragment(FragmentManager fragmentManager, Fragment fragment, String fragmentTag)&#123; if (fragmentManager != null)&#123; FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.add(R.id.frag_main, fragment, fragmentTag); transaction.commit(); &#125; &#125; /** * 显示已存在的 Fragment * @param fragmentManager * @param fragment */ public static void showFragment(FragmentManager fragmentManager, Fragment fragment)&#123; FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); if (fragment != null)&#123; fragmentTransaction.show(fragment); fragmentTransaction.commit(); &#125; &#125; /** * 隐藏所有的 Fragment * @param fragmentManager */ public static void hideAllFragment(FragmentManager fragmentManager)&#123; FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); Fragment dashboard_fragment = fragmentManager.findFragmentByTag(&quot;dashboard_fragment&quot;); if (dashboard_fragment != null)&#123; fragmentTransaction.hide(dashboard_fragment); &#125; fragmentTransaction.commit(); &#125;&#125; 参考资料 Fragment全解析系列 Fragment你真的熟悉吗？看了才知道 Android基础：Fragment，看这篇就够了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 View]]></title>
    <url>%2F2018%2F07%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"><![CDATA[参考资料 安卓自定义View教程 仿支付宝芝麻信用的仪表盘]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义 View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intent使用]]></title>
    <url>%2F2018%2F07%2F05%2FIntent%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Service使用]]></title>
    <url>%2F2018%2F07%2F05%2FService%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Broadcast 使用]]></title>
    <url>%2F2018%2F07%2F05%2FBroadcast%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[广播机制 标准广播 完全异步执行，所有广播接收器同时接收 有序广播 同步执行，同一时刻只有一个广播接收器可以接收 接收系统广播动态注册监听网络变化动态注册的广播接收器可以随意地控制注册和注销，但必须要在程序启动之后才能街道广播。 静态注册实现开机启动发送自定义广播发送标准广播发送有序广播使用 sendOrderBrocast() 发送广播，同时需要在 AndroidManifest 中设置优先级 &lt;intent-filter android:priority= &gt; 使用本地广播LocalBroadcastManger 来管理广播。LocalBroadcastManger localBroadcastmanger = LocalBroadcastManger.getInstance(this); 获取 LocalBroadcastManger 实例。localBroadcastmanger.sendBroadcast() 发送广播。localBroadcastmanger.registerReceiver() 注册广播。localBroadcastmanger.unregisterReceiver() 注销广播。 利用广播实现强制下线功能 首先定义一个活动回收器 ActivityCollector 类，创建一个列表来管理活动，ActivityCollector 类里面包含添加活动 addActivity、移除活动 removeActivity、结束活动 finishAll 的方法。 创建一个 BaseActivity 类作为所有活动的父类，同时复写 onCreate 添加 addActivity 方法；复写 onDestroy 添加 removeActivity 方法；复写 onResume 在里面注册广播；复写 onPause 在里面注销广播；在 ForceOfflineReceiver 的 onReceive 方法里面放入 finishAll 方法。 让需要实现强制下线功能的 Activity 继承 BaseActivity 类，同时发送强制下线功能的广播。 利用静态广播实现 APP 开机自动启动]]></content>
  </entry>
  <entry>
    <title><![CDATA[ViewPager使用]]></title>
    <url>%2F2018%2F07%2F05%2FViewPager%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java 获取时间日期方法]]></title>
    <url>%2F2018%2F07%2F05%2FJava%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[单个获取年、月、日、时、分1234567891011121314151617181920212223242526272829303132333435363738394041public static int getYear() &#123; //获取系统的日期 Calendar calendar = Calendar.getInstance(); //年 int year = calendar.get(Calendar.YEAR); return year; &#125; public static int getMonth() &#123; Calendar calendar = Calendar.getInstance(); //月份需要加 1，因为是从 0 开始算的 int month = calendar.get(Calendar.MONTH) + 1; return month; &#125; public static int getDay() &#123; Calendar calendar = Calendar.getInstance(); int day = calendar.get(Calendar.DAY_OF_MONTH); return day; &#125; public static int getHour() &#123; Calendar calendar = Calendar.getInstance(); int hour = calendar.get(Calendar.HOUR_OF_DAY); return hour; &#125; public static int getMinute() &#123; Calendar calendar = Calendar.getInstance(); int minute = calendar.get(Calendar.MINUTE); return minute; &#125; 获取当前时间12345678910/** * 获取当前时间的年月日 * @return */ public static String simpleDate()&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); Date date = new Date(System.currentTimeMillis()); return simpleDateFormat.format(date); &#125; 以当前时间为原点，往前或往后查询某一天123456789101112131415161718192021222324/** * 显示某一日的数据 * @param dateIndex * @return */ public static String getDisplayOffsetDate(int dateIndex)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日&quot;); if (dateIndex == 0)&#123; Date date = new Date(System.currentTimeMillis()); return simpleDateFormat.format(date); &#125;else &#123; Date beginDate = new Date();//获取当天 年月日+时间+时区 Calendar date = Calendar.getInstance();//获取当天更加详细时间 date.setTime(beginDate); date.set(Calendar.DATE, date.get(Calendar.DATE) + dateIndex); Date endDate = null; try &#123; endDate = simpleDateFormat.parse(simpleDateFormat.format(date.getTime())); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return simpleDateFormat.format(endDate); &#125; &#125; 如果查询某一年、某一月，则改变 Calendar.DATE 为 YEAR 或 MONTH。 查询某一个月有多少天1234567891011121314151617/** * 查询某一个月一共有多少天 * @param date * @return */public static int getDaysOfMonth(String date)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月&quot;); Date timeMillis = new Date(); try &#123; timeMillis = simpleDateFormat.parse(date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; Calendar calendar = Calendar.getInstance(); calendar.setTime(timeMillis); return calendar.getActualMaximum(Calendar.DAY_OF_MONTH);&#125; 设置 calendar 的时间为 2000-01-01-00-00，并获取 1970至2000-01-01-00-00时间的毫秒12345678910111213141516171819202122/** * 2000-01-01-00-00 * @return */public static Calendar get20000101Datetime() &#123; Calendar cal_ = Calendar.getInstance(); cal_.set(Calendar.YEAR, 2000); cal_.set(Calendar.MONTH, Calendar.JANUARY); cal_.set(Calendar.DATE, 1); cal_.set(Calendar.HOUR_OF_DAY, 0); cal_.set(Calendar.MINUTE, 0); cal_.set(Calendar.SECOND, 0); cal_.set(Calendar.MILLISECOND, 0); return cal_;&#125;//设置 calendar 的时间为 2000-01-01-00-00Calendar calendar = get20000101Datetime();//setTimeInMillis 为 （1970至2000-01-01-00-00时间的毫秒）calendar.getTimeInMillis(); 把 String 类型的日期，转换为日期的毫秒数12345678910111213141516/** * 把 String 类型的日期，转换为日期的毫秒数 * @param i * @return */public static Long stringToDateMillis(String i)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm&quot;);//24小时制 long timeMillis = 0; try &#123; timeMillis = simpleDateFormat.parse(i).getTime(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return timeMillis;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BLE 开发知识]]></title>
    <url>%2F2018%2F07%2F05%2FBLE%20%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[开发流程声明 BLE 权限在 AndroidManifest 中添加： 12345&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;&lt;!-- 6.0 之后需要位置权限--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; 获取 BluetoothAdapter 实例12345678910111213141516171819202122/** * 初始化本地蓝牙 * * @return */private boolean initBLE() &#123; if (mBluetoothManager == null) &#123; mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); if (mBluetoothManager == null) &#123; LogUtil.e(TAG, &quot;Unable to initialize BluetoothManager.&quot;); return false; &#125; &#125; mBluetoothAdapter = mBluetoothManager.getAdapter(); if (mBluetoothAdapter == null) &#123; LogUtil.e(TAG, &quot;Unable to obtain a BluetoothAdapter.&quot;); return false; &#125; return true;&#125; 动态申请定位权限Android 6.0 系统以上开启蓝牙还需要定位权限，定位权限属于危险权限，需要动态申请： 12345678910private void initPermission() &#123; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; …………………… //请求权限 requestPermissions(new String[]&#123;Manifest.permission.WRITE_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION); &#125;&#125; 如果是在 Fragment 中使用，则是 xxxFragment.this.requestPermissions requestPermissions 的回调方法是 123456789@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION: Toast.makeText(getActivity(), &quot;已经可以定位了&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; 请求位置服务判断是否开启定位功能1234567891011121314/** * 开启定位功能 * @param context * @return */private static boolean isLocationEnable(Context context) &#123; LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE); boolean networkProvider = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER); boolean gpsProvider = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER); if (networkProvider || gpsProvider) &#123; return true; &#125; return false;&#125; 开启定位服务123456789/** * 获取定位服务 * * @param context */private static void setLocationService(Context context) &#123; Intent locationIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS); ((Activity) context).startActivityForResult(locationIntent, Global.REQUEST_CODE_LOCATION_SETTINGS);&#125; 扫描设备在 android 6.0 中，使用 BluetoothLeScanner.startScan() 来扫描的： 123456789101112131415161718192021222324252627282930313233343536/** * 扫描 BLE 设备 * @param enable */public void scanDevices(boolean enable) &#123; LogUtil.i(TAG, &quot;BluetoothAdapter 状态：&quot; + mBluetoothAdapter.getState()); if (enable) &#123; /*new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; mBluetoothAdapter.getBluetoothLeScanner().stopScan(mScanCallback); &#125; &#125;, 3000);*/ LogUtil.i(TAG, &quot;正在搜索设备…………&quot;); mBluetoothAdapter.getBluetoothLeScanner().startScan(mScanCallback); &#125; else &#123; LogUtil.i(TAG, &quot;停止搜索设备&quot;); mBluetoothAdapter.getBluetoothLeScanner().stopScan(mScanCallback); &#125;&#125;private ScanCallback mScanCallback = new ScanCallback() &#123; @Override public void onScanResult(int callbackType, ScanResult result) &#123; super.onScanResult(callbackType, result); Bundle data = new Bundle(); data.putParcelable(BluetoothDevice.EXTRA_DEVICE, result.getDevice()); Intent intent = new Intent(); intent.setAction(ACTION_DEVICE_FOUND); intent.putExtras(data); sendBroadcast(intent); &#125;&#125;; 注册广播123456789101112131415/** * 初始化广播 */private void initBroadcastReceiver() &#123; IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); intentFilter.addAction(BluetoothService.ACTION_DEVICE_FOUND); intentFilter.addAction(BluetoothService.ACTION_GATT_SERVICES_DISCOVERED_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_DESCRIPTOR_WRITE_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_CHARACTERISTIC_WRITE_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_CHARACTERISTIC_DATA_REPLY); registerReceiver(broadcastReceiver, intentFilter);&#125; 123456789101112/** * 广播接收器 */private BroadcastReceiver broadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) &#123; ………… &#125; &#125; 连接设备需要获取 BluetoothGATT 再进行操作： 1234567891011121314151617181920212223242526/** * 连接目标 BLE 设备 * * @param address * @return */public boolean connect(final String address) &#123; if (mBluetoothAdapter == null || address == null) &#123; LogUtil.e(TAG, &quot;BluetoothAdapter not initialized or unspecified address.&quot;); return false; &#125; final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address); if (device == null) &#123; LogUtil.e(TAG, &quot;Device not found. Unable to connect.&quot;); return false; &#125; // We want to directly connect to the device, so we are setting the autoConnect // parameter to false. mBluetoothGatt = device.connectGatt(this, false, mGattCallback); LogUtil.i(TAG, &quot;成功连接上设备：&quot; + device.getName()); LogUtil.i(TAG, &quot;------------Create a new connection.------------&quot;); return true;&#125; 当 GATT 客户端连接上或者连接状态改变时，调用 onConnectionStateChange。 如果使用：device.connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport) 根据源码 @param transport preferred transport for GATT connections to remote dual-mode devices跟双模设备连接，transport 如果不传默认 TRANSPORT_AUTO，6.0系统及以上需要使用 TRANSPORT_LE 这种传输模式。 发现服务当使用 mBluetoothGatt.discoverServices() 时，则调用 onServicesDiscovered。 获取 BluetoothGattService 和 BluetoothGattCharacteristic12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 获取 BluetoothGattService * * @param bluetoothGatt * @param uuid_service * @return */ private BluetoothGattService getBluetoothGATTService(BluetoothGatt bluetoothGatt, UUID uuid_service) &#123; if (mBluetoothGatt != null) &#123; BluetoothGattService bluetoothGattService = mBluetoothGatt.getService(uuid_service); if (bluetoothGattService != null) &#123; //LogUtil.i(TAG, &quot;成功获取 bluetoothGattService：&quot; + uuid_service); return bluetoothGattService; &#125; else &#123; LogUtil.e(TAG, &quot;bluetoothgatt get service uuid:&quot; + uuid_service + &quot; is null&quot;); &#125; &#125; else &#123; LogUtil.e(TAG, &quot;mBluetoothGatt is null&quot;); &#125; return null; &#125; /** * 获取 BluetoothGattCharacteristic * * @param bluetoothGattService * @param uuid_characteristic * @return */ private BluetoothGattCharacteristic getBluetoothGattCharacteristic(BluetoothGattService bluetoothGattService, UUID uuid_characteristic) &#123; if (bluetoothGattService != null) &#123; BluetoothGattCharacteristic bluetoothGattCharacteristic = bluetoothGattService.getCharacteristic(uuid_characteristic); if (bluetoothGattCharacteristic != null) &#123; //LogUtil.i(TAG, &quot;成功获取 bluetoothGattCharacteristic：&quot; + uuid_characteristic); return bluetoothGattCharacteristic; &#125; else &#123; LogUtil.e(TAG, &quot;bluetoothGattService get characteristic uuid:&quot; + uuid_characteristic + &quot; is null&quot;); &#125; &#125; else &#123; LogUtil.e(TAG, &quot;bluetoothGattService is null&quot;); &#125; return null; &#125; 开启通知，并且写入 DescriptorWriteCharacteristic() 后有数据返回，则需要先： 12345678910111213141516171819202122232425/** * 设置 Characteristic 通知属性，并且写上 Descriptor */ private void setCharacteristicNotifyAndWriteDescriptor(UUID uuid_service, UUID uuid_characteristic, UUID uuid_descriptor) &#123; BluetoothGattService mBluetoothGattService = getBluetoothGATTService(mBluetoothGatt, uuid_service); BluetoothGattCharacteristic mBluetoothGattCharacteristic = getBluetoothGattCharacteristic(mBluetoothGattService, uuid_characteristic); if (mBluetoothGatt != null &amp;&amp; mBluetoothGattCharacteristic != null) &#123; mBluetoothGatt.setCharacteristicNotification(mBluetoothGattCharacteristic, true); BluetoothGattDescriptor mBluetoothGattDescriptor = mBluetoothGattCharacteristic.getDescriptor(uuid_descriptor); if (mBluetoothGattDescriptor != null) &#123; LogUtil.i(TAG, &quot;成功设置 mBluetoothGattDescriptor&quot;); mBluetoothGattDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); mBluetoothGatt.writeDescriptor(mBluetoothGattDescriptor); &#125; &#125; else if (mBluetoothGatt == null) &#123; LogUtil.e(TAG, &quot;mBluetoothGatt is null&quot;); &#125; else if (mBluetoothGattCharacteristic == null) &#123; LogUtil.e(TAG, &quot;mBluetoothGattCharacteristic is null&quot;); &#125; &#125; 然后会回调 onDescriptorWrite 写入 Characteristic12345678910111213141516171819202122/** * 写入 Characteristic * @param uuid_service * @param uuid_characteristic * @param value */private void writeCharacteristic(UUID uuid_service, UUID uuid_characteristic, byte[] value) &#123; BluetoothGattService mBluetoothGattService = getBluetoothGATTService(mBluetoothGatt, uuid_service); BluetoothGattCharacteristic mBluetoothGattCharacteristic = getBluetoothGattCharacteristic(mBluetoothGattService, uuid_characteristic); if (mBluetoothGatt != null &amp;&amp; mBluetoothGattCharacteristic != null) &#123; mBluetoothGattCharacteristic.setValue(value); mBluetoothGattCharacteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE); mBluetoothGatt.writeCharacteristic(mBluetoothGattCharacteristic); &#125;else if (mBluetoothGatt == null) &#123; LogUtil.e(TAG, &quot;mBluetoothGatt is null&quot;); &#125; else if (mBluetoothGattCharacteristic == null) &#123; LogUtil.e(TAG, &quot;mBluetoothGattCharacteristic is null&quot;); &#125;&#125; 则先回调 onCharacteristicWrite，然后回调 onCharacteristicChanged。 BluetoothGatt 的回调1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * BluetoothGatt 的回调 */private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; super.onConnectionStateChange(gatt, status, newState); if (newState == BluetoothProfile.STATE_CONNECTED) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; LogUtil.i(TAG, &quot;Connected To GATT Server&quot;); LogUtil.i(TAG, &quot;Attempting To Start Service Discovery:&quot; + mBluetoothGatt.discoverServices()); broadcastUpdate(ACTION_GATT_CONNECTED); &#125; else &#123; disconnect(); close(); &#125; &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123; close(); &#125; &#125; @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; super.onServicesDiscovered(gatt, status); LogUtil.i(TAG, &quot;onServicesDiscovered received: &quot; + status); if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED_SUCCESS); &#125; else &#123; LogUtil.i(TAG, &quot;onServicesDiscovered received: &quot; + status); &#125; &#125; @Override public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorWrite(gatt, descriptor, status); if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_DESCRIPTOR_WRITE_SUCCESS); &#125; &#125; @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicWrite(gatt, characteristic, status); if (status == BluetoothGatt.GATT_SUCCESS)&#123; broadcastUpdate(ACTION_GATT_CHARACTERISTIC_WRITE_SUCCESS); //LogUtil.i(TAG, &quot;onCharacteristicWrite 返回的数据&quot; + Arrays.toString(characteristic.getValue())); &#125; &#125; @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicChanged(gatt, characteristic); LogUtil.i(TAG, &quot;onCharacteristicChanged 返回的数据&quot; + Arrays.toString(characteristic.getValue())); broadcastUpdate(ACTION_GATT_CHARACTERISTIC_DATA_REPLY, KEY_HOUR_DATA, characteristic.getValue()); &#125; @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicRead(gatt, characteristic, status); &#125; @Override public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorRead(gatt, descriptor, status); &#125;&#125;; 发送广播12345678910111213141516/** * 发送广播 * * @param action */private void broadcastUpdate(final String action) &#123; final Intent intent = new Intent(action); sendBroadcast(intent);&#125;private void broadcastUpdate(final String action, String key, byte[] value)&#123; final Intent intent = new Intent(action); intent.putExtra(key, value); sendBroadcast(intent);&#125; 参考资料 Android蓝牙4.0 BLE开发坑总结 Android BLE 多次writeCharacteristic 为什么只有一个回调]]></content>
      <categories>
        <category>Android</category>
        <category>BLE</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BLE 4.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BLE 手环开发总结]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%89%8B%E7%8E%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基础功能 显示步数、距离、卡路里、电量、目标完成状况 功能实现过程 通过手机蓝牙与手环连接，手机 APP 发送个人设置数据给手环；当手环接收数据成功后，更新用户信息，同时返回当前时刻到上一次同步数据时刻的数据（注：数据以1小时为单位，返回的每个1小时数据是每个1小时的累计数据)，这次返回的数据中含有掉电标志字节，用于判断本次数据同步是正常还是掉电后重新上电后的第一次同步。 手机 APP 发送请求同步手环屏幕当前显示数据的数据给手环；手环接收数据成功后，返回步数、距离、卡路里、电量的数据。 手机 APP 发送请求同步手环72个小时数据的数据给手环；手环接收数据成功后，返回步数、卡路里、每个小时的 UTC 秒数的数据。 开发辅助数据库框架greenDAO 简书上面的参考资料： Android Study 之 玩转GreenDao 3.2.2 点滴提升逼格~ 数据库调试Android-Debug-Database 智能刷新框架SmartRefreshLayout 图表显示框架MPAndroidChart CSDN 上面的两篇参考资料： Android图表控件MPAndroidChart的简单介绍（MPAndroidChart3.0 MPAndroidChart 教程 Fragment 切换指示器SpringIndicator 自定义选择器框架AndroidPicker 遇到的问题 BLE 以6.0版本为界限的开发流程、GATT 规范 Java 获取当前时间以及各种转换 ViewPager + Fragment 使用 Activity 和 Fragment 跳转、数据交互 BottomNavigationView 使用 Broadcast 使用 Service 使用 Intent 使用 异步使用 enum 自定义 View 参考：仿支付宝芝麻信用的仪表盘安卓自定义View教程 Fragment 的 add、hide、show。简书收藏几篇文章 由于手环储存的步数数据仅为1个小时的累计，所以当用图表显示月、年的时候，需要对数据进行处理 实时监控手机的网络、蓝牙状态变化 蓝牙、定位、位置服务权限申请 byte[] 数组对应天数开关处理 Fragment 的接口回调 自定义一个 NoScrollViewPagerAdapter 自定义一个 LogUtil RecyclerView 使用 Bundle 使用 改进 引入 ButterKnife 使用异步加载图表数据，现在加载月、年数据比较慢 同步时间过长之后，再次同步一次会出现数据错乱情况 引入网络数据 引入 Google 的 easypermissions 作为权限获取库]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BLE 4.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ICON 资源网站]]></title>
    <url>%2F2018%2F07%2F05%2FICON%20%E8%B5%84%E6%BA%90%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Android Asset Studio Material Palette easyicon]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ICON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPAndroidChart 翻译]]></title>
    <url>%2F2018%2F07%2F02%2FMPAndroidChart%20%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[MPAndroidChart 开始本章介绍使用此库的基本设置。 添加依赖作为第一步，将该库的依赖项添加到您的项目中。 如何添加依赖已经在此存储库的用法部分中进行了介绍。 推荐使用 Gradle 方式作为添加依赖的方式。 创建界面使用 LineChart, BarChart, ScatterChart, CandleStickChart, PieChart, BubbleChart or RadarChart ，在 .xml 中定义：1234&lt;com.github.mikephil.charting.charts.LineChart android:id=&quot;@+id/chart&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 然后从 Activity, Fragment or whatever 中取回：12// in this example, a LineChart is initialized from xmlLineChart chart = (LineChart) findViewById(R.id.chart); 或者使用代码来创建（跟着在 layout 添加）123456// programmatically create a LineChartLineChart chart = new LineChart(Context);// get a layout defined in xmlRelativeLayout rl = (RelativeLayout) findViewById(R.id.relativeLayout);rl.add(chart); // add the programmatically created chart 添加数据在获得图表实例后，你可以创建数据并且添加到图表。这个例子使用的是 LineChart，Entry 类代表图表中一个点的 X，Y 坐标。其他图表类型，例如 BarChart 使用 BarEntry。添加数据到图表，将每一个数据代入到 Entry 中，例如：123456789YourData[] dataObjects = ...;List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;();for (YourData data : dataObjects) &#123; // turn your data into Entry objects entries.add(new Entry(data.getValueX(), data.getValueY()));&#125; 下一步，将 List 添加到 LineDataSet。DataSet 对象保存数据，同时允许单独设置数据的样式。如果启用，下面使用的“标签”仅具有描述性目的，并显示在图表中。123LineDataSet dataSet = new LineDataSet(entries, &quot;Label&quot;); // add entries to datasetdataSet.setColor(...);dataSet.setValueTextColor(...); // styling, ... 最后一步，添加 LineDataSet 对象到 LineData 对象。这个对象持有 chart 实例的所有数据，并允许有单独样式。在你建立数据对象后，你可以使用它建立图表并刷新：123LineData lineData = new LineData(dataSet);chart.setData(lineData);chart.invalidate(); // refresh 请考虑到上面的仅仅是基本应用。需要更详细的扩展应用，请参考 setting data 部分，其中有很多添加数据到不同 chart 类型图表的例子。 样式有关图表外观和数据的设置和样式的信息，请参考 general settings &amp; styling 部分。关于单个图表类型的更具体的样式和设置，请参考 specific settings &amp; styling。 与图表交互该库允许您完全自定义与图表视图的可能触摸（和手势）交互，并通过回调方法对交互作出反应。 启用/禁用交互 setTouchEnabled(boolean enabled) 允许启用/禁用与图表的所有可能的触摸交互。 setDragEnabled(boolean enabled) 启用/禁用图表的拖动（平移）。 setScaleEnabled(boolean enabled) 启用/禁用两个轴上的图表缩放。 setScaleXEnabled(boolean enabled) 启用/禁用 X 轴缩放。 setScaleYEnabled(boolean enabled) 启用/禁用 Y 轴缩放。 setPinchZoom(boolean enabled) 如果设置为 true，则启用缩放。如果禁用，则可以单独缩放 X 轴和 Y 轴。 setDoubleTapToZoomEnabled(boolean enabled) 将此设置为 false 以禁止通过双击来缩放图表。 图表抛物线/减速 setDragDecelerationEnabled(boolean enabled) 如果设置为 true，则图表会在触摸后继续滚动。 默认值：true。 setDragDecelerationFrictionCoef(float coef) 减速摩擦系数在 [0; 1] 之间，较高的值表示速度将缓慢下降，例如，如果设置为 0，它将立即停止。 1 是无效值，将自动转换为 0.9999。 突出显示值如何允许通过点击手势和编程方式，突出显示条目在 highlightning section 中进行了描述。 手势回调OnChartGestureListener 将允许您对图表上的手势做出反应： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface OnChartGestureListener &#123; /** * Callbacks when a touch-gesture has started on the chart (ACTION_DOWN) * * @param me * @param lastPerformedGesture */ void onChartGestureStart(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when a touch-gesture has ended on the chart (ACTION_UP, ACTION_CANCEL) * * @param me * @param lastPerformedGesture */ void onChartGestureEnd(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when the chart is longpressed. * * @param me */ public void onChartLongPressed(MotionEvent me); /** * Callbacks when the chart is double-tapped. * * @param me */ public void onChartDoubleTapped(MotionEvent me); /** * Callbacks when the chart is single-tapped. * * @param me */ public void onChartSingleTapped(MotionEvent me); /** * Callbacks then a fling gesture is made on the chart. * * @param me1 * @param me2 * @param velocityX * @param velocityY */ public void onChartFling(MotionEvent me1, MotionEvent me2, float velocityX, float velocityY); /** * Callbacks when the chart is scaled / zoomed via pinch zoom gesture. * * @param me * @param scaleX scalefactor on the x-axis * @param scaleY scalefactor on the y-axis */ public void onChartScale(MotionEvent me, float scaleX, float scaleY); /** * Callbacks when the chart is moved / translated via drag gesture. * * @param me * @param dX translation distance on the x-axis * @param dY translation distance on the y-axis */ public void onChartTranslate(MotionEvent me, float dX, float dY);&#125; 只需让你接收回调的类实现这个接口，并将其设置为图表的监听器：1chart.setOnChartGestureListener(this); 高亮显示值本节重点介绍通过 tap-gesture 和基于发行版 v3.0.0 以编程方式，高亮显示图表中条目的主题。 启用/禁用高亮显示 setHighlightPerDragEnabled(boolean enabled) 在图表上将此设置为 true，以便在完全缩小时，在图表表面上进行每次拖动时高亮显示。 默认值： true setHighlightPerTapEnabled(boolean enabled) 在图表上将此设置为 false，以防止通过点击手势高亮显示值。 但仍可通过拖动或以编程方式高亮显示值。 默认值： true setMaxHighlightDistance(float distanceDp) 在 dp 中设置最大的高光距离。在图表上轻敲远离条目的距离，不会触发高亮显示。 默认值： 500dp 除此之外，还可以为各个 DataSet 对象配置高亮显示：123456dataSet.setHighlightEnabled(true); // allow highlighting for DataSet // set this to false to disable the drawing of highlight indicator (lines) dataSet.setDrawHighlightIndicators(true); dataSet.setHighlightColor(Color.BLACK); // color for highlight indicator // and more... 以编程方式突出显示 highlightValue(float x, int dataSetIndex, boolean callListener) 高亮显示给定 DataSet 中给定 x位置的值。 提供 -1 作为 dataSetIndex 以撤消所有高亮显示。布尔标志确定是否应该调用选择侦听器。 highlightValue(Highlight high, boolean callListener) 高亮显示提供的 Highlight对象 所代表的值。提供 null 以撤消所有高亮显示。布尔标志确定是否应该调用选择侦听器。 highlightValues(Highlight[] highs) 高亮显示给定 Highlight [] 数组所表示的值。提供 null 或空数组以撤消所有高亮显示。 getHighlighted() 返回 Highlight [] 数组，其中包含有关所有高亮显示的条目，x-index 和 dataset-index 的信息。 选择回调该库在交互时为回调提供了许多侦听器。 其中一个是 OnChartValueSelectedListener，用于通过触控高亮显示值时的回调： 1234567891011121314 public interface OnChartValueSelectedListener &#123; /** * Called when a value has been selected inside the chart. * * @param e The selected Entry. * @param h The corresponding highlight object that contains information * about the highlighted position */ public void onValueSelected(Entry e, Highlight h); /** * Called when nothing has been selected or an &quot;un-select&quot; has been made. */ public void onNothingSelected();&#125; 只需让你的接收回调的类，实现这个接口并将其设置为图表的监听器：chart.setOnChartValueSelectedListener(this); 高亮的类Highlight类 表示与高亮显示的 Entry 关联的所有数据，例如高亮显示的 Entry对象 本身，它所属的 DataSet，它在绘图表面上的位置等等。它可用于获取有关已高亮显示的条目的信息，或用于向图表提供要高亮显示的条目的信息。关于这个目的，Highlight类 提供了两个构造函数：12345/** constructor for standard highlight */public Highlight(float x, int dataSetIndex) &#123; ... &#125;/** constructor for stacked BarEntry highlight */public Highlight(float x, int dataSetIndex, int stackIndex) &#123; ... &#125; 这些构造函数可用于创建 Highlight对象，该对象允许以编程方式执行突出显示：1234// highlight the entry and x-position 50 in the first (0) DataSetHighlight highlight = new Highlight(50f, 0);chart.highlightValue(highlight, false); // highlight this value, don&apos;t call listener 自定义高亮所有用户输入的高亮手势形式，都由默认的 ChartHighlighter类 在内部处理。使用以下方法，用自定义实现替换默认的 highligher： setHighlighter（ChartHighlighter highlighter） 为图表设置自定义 highligher对象，以处理在图表视图上执行的所有高亮触摸事件。您自定义的 highlighter对象 需要继承 ChartHighlighter类。]]></content>
      <categories>
        <category>Android</category>
        <category>Chart</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Chart</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON 数据解析]]></title>
    <url>%2F2018%2F06%2F26%2FJSON%20%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[JSONObject 及 JSONArray 取值String 转 JSONObject 或 JSONArrayJSONArray jsonArray = JSONArray.fromObject(str); JSONObject jsonObject = JSONObject.fromObject(str); JSONObject 中获取 JSONArray 或 StringJSONObject jsonObject = new JSONObject(resource); String str = jsonObject.getString(&quot;str&quot;); //获取 sequences的值 JSONArray sequencesArray = jsonObject.getJSONArray(&quot;sequences&quot;); JSONObject 中还有其它 get 方法。 JSONArray 中获取 JSONObject 或 StringJSONArray jsonArray = new JSONArray(resource); String str = jsonArray.getString(0); JSONObject jsonObject = jsonArray.getJSONObject(0); 解析 json 格式的数据时要看清楚，最外面为 { 的是 JSONObject ，为 [ 的是JSONArray。 实例JSONArray 中获取 JSONObject1234567891011121314151617181920212223242526272829303132public class Province extends DataSupport &#123; private int id; private String provinceName; private int provinceCode; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getProvinceName() &#123; return provinceName; &#125; public void setProvinceName(String provinceName) &#123; this.provinceName = provinceName; &#125; public int getProvinceCode() &#123; return provinceCode; &#125; public void setProvinceCode(int provinceCode) &#123; this.provinceCode = provinceCode; &#125;&#125; 1JSON 数组 [&#123;&quot;id&quot;:1, &quot;name&quot;:北京&#125;,&#123;&quot;id&quot;:2, &quot;name&quot;:上海&#125;,&#123;&quot;id&quot;:3, &quot;name&quot;:天津&#125;,&#123;&quot;id&quot;:4, &quot;name&quot;:重庆&#125;,&#123;&quot;id&quot;:5, &quot;name&quot;:香港&#125;] 123456789101112131415161718public static boolean handleProvinceResponse(String response) &#123; if (!TextUtils.isEmpty(response)) &#123; try &#123; JSONArray allProvinces = new JSONArray(response); for (int i = 0; i &lt; allProvinces.length(); i++) &#123; JSONObject provinceObject = allProvinces.getJSONObject(i); Province province = new Province(); province.setProvinceName(provinceObject.getString(&quot;name&quot;)); province.setProvinceCode(provinceObject.getInt(&quot;id&quot;)); province.save(); &#125; return true; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; JSONObject 中获取 JSONArray，然后在从 JSONArray 中获取 JSONObject12345678910111213141516public class Weather &#123; public String status; public Basic basic; public AQI aqi; public Now now; public Suggestion suggestion; @SerializedName(&quot;daily_forecast&quot;) public List&lt;Forecast&gt; forecastList;&#125; 1&#123;&quot;HeWeather&quot;: [&#123;&quot;basic&quot;:&#123;&quot;cid&quot;:&quot;CN101300105&quot;,&quot;location&quot;:&quot;隆安&quot;,&quot;parent_city&quot;:&quot;南宁&quot;,&quot;admin_area&quot;:&quot;广西&quot;,&quot;cnty&quot;:&quot;中国&quot;,&quot;lat&quot;:&quot;23.17476273&quot;,&quot;lon&quot;:&quot;107.68865967&quot;,&quot;tz&quot;:&quot;+8.00&quot;,&quot;city&quot;:&quot;隆安&quot;,&quot;id&quot;:&quot;CN101300105&quot;,&quot;update&quot;:&#123;&quot;loc&quot;:&quot;2018-05-02 11:47&quot;,&quot;utc&quot;:&quot;2018-05-02 03:47&quot;&#125;&#125;,&quot;update&quot;:&#123;&quot;loc&quot;:&quot;2018-05-02 11:47&quot;,&quot;utc&quot;:&quot;2018-05-02 03:47&quot;&#125;,&quot;status&quot;:&quot;ok&quot;,&quot;now&quot;:&#123;&quot;cloud&quot;:&quot;25&quot;,&quot;cond_code&quot;:&quot;300&quot;,&quot;cond_txt&quot;:&quot;阵雨&quot;,&quot;fl&quot;:&quot;32&quot;,&quot;hum&quot;:&quot;71&quot;,&quot;pcpn&quot;:&quot;0.0&quot;,&quot;pres&quot;:&quot;1014&quot;,&quot;tmp&quot;:&quot;29&quot;,&quot;vis&quot;:&quot;10&quot;,&quot;wind_deg&quot;:&quot;107&quot;,&quot;wind_dir&quot;:&quot;东南风&quot;,&quot;wind_sc&quot;:&quot;1&quot;,&quot;wind_spd&quot;:&quot;4&quot;,&quot;cond&quot;:&#123;&quot;code&quot;:&quot;300&quot;,&quot;txt&quot;:&quot;阵雨&quot;&#125;&#125;,&quot;daily_forecast&quot;:[&#123;&quot;date&quot;:&quot;2018-05-02&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;中雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;30&quot;,&quot;min&quot;:&quot;23&quot;&#125;&#125;,&#123;&quot;date&quot;:&quot;2018-05-03&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;阵雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;27&quot;,&quot;min&quot;:&quot;22&quot;&#125;&#125;,&#123;&quot;date&quot;:&quot;2018-05-04&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;阵雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;28&quot;,&quot;min&quot;:&quot;23&quot;&#125;&#125;],&quot;hourly&quot;:[&#123;&quot;cloud&quot;:&quot;90&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;26&quot;,&quot;hum&quot;:&quot;83&quot;,&quot;pop&quot;:&quot;58&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-02 13:00&quot;,&quot;tmp&quot;:&quot;30&quot;,&quot;wind_deg&quot;:&quot;188&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;11&quot;&#125;,&#123;&quot;cloud&quot;:&quot;95&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;24&quot;,&quot;hum&quot;:&quot;85&quot;,&quot;pop&quot;:&quot;49&quot;,&quot;pres&quot;:&quot;1010&quot;,&quot;time&quot;:&quot;2018-05-02 16:00&quot;,&quot;tmp&quot;:&quot;30&quot;,&quot;wind_deg&quot;:&quot;172&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;1&quot;&#125;,&#123;&quot;cloud&quot;:&quot;98&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;24&quot;,&quot;hum&quot;:&quot;87&quot;,&quot;pop&quot;:&quot;25&quot;,&quot;pres&quot;:&quot;1010&quot;,&quot;time&quot;:&quot;2018-05-02 19:00&quot;,&quot;tmp&quot;:&quot;29&quot;,&quot;wind_deg&quot;:&quot;173&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;8&quot;&#125;,&#123;&quot;cloud&quot;:&quot;99&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;23&quot;,&quot;hum&quot;:&quot;89&quot;,&quot;pop&quot;:&quot;20&quot;,&quot;pres&quot;:&quot;1013&quot;,&quot;time&quot;:&quot;2018-05-02 22:00&quot;,&quot;tmp&quot;:&quot;28&quot;,&quot;wind_deg&quot;:&quot;27&quot;,&quot;wind_dir&quot;:&quot;东北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;9&quot;&#125;,&#123;&quot;cloud&quot;:&quot;99&quot;,&quot;cond_code&quot;:&quot;104&quot;,&quot;cond_txt&quot;:&quot;阴&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;90&quot;,&quot;pop&quot;:&quot;71&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-03 01:00&quot;,&quot;tmp&quot;:&quot;25&quot;,&quot;wind_deg&quot;:&quot;5&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;6&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;306&quot;,&quot;cond_txt&quot;:&quot;中雨&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;93&quot;,&quot;pop&quot;:&quot;49&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-03 04:00&quot;,&quot;tmp&quot;:&quot;24&quot;,&quot;wind_deg&quot;:&quot;2&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;6&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;104&quot;,&quot;cond_txt&quot;:&quot;阴&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;93&quot;,&quot;pop&quot;:&quot;34&quot;,&quot;pres&quot;:&quot;1013&quot;,&quot;time&quot;:&quot;2018-05-03 07:00&quot;,&quot;tmp&quot;:&quot;23&quot;,&quot;wind_deg&quot;:&quot;11&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;10&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;86&quot;,&quot;pop&quot;:&quot;70&quot;,&quot;pres&quot;:&quot;1015&quot;,&quot;time&quot;:&quot;2018-05-03 10:00&quot;,&quot;tmp&quot;:&quot;23&quot;,&quot;wind_deg&quot;:&quot;3&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;2&quot;&#125;],&quot;aqi&quot;:&#123;&quot;city&quot;:&#123;&quot;aqi&quot;:&quot;51&quot;,&quot;pm25&quot;:&quot;29&quot;,&quot;qlty&quot;:&quot;良&quot;&#125;&#125;,&quot;suggestion&quot;:&#123;&quot;comf&quot;:&#123;&quot;type&quot;:&quot;comf&quot;,&quot;brf&quot;:&quot;较舒适&quot;,&quot;txt&quot;:&quot;白天有雨，从而使空气湿度加大，会使人们感觉有点儿闷热，但早晚的天气很凉爽、舒适。&quot;&#125;,&quot;sport&quot;:&#123;&quot;type&quot;:&quot;sport&quot;,&quot;brf&quot;:&quot;较不宜&quot;,&quot;txt&quot;:&quot;有较强降水，建议您选择在室内进行健身休闲运动。&quot;&#125;,&quot;cw&quot;:&#123;&quot;type&quot;:&quot;cw&quot;,&quot;brf&quot;:&quot;不宜&quot;,&quot;txt&quot;:&quot;不宜洗车，未来24小时内有雨，如果在此期间洗车，雨水和路上的泥水可能会再次弄脏您的爱车。&quot;&#125;&#125;&#125;]&#125; 12345678910111213141516/** * 将返回的 JSON 数据解析成 Weather 实体类 */public static Weather parseWeatherResponse(String response) &#123; try &#123; JSONObject jsonObject = new JSONObject(response); JSONArray jsonArray = jsonObject.getJSONArray(&quot;HeWeather&quot;); String weatherContent = jsonArray.getJSONObject(0).toString(); return new Gson().fromJson(weatherContent, Weather.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
</search>
