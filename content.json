{"meta":{"title":"你好，我叫weking","subtitle":null,"description":"能讲究，能将就","author":"wekingtan","url":"http://yoursite.com"},"pages":[{"title":"所有分类","date":"2018-07-08T08:43:35.000Z","updated":"2018-07-08T08:50:40.098Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2018-07-08T13:46:02.000Z","updated":"2018-07-08T15:01:32.752Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"有梦想有追求"},{"title":"所有标签","date":"2018-07-08T08:46:42.000Z","updated":"2018-07-08T08:49:53.665Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2018-07-08T14:57:28.000Z","updated":"2018-07-15T15:18:17.783Z","comments":false,"path":"friendlink/index.html","permalink":"http://yoursite.com/friendlink/index.html","excerpt":"","text":"@card{ Love2.io: https://love2.io/Android Weekly: https://androidweekly.net/Android 开发技术周报: https://androidweekly.io/国外著名优秀开发者博客: http://t.cn/RPni7a0美团点评技术团队: http://tech.meituan.com/腾讯前端 AlloyTeam 团队 Blog: http://www.alloyteam.com/自学 Android 编程系列: http://stormzhang.com/android/2016/06/10/learn-android-byself/ wanandroid: http://wanandroid.com/index 吴小龙同學: http://wuxiaolong.me/ 人人都是产品经理: http://www.woshipm.com/ 掘金酱: http://e.xitu.io/ android.google.cn: https://developer.android.google.cn/ Kotlin 中文文档: https://lyndonchin.gitbooks.io/kotlin-docs-zh/content/ Flutter中文网: https://flutterchina.club/ 廖雪峰的官方网站: https://www.liaoxuefeng.com/ OPENINSTALL: https://www.openinstall.io/index.html 极客学院: http://www.jikexueyuan.com/ TED: https://www.ted.com/ stackoverflow: https://stackoverflow.com/ 简书: https://www.jianshu.com/ Android Arsenal: https://android-arsenal.com/ UI巴巴: http://www.uibaba.com/ Material Design中文版: http://design.1sters.com/material_design/style/color.html# }"}],"posts":[{"title":"Java 基础","slug":"Java 基础","date":"2018-07-14T17:01:16.000Z","updated":"2018-07-17T15:53:43.550Z","comments":true,"path":"2018/07/15/Java 基础/","link":"","permalink":"http://yoursite.com/2018/07/15/Java 基础/","excerpt":"Java 主类结构Java 程序的基本组成单元是类，类体中包括属性和方法。每个程序都必须包含一个 main() 方法，含有 main() 方法的类称为主类。","text":"Java 主类结构Java 程序的基本组成单元是类，类体中包括属性和方法。每个程序都必须包含一个 main() 方法，含有 main() 方法的类称为主类。 包声明语句 package xxx 为声明该类所在的包。 声明成员变量和局部变量全局变量（成员变量）：类的属性； 局部变量：方法中的属性； 编写主方法public static void main(String[] args) {……} 方法是主类中的主方法。public 是权限修饰符、static 是静态修饰符、void 是返回值修饰符、String[] args 是一个字符串类型的数组。 基本数据类型分为数值型（整数类型、浮点类型）、字符型、布尔型。 整数类型整型数据在 Java 中有十进制、八进制、十六进制。其中八进制以0开头，十六进制以0X或0x开头。 整型数据根据所占内存大小不同（内存空间 8 位等于 1 字节），分为 byte（8位）、short（16位）、int（32位）、long（64位）。 变量取值范围超出就会报错。 对于 long 型值，若赋给的值大于 int 型的最大最小值，则需要在数字后面加 L 或 l。 浮点类型浮点类型表示有小数部分的数字。分为单精度浮点类型和双精度浮点类型。 浮点数据根据所占内存大小不同（内存空间 8 位等于 1 字节），分为 float（32位）、double（64位）。 默认情况下，小数被看做是 double 型。 float 型小数，数字后面需要加 F 或 f。 字符类型char 型字符类型用于存储单个字符，占用内存空间 16 位（两个字节）。 在定义字符类型变量时，以单引号表示一个字符，双引号表示一个字符串。 转义字符以反斜杠 \\ 开头，后跟一个或多个字符。 布尔型通过关键字 boolean 来定义布尔类型变量，只有 true 和 false。 变量和常量标识符和关键字标识符由任意顺序的字母、下划线、美元符号、数字组成，并且第一个字符不能是数字，不能是关键字。 关键字是赋予特定意义的单词。 声明变量声明变量时可以没有赋值，也可以直接赋给初值。 声明常量标准语法： final 数据类型 常量名称[=值] 常量名通常使用大写字母表示。 当定义的 final 变量属于成员变量时，必须在定义时就设定它的初值，否则会编译错误。 变量的有效范围由于变量被定义出来后只是暂存在内存中，等到程序执行到某一个点，改变量会被释放掉。 根据变量的“有效范围”将变量分为 “成员变量” 和“局部变量”。 成员变量（全局变量）类体中定义的变量称为成员变量，在整个类中都有效。分为静态变量和实例变量。 成员变量的类型前面加上关键字 static，则是静态变量。它的有效范围可以跨类，甚至可以达到整个应用程序之内。对于静态变量，除了在定义它的类内存取，还可以“类名.静态变量”方式在其他类内使用。 局部变量局部变量是在类的方法体中定义的。只在当前代码块中有效。 运算符自增和自减运算符是单目运算符。++a（-a） 表示在使用变量 a 之前，先使 a 的值加（减）1a--（a-） 表示在使用变量 a 之后，使 a 的值加（减）1 位运算符按位与 &amp; 按位或 | 按位取反 ~ 按位异或 ^ 移位操作 &lt;&lt; 左移 &gt;&gt; 右移 &gt;&gt;&gt; 无符号右移 三元运算符使用格式： 条件式？值1：值2等价于 if…else 数据类型转换低精度数据类型向高精度数据类型转换，则永远不会溢出，永远成功；高精度数据类型向低精度数据类型转换，则有可能失败。 隐式类型转换低精度类型向高精度类型转换，系统自动执行。 精度从低到高： byte &lt; short &lt; char &lt; int &lt; long &lt; float &lt; double 显示类型转换高精度的变量的值赋给低精度的变量或取值范围超出变量时，必须使用显示类型转换（又称为强制类型转换）。 循环语句while 循环语句先判断，再循环 do…while 循环语句先执行一次，再判断 for 循环语句for 语句for(表达式; 表达式2; 表达式3){ 语句序列} foreach 语句for(元素变量 x : 遍历对象 obj){ 引用了 x 的 java 语句.} 循环控制包括：控制循环变量的变化方式、控制循环的跳转。控制循环的跳转需要 break、continue 两个关键字。break 是中断循环，continue 是执行下一次循环。 break 语句break 可以跳出 switch 结构，也可以跳出当前循环体。若有循环嵌套，则 break 只会跳出包含它的最内层的循环结构，只跳出一层循环。 如果想让 break 跳出外层循环，则使用标签功能： 标签 : 循环体{ break 标签名 } continue 语句不是立即跳出循环体，而是跳过本次循环结束前的语句，回到循环的条件测试部分，重新开始执行循环。 对于 for 循环，首先执行循环的增量部分，再执行条件测试部分。对于 while 和 do…while 循环，则直接回到条件测试部分。 continue 同样支持标签功能。 字符串获取字符串信息字符串查找str.indexOf(substr) 用于返回参数字符串 substr 在指定字符串中首次出现的索引位置。如果没有检索到字符串 substr，则返回值是 -1。 在计算机中 String 对象使用数组表示的。字符串的下标是 0~length()-1 str.lastIndexOf(String str) 用于返回指定字符串最后一次出现的索引位置。如果参数是空字符串（””），则返回的结果是字符串的长度。 获取指定索引位置的字符str.charAt(int index) 返回指定索引处的字符。 字符串操作获取子字符串str.substring(int beginIndex) 返回的是从指定的索引位置开始截取知道该字符串结尾的子串。 substring(int beginIndex, int endIndex) 返回的是字符串某一索引位置开始截取至某一索引位置结束的子串。 去除空格str.trim() 返回字符串的副本，忽略前导空格和尾部空格。 字符串替换str.replace(char oldChar, char newChar) 将指定的字符或字符串所有都替换成新的字符或字符串。 判断字符串的开始和结尾str.stratsWith(String prefix) 判断当前字符串对象的前缀是否为参数指定的字符串。 str.endsWith(String suffix) 判断当前字符串是否以给定的字符串结束。 判断字符串是否相等比较运算符 == 用于比较两个字符串的地址是否相同。即使两个字符串的内容相同，两个对象的内存地址是不相同的，返回 false。 str.equals(String otherstr) 如果两个字符串内容相等（区分大小写），则返回 true。 str.equalsIgnoreCase(String otherstr) 忽略大小写情况下，如果两个字符串内容相等，则返回 true。 按字典顺序比较两个字符串str.compareTo(String otherstr) 按字典顺序比较两个字符串，基于字符串中各个字符的 Unicode 值。如果 String 对象位于参数字符串之前，则返回一个负整数；如果位于之后，则返回一个正整数；如果两者相等，则结果为 0。 字母大小写转换str.toLowerCase 将原字符串中每个字符从大写字母等价转换为小写字母。 str.toUpperCase 将原字符串中每个字符从小写字母等价转换为大写字母。 字符串分割使用 split() 方法可以使字符串按指定的分割字符或字符串对内容进行分割，并将分割后的结果存放在字符串数组中。 str.split(String sign) 根据给定的分隔符对字符串进行拆分。sign 为分割字符串的分隔符，也可以使用正则表达式。 str.split(String sign, int limit) 根据给定的分隔符对字符串进行拆分，并限定拆分的次数。 没有统一的对字符进行分割的符号，如果想定义多个分割符，可以使用符号 |。例如，,|= 表示分割符为 ,和= 。 格式化字符串str.format(String format, Object…args) 使用指定的格式字符串和参数返回一个格式化字符串，格式化后的新字符串使用本地默认的语言环境。 str.format(Local l, String format, Object…args) l : 格式化过程中要应用的语言环境。如果 l 为 null，则不进行本地化 。 format : 格式字符串。 args : 格式字符串中由格式说明符引用的参数。如果还有格式说明符以外的参数，则忽略这些额外的参数。此参数的数目是可变的，可以为 0 。 日期和时间字符串格式化日期格式化12Date date = new Date(); //创建 Date 对象 dateString s = String.format(\"%te\", date); //通过 format() 方法对 date 进行格式化 时间格式化 格式化常见的日期时间组合 常规类型格式化 使用正则表达式正则表达式用于判断语句中，用来检查某一字符串是否满足某一格式。 字符串生成器使用 + 可以达到附加新字符或字符串的目的，但 + 会产生一个新的 String 实例，会在内存中创建新的字符串对象。 如果程序中频繁地附加字符串，建议使用 StringBuilder。 新创建的 StringBuilder 对象初始容量是 16 个字符，可以自行指定初始长度。如果附加的字符超过可容纳的长度，则 StringBuilder 对象将自动增加长度以容纳附加的字符。 StringBuilder 方法 append(content) 用于向字符串生成器中追加内容； insert(int offset, arg) 用于向字符串生成器中的指定位置插入数据内容； delete(int start, int end) 用于移除此序列的字符串中的字符；（左闭右开） 数组一维数组的创建及应用创建一维数组1、先声明，再用 new 运算符进行内存分配 声明一维数组： 数组元素类型 数组名字[] 数组元素类型[] 数组名字 为数组分配内存空间： 数组名字 = new 数组元素的类型[数组元素的个数] 假如创建的数组有 5 个元素，因此数组中元素的下标为 0~4 。 2、声明的同时为数组分配内存 数组元素的类型[] 数组名 = new 数组元素的类型[数组元素的个数] 初始化一维数组数组元素类型[] 数组名字 = new 数组元素类型[]{元素, 元素, …} 数组元素类型[] 数组名字 = {元素, 元素, …} 使用一维数组数组名字[0] = 元素1; 数组名字[1] = 元素2; …… 二维数组的创建及使用二维数组常用于表示表。第一个下标代表元素所在的行，第二个下标代表元素所在的列。 创建二维数组1、先声明，再用 new 运算符进行内存分配 声明二维数组： 数组元素类型 数组名字[][] 数组元素类型[][] 数组名字 为数组分配内存空间： 数组名字 = new 数组元素的类型[数组元素的个数 1][数组元素的个数 2] 12345数组名字 = new 数组元素的类型[数组元素的个数 1][]数组名字[0] = new 数组元素类型[数组元素的个数]数组名字[1] = new 数组元素类型[数组元素的个数]…………数组名字[数组元素的个数 1] = new 数组元素类型[数组元素的个数] 假如创建的数组有 5 个元素，因此数组中元素的下标为 0~4 。 2、声明的同时为数组分配内存 12345数组名字 = new 数组元素的类型[数组元素的个数 1][]数组名字[0] = new 数组元素类型[数组元素的个数]数组名字[1] = new 数组元素类型[数组元素的个数]…………数组名字[数组元素的个数 1] = new 数组元素类型[数组元素的个数] 初始化二维数组数组的基本操作遍历数组遍历二维数组一般使用双层 for 循环，通过数组的 length 属性可获得数组的长度。 填充替换数组元素数组中的元素定义完成后，可通过 Arrays 类的静态方法 fill() 对数组中的元素进行替换。 Arrays.fill(数组类型[] 数组名字, 数组类型 value) 将指定的 value 分配给数组的每个元素。 Arrays.fill(数组类型[] 数组名字, int fromIndex, int toIndex ,数组类型 value) fromIndex 用指定值填充的第一个元素的索引（包括） toIndex 使用指定值填充的最后一个元素的索引（不包括） 对数组进行排序Arrays.sort(object) Java 中的 String 类型数组的排序算法是根据字典编排顺序排序的，因此数字排在字母前面，大写字母排在小写字母前面。 复制数组Arrays.copyOf(数组名字, 数组类型 newlength) Arrays.copyOfRange(数组名字, int fromIndex, int toIndex) 数组查询Arrays 类的 binarySearch() 方法，可使用二分搜索法来搜索指定数组，以获得指定对象。 binarySearch(Object[] a, Object key) a 要搜索的数组 key 要搜索的值 必须在进行此调用之前对数组进行排序。 binarySearch(Object[] a, int fromIndex, int toIndex, Object key) 数组排序算法冒泡排序由小到大排序。依据对比相邻的元素值。 冒泡算法由双层循环实现，外层是比较的轮数 ；内层是每轮比较的次数。 12345678910111213141516171819202122232425262728293031323334353637public class BubbleSort&#123; private static void sort(int array[])&#123; int temp = 0; //记录最后一次交换的位置 int lastExchangeIndex = 0; //无序数列的边界，每次比较只需要比到这里为止 int sortBorder = array.length - 1; for(int i = 0; i &lt; array.length; i++)&#123; //有序标记，每一轮的初始是 true boolean isSorted = true; for(int j = 0; j &lt; sortBorder; j++)&#123; if(array[j] &gt; array[j+1])&#123; temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; //有元素交换，所以不是有序，标记变为 false isSorted = false; //把无序数列的边界更新为最后一次交换元素的位置 lastExchangeIndex = j; &#125; &#125; sortBorder = lastExchangeIndex; if(isSorted)&#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[]&#123;3,4,2,1,5,6,7,8&#125;; //int[] array = new int[]&#123;63,4,24,1,3,15&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 该方法为已经优化后的。 isSorted 避免在所有元素都在有序情况下，坚持走完所有轮数 lastExchangeIndex 记录最后一次元素交换的位置 sortBorder 避免在后面的元素是有序情况下，坚持去比较。之后的元素肯定是有序的，所以不用比较 直接选择排序1234567891011121314151617181920212223public class Gess &#123; private static void sort(int array[])&#123; int index; for (int i = 1; i &lt; array.length; i++) &#123; index = 0; for (int j = 1; j &lt;= array.length-i; j++) &#123; if(array[j] &gt; array[index]) &#123; index = j; &#125; &#125; int temp = array[array.length-i]; array[array.length-i] = array[index]; array[index]=temp; &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[]&#123;63,4,24,1,3,15&#125;; sort(array); System.out.println(Arrays.toString(array)); &#125;&#125; 反转排序类和对象面向对象概述类就是封装对象属性和行为的载体，对象就是类抽象出来的一个实例。其中，对象的属性就是成员变量，行为就是方法。 封装是面向对象编程的核心思想。将对象的属性和行为封装起来，其载体就是类，类通常对客户隐藏其实现细节。保证内部数据结构的完整性，避免外部操作对内部数据的影响。 继承是避免重复去定义属性和行为。 多态就是将父类对象应用于子类的特征。依赖于抽象类和接口。 在多态机制中，父类通常会被定义为抽象类，在抽象类中给出一个方法的标准，而不给出实现的具体流程。 在多态机制中，将抽象类定义为接口更方便。由抽象方法组成的集合就是接口。 类成员变量java 中对象的属性就是成员变量。 成员方法Java 中使用成员方法对应于类对象的行为。 1234权限修饰符 返回值类型 方法名(参数类型 参数名)&#123; …//方法体 return 返回值;&#125; 成员方法可以有参数，这个参数可以是对象，也可以是基本数据类型 成员方法可以有有返回值，也可以有不返回值（使用 void 关键字） 返回值可以是计算结果，也可以是其他数值和对象，但返回值类型要与方法返回的值类型一致 成员方法可以调用其他成员方法和类成员变量 成员方法内可以定义局部变量 权限修饰符对于类的成员变量、成员方法，被修饰为： private 则只能在本类中使用，在子类中是不可见的，并且对其他包的类也是不可见； public 则除了可以在本类中使用，还可以在子类和其他包的类中使用； protected 则只有本包内的该类的子类或其他类可以访问此类中的成员变量和成员方法； 如果在声明类的时候，不使用修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。 局部变量在成员方法中定义的变量。方法被执行时创建，方法执行结束时销毁。 局部变量在使用时必须进行赋值操作或初始化，否则会编译错误 this 关键字在 Java 中规定， 使用 this 关键字来代表本类对象的引用，this 关键字被隐式地用于引用对象的成员变量和方法； 还可以作为方法的返回值。 类的构造方法构造方法是一个与类同名的方法，每当类实例化一个对象时，类都会自动调用构造方法。 构造方法没有返回值； 构造方法的名称要与本类的名称相同； 123public 构造方法名（类名）&#123; …//构造方法体&#125; 在构造方法中可以为成员变量赋值，当实例化一个本类对象时，相应的成员变量也可以初始化。 如果类中没有明确定义构造方法，编译器会自动创建一个不带参数的默认构造方法。但如果类中已经存在带参数的构造方法时，编译器不会自动创建一个不带参数的构造方法。 static 静态变量、常量和方法由 static 声明的变量、常量和方法被称为静态成员。在本类或者其他类中使用类名.静态成员调用。 在静态方法中不可以使用 this 关键字； 在静态方法中不可以直接调用非静态方法； 类的主方法对象对象的创建使用 new 操作符调用构造方法来创建对象。 访问对象的属性和行为对象.类成员 对象的引用类名 对象引用名称 = new 类名() 引用只是存放一个对象的内存地址，并非存放一个对象。严格地说，引用和对象是不同的，但是这种区别可以忽略。 对象的比较 == 比较两个对象引用的地址是否相等； equals() 是 String 类方法，比较两个对象引用所指的内容是否相等； 对象的销毁包装类Integer （Long、Short）构造方法 Integer 变量名 = new Integer(int number) Integer 变量名 = new Integer(String str) 常用方法 toString() 可以将 Integer 对象转换为十进制字符串; toBinaryString() 可以将对象转换为二进制; toHexString() 可以将对象转换为十六进制; toOctalString() 可以将对象转换为八进制; 常量 Boolean构造方法 Boolean 变量名 = new Boolean(boolean value) Boolean 变量名 = new Boolean(String str) str 不为 null 且在忽略大小写时等于 true，则分配一个表示 true 值的 Boolean 对象，否则获得一个 false 值的 Boolean 对象。 常用方法 常量 Byte构造方法 Byte 变量名 = new Byte(byte value) Byte 变量名 = new Byte(String str) str 要使用数值型，否则会报错 常用方法 常量 CharacterDouble (Float)Number数字处理数字格式化Java 主要对浮点型数据进行数字格式化，其中浮点数包括 double 型和 float 型数据。 使用 java.text.DecimalFormat 格式化数字 数学运算Math 类Math 类中提供的众多数学函数方法，都被定义为 static 形式。 Math.数学方法 Math.PI 、Math.E 常用数学运算方法 Math 类三角函数方法 Math 类指数函数方法 Math 类取整函数方法 Math 类取最大值、最小值、绝对值函数方法 随机数Math.random() 方法默认生成大于等于 0.0 且小于 1.0 的 double 型随机数。 Random 类通过实例化 Random 对象创建一个随机数生成器。 大数字运算BigInteger支持任意精度整数。 BigDecimal支持任意精度的定点数，可以用来精确计算货币值。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Android 屏幕适配","slug":"屏幕适配","date":"2018-07-13T11:07:43.000Z","updated":"2018-07-13T11:08:24.538Z","comments":true,"path":"2018/07/13/屏幕适配/","link":"","permalink":"http://yoursite.com/2018/07/13/屏幕适配/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"屏幕适配","slug":"屏幕适配","permalink":"http://yoursite.com/tags/屏幕适配/"}]},{"title":"线程池","slug":"线程池","date":"2018-07-13T04:24:47.000Z","updated":"2018-07-13T11:16:46.001Z","comments":true,"path":"2018/07/13/线程池/","link":"","permalink":"http://yoursite.com/2018/07/13/线程池/","excerpt":"","text":"Android 中常见的4种线程池（保证你能看懂并理解","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"线程池","slug":"线程池","permalink":"http://yoursite.com/tags/线程池/"}]},{"title":"混合开发","slug":"混合开发","date":"2018-07-13T02:03:59.000Z","updated":"2018-07-13T02:05:52.688Z","comments":true,"path":"2018/07/13/混合开发/","link":"","permalink":"http://yoursite.com/2018/07/13/混合开发/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Hybrid","slug":"Hybrid","permalink":"http://yoursite.com/tags/Hybrid/"}]},{"title":"App 设计","slug":"App 设计","date":"2018-07-13T02:01:56.000Z","updated":"2018-07-13T11:30:26.154Z","comments":true,"path":"2018/07/13/App 设计/","link":"","permalink":"http://yoursite.com/2018/07/13/App 设计/","excerpt":"","text":"Android 中 vector 用法详解 Android UI：使用矢量图，抛弃PNG 码农如何从零开始做出有设计感的app？","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/设计/"},{"name":"Vector Assert","slug":"Vector-Assert","permalink":"http://yoursite.com/tags/Vector-Assert/"}]},{"title":"Dagger2","slug":"Dagger2","date":"2018-07-11T00:32:23.000Z","updated":"2018-07-12T01:32:34.857Z","comments":true,"path":"2018/07/11/Dagger2/","link":"","permalink":"http://yoursite.com/2018/07/11/Dagger2/","excerpt":"A fast dependency injector for Android and Java.","text":"A fast dependency injector for Android and Java. 添加依赖只要在 app module 的 build.gradle，添加： 123456dependencies &#123; ……………… //dagger2 implementation &apos;com.google.dagger:dagger:版本号&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:版本号&apos;&#125; 开始新建一个无参数的类123456public class Person &#123; public Person() &#123; System.out.println(\"a person created\"); &#125;&#125; 新建一个该类的提供者123456789@Modulepublic class MainModule &#123; @Provides Person providesPerson()&#123; System.out.println(\"a person created from MainModule\"); return new Person(); &#125;&#125; @Module 标注的对象，你可以把它想象成一个工厂，可以向外提供一些类的对象。那么到底提供什么对象呢？ @Provides 标注的方法就是提供对象的，这种方法一般会返回一个对象实例，例如上面返回一个 Person 对象。 新建一个 component 容器12345@Component(modules = &#123;MainModule.class&#125;)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125; 可以把它想成一个容器， module 中产出的东西都放在里面，然后将 component 与我要注入的 MainActivity 做关联，MainActivity 中需要的 person 就可以从 component 中去取出来。 @Component 表示这个接口是一个容器，并且与 MainModule.class 关联，它生产的东西都在这里。 void inject(MainActivity mainActivity); 表示我怎么和要注入的类关联。这个比较抽象！ 在 MainActivity 中将 component 关联进去123456789101112131415public class MainActivity extends AppCompatActivity &#123; @Inject Person person; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); MainComponent component = DaggerMainComponent.builder() .mainModule(new MainModule()).build(); component.inject(this); &#125;&#125; @Inject 在 Person 对象上添加一个 @Inject 注解，即可自动注入对象。这个时候系统看到有一个 @Inject 修饰的 Person，就知道在这个 MainComponent 中去找，并且是有 MainModule 的 Provides 修饰的方法提供的。 完成以上步骤，开始重建我们的项目DaggerMainComponent 就是你 build project 的时候，dagger 自己为你生成的具体的 component 类（我们自己定义的是 MainComponent 接口）。 其他注解和情况单例模式 @Singleton（基于Component）基于 Component 的单例模式， 就是在这个 Component 对象中，一个对象是单例对象。如果又新创建了一个Component，那么两个 Component 中的对象是不一样的。 我们再在 MainActivity 中添加一个12@InejctPerson person2 并打印两个 person 对象，发现 person 会被创建两次，并且两个 person 对象也不同。如果我们希望只有一个 person 和 person2，并且都指向同一个 Person 对象，就要使用 @Singleton 注解。 在 MainModule.java 的 provides 方法上需要添加 @Singleton 注解12345678910@Modulepublic class MainModule &#123; @Singleton @Provides Person providesPerson()&#123; System.out.println(\"a person created from MainModule\"); return new Person(); &#125;&#125; 在 MainComponent.java 类上添加 @Singleton 注解123456@Singleton@Component(modules = &#123;MainModule.class&#125;)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125; 再运行，发现 person 只创建了一次，并且两个 person 指向同一个对象。 需要注意的是：单例是基于 Component 的，所以不仅 Provides 的地方要加 @Singleton，Component 上也需要加。并且如果有另外一个 OtherActivity，并且创建了一个 MainComponent，也注入 Person，这个时候 MainActivity 和 OtherActivity 中的 Person 是不构成单例的，因为它们的 Component 是不同的。 带有参数的依赖对象如果构造 Person 类，需要一个参数 Context，我们怎么注入呢？ 要知道注入的时候我们只有一个 @Inject 注解，并不能带参数。所以我们需要再 MainModule 中提供 context，并且由 providesXXX 函数自己去构造。 新建一个带参数的类123456789public class Person &#123; private static final String TAG = \"Person\"; private Context context; public Person(Context context)&#123; Log.d(TAG, \"我是一个带参数的男人\" + context); &#125;&#125; 修改该类的提供者12345678910111213141516171819202122@Modulepublic class MainModule &#123; private static final String TAG = \"MainModule\"; private Context context; public MainModule(Context context)&#123; this.context = context; &#125; @Provides public Context providesContext()&#123; return this.context; &#125; @Singleton @Provides public Person providesPerson(Context context)&#123; Log.d(TAG, \"person from module \"); return new Person(context); &#125;&#125; providesPerson(Context context) 中的 context 不能直接使用成员变量 this.context，而是要在本类中提供一个1234@Providespublic Context providesContext()&#123; return this.context;&#125; 方法，这样在发现需要 context 的时候会调用 provideContext 来获取，这也是为了解耦。 依赖一个组件自定义标记 @Qualifier 和 ＠Named@Named(“…”)@Qualifier自定义标签懒加载Lazy和强制重新加载Provider@Scope 自定义生命周期参考google/daggerDagger2入门","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Dagger2","slug":"Dagger2","permalink":"http://yoursite.com/tags/Dagger2/"}]},{"title":"ButterKnife","slug":"ButterKnife","date":"2018-07-11T00:31:58.000Z","updated":"2018-07-12T01:30:29.905Z","comments":true,"path":"2018/07/11/ButterKnife/","link":"","permalink":"http://yoursite.com/2018/07/11/ButterKnife/","excerpt":"","text":"","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ButterKnife","slug":"ButterKnife","permalink":"http://yoursite.com/tags/ButterKnife/"}]},{"title":"旅游记账助手","slug":"旅游记账助手","date":"2018-07-11T00:31:58.000Z","updated":"2018-07-11T00:37:43.059Z","comments":true,"path":"2018/07/11/旅游记账助手/","link":"","permalink":"http://yoursite.com/2018/07/11/旅游记账助手/","excerpt":"","text":"功能记账（AA 制） 旅游攻略 景点导航 相机 紧急电话 注意事项分享提醒（护照、衣物、登机牌…………）","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"旅游","slug":"旅游","permalink":"http://yoursite.com/tags/旅游/"},{"name":"记账","slug":"记账","permalink":"http://yoursite.com/tags/记账/"}]},{"title":"异常捕获代码","slug":"异常捕获代码","date":"2018-07-06T05:48:15.000Z","updated":"2018-07-06T05:48:15.430Z","comments":true,"path":"2018/07/06/异常捕获代码/","link":"","permalink":"http://yoursite.com/2018/07/06/异常捕获代码/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Content Provider 内容提供器","slug":"ContentProvider 内容提供器","date":"2018-07-06T05:26:27.000Z","updated":"2018-07-08T01:53:52.728Z","comments":true,"path":"2018/07/06/ContentProvider 内容提供器/","link":"","permalink":"http://yoursite.com/2018/07/06/ContentProvider 内容提供器/","excerpt":"定义内容提供器主要用于在不同的应用程序之间实现数据共享功能，是 Android 实现跨程序共享数据的标准方式。","text":"定义内容提供器主要用于在不同的应用程序之间实现数据共享功能，是 Android 实现跨程序共享数据的标准方式。 运行时权限Android 的权限机制每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名，但是用户一旦同意授权了，那么该权限所对应的权限组中所有的其他权限也会同时被授权。 在程序运行时申请权限1、 首先判断用户是不是已经给我们授权了： 12345if(ContextCompat.checkSelfPermission(Context, Manifest.permission.权限) != PackageManager.PErMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(Context, new String[]&#123;Manifest.permission.权限&#125;, 常量);&#125;else&#123; //do something&#125; 2、 如果已经授权就执行逻辑操作；如果没有授权，则调用 ActivityCompat.requestPermissions() 方法，最终回调到 onRequestPermissionResult() 方法： 1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case 常量: if(grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PErMISSION_GRANTED)&#123; //do something &#125;else&#123; //do another thing &#125; break; default: &#125;&#125; 访问其他程序中的数据如果想要访问内容提供器中共享的数据，就一定要借助 ContentResolver 类，通过 Context 的 getContentResolver() 方法获得实例。 ContentResolver 的基本用法 insert() ：增加数据 update() ：更新数据 delete() ：删除数据 query() ：查询数据 ContentResolver 中的增删改查方法都不是接受表名参数，而是使用一个 Uri 参数代替，即内容 URI。 关于内容 URI内容 URI 由 authority 和 path 组成。其中： authority 是用于对不同的应用程序做区分的，采用程序包命名。例如：com.example.app.Provider。 path 是对同一程序不同的表做区分的，通常添加到 authority 后面。例如：com.example.app.Provider/table1，com.example.app.Provider/table2。 解析内容 URI 的方法：Uri uri = Uri.parse(&quot;com.example.app.Provider/table1&quot;); 增删改查方法演示查1234567Cursor cursor = getContentResolver().query( uri, projection, selection, selectionArgs, sortOrder ); query() 方法参数 对应 SQL 部分 描述 uri from table_name 指定查询某个应用程序下的某一张表 projection select column1，column2 指定查询的列名 selection where column = value 指定 where 的约束条件 selectionArgs - 为 where 中的占位符提供具体的值 orderBy order by column1,column2 指定查询结果的排序方式 查询完成后返回的仍然是一个 Cursor 对象，将数据从 Cursor 对象中读取： 1234567if(cursor != null)&#123; while(cursor.moveToNext())&#123; String column1 = cursor.getstring(cursor.getColumnIndex(\"column1\")); int column2 = cursor.getInt(cursor.getColumnIndex(\"column2\")); &#125; cursor.close();&#125; 增1234ContentValues values = new ContentValues();values.put(\"column1\", \"text\");values.put(\"column2\", 1);getContentResolver().insert(uri, values); 改123ContentValues values = new ContentValues();values.put(\"column1\", \"\");getContentResolver().update(uri, values, \"column1 = ? and column2 = ?\", new String[] &#123;\"text\", \"1\"&#125;); 删getContentResolver().delete(uri, &quot;column2 = ?&quot;, new String[] {&quot;1&quot;}) 创建自己的内容提供器","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"内容提供器","slug":"内容提供器","permalink":"http://yoursite.com/tags/内容提供器/"}]},{"title":"RecyclerView使用","slug":"RecyclerView使用","date":"2018-07-05T05:48:59.000Z","updated":"2018-07-05T05:48:59.578Z","comments":true,"path":"2018/07/05/RecyclerView使用/","link":"","permalink":"http://yoursite.com/2018/07/05/RecyclerView使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Fragment 使用","slug":"Fragment使用","date":"2018-07-05T05:48:36.000Z","updated":"2018-07-08T01:12:54.753Z","comments":true,"path":"2018/07/05/Fragment使用/","link":"","permalink":"http://yoursite.com/2018/07/05/Fragment使用/","excerpt":"Fragment 的 add、hide、show","text":"Fragment 的 add、hide、show 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class FragmentHelper &#123; /** * 添加 Fragment * @param fragmentManager * @param fragment * @param fragmentTag */ public static void addFragment(FragmentManager fragmentManager, Fragment fragment, String fragmentTag)&#123; if (fragmentManager != null)&#123; FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.add(R.id.frag_main, fragment, fragmentTag); transaction.commit(); &#125; &#125; /** * 显示已存在的 Fragment * @param fragmentManager * @param fragment */ public static void showFragment(FragmentManager fragmentManager, Fragment fragment)&#123; FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); if (fragment != null)&#123; fragmentTransaction.show(fragment); fragmentTransaction.commit(); &#125; &#125; /** * 隐藏所有的 Fragment * @param fragmentManager */ public static void hideAllFragment(FragmentManager fragmentManager)&#123; FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); Fragment dashboard_fragment = fragmentManager.findFragmentByTag(\"dashboard_fragment\"); if (dashboard_fragment != null)&#123; fragmentTransaction.hide(dashboard_fragment); &#125; fragmentTransaction.commit(); &#125;&#125; 参考资料 Fragment全解析系列 Fragment你真的熟悉吗？看了才知道 Android基础：Fragment，看这篇就够了","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Fragment","slug":"Fragment","permalink":"http://yoursite.com/tags/Fragment/"}]},{"title":"自定义 View","slug":"自定义View","date":"2018-07-05T05:48:16.000Z","updated":"2018-07-05T11:03:06.347Z","comments":true,"path":"2018/07/05/自定义View/","link":"","permalink":"http://yoursite.com/2018/07/05/自定义View/","excerpt":"","text":"参考资料 安卓自定义View教程 仿支付宝芝麻信用的仪表盘","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"自定义 View","slug":"自定义-View","permalink":"http://yoursite.com/tags/自定义-View/"}]},{"title":"Intent使用","slug":"Intent使用","date":"2018-07-05T05:47:59.000Z","updated":"2018-07-05T05:47:59.177Z","comments":true,"path":"2018/07/05/Intent使用/","link":"","permalink":"http://yoursite.com/2018/07/05/Intent使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Service 使用","slug":"Service 使用","date":"2018-07-05T05:47:42.000Z","updated":"2018-07-08T01:10:03.384Z","comments":true,"path":"2018/07/05/Service 使用/","link":"","permalink":"http://yoursite.com/2018/07/05/Service 使用/","excerpt":"定义 服务是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而还要求长期运行的任务。 服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。但服务不是运行在一个独立的进程中，而是依赖于创建服务时所在的应用程序。当应用程序进程被杀死，服务也会被停止运行。 服务并不会自动开启线程，默认运行在主线程中。","text":"定义 服务是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要和用户交互而还要求长期运行的任务。 服务的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。但服务不是运行在一个独立的进程中，而是依赖于创建服务时所在的应用程序。当应用程序进程被杀死，服务也会被停止运行。 服务并不会自动开启线程，默认运行在主线程中。 Android 多线程线程基本用法1.继承的方式耦合性有点高123456789class MyThread extends Thread&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125;new MyThread().start(); 2.实现 Runnable 接口的方式12345678910class MyThread implements Runnable&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125;MyThread myThread = new MyThread();new Thread(myThread).start(); 3.1234567new Thread(new Runnable()&#123; @Override public void run()&#123; //处理具体的逻辑 &#125;&#125;).start(); 在子线程中更新 UIAndroid 是不允许在子线程中更新 UI。但它提供了一套异步消息处理机制，可以解决在子线程中进行 UI 操作。 首先在主线程创建一个 Handler，并重写 handleMessage() 方法： 12345678910private Handler handler = new Handler()&#123; public void handleMessage(Message msg)&#123; switch (msg.what)&#123; case 常量 //在这里进行 UI 操作 break; &#125; &#125;&#125; 在需要更新 UI 的子线程中创建一个 Message 对象： 123Message message = new Message();message.what = 常量;handler.sendMessage(message); //将 Message 对象发送出去 解析异步消息处理机制Android 的异步消息处理机制由 4 部分组成：Message、Handler、MessageQueue、Looper。 MessageMessage 是在线程之间传递消息，可以在内部携带少量消息，用于在不同线程之间交换数据。what 字段携带 String 数据，arg1、arg2 字段携带整型数据，obj 字段携带一个 Object 对象。 Handler主要用于发送和处理消息。发送消息一般用 Handler 的 sendMessage() 方法。接收消息 Handler 的 handleMessage() 方法。 MessageQueueMessageQueue 是消息队列，主要用于存放所有通过 Handler 发送的消息。每个线程只会有一个 MessageQueue 对象。 LooperLooper 是每个线程中的 MessageQueue 管家，调用 Looper 的 loop() 方法后，就会进入一个无限循环，每当发现 MessageQueue 中存在的一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。每个线程只有一个 Looper 对象。 使用 AsyncTask由于 AsyncTask 是一个抽象类，所以我们需要创建一个子类去继承。 AsyncTask 类的 3 个泛型参数： Params ：在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。 Progress ：后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型为进度单位。 Result ：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。 AsyncTask 几个方法： onPreExecute() ：这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框。 doInBackground(Params…) :1、 所有代码都会在子线程中运行；2、 任务一旦完成就会返回 return 语句，但如果 AsyncTask 第三个泛型参数为 Void，则不返回任务执行结果；3、 这个方法中不可以执行 UI 操作，如果要执行 UI 操作，则可以调用 publishProgress(Progress…) 方法完成； onProgressUpdate(Progress…) ：当后台任务中调用 publishProgress(Progress…) 方法后，onProgressUpdate(Progress…) 方法就会调用。 onPostExcute(Result) ：当后台任务执行完毕并通过 return 语句执行返回时，这个方法就会调用。 AsyncTask 总结doInBackground(Params…) 执行具体的耗时任务；onProgressUpdate(Progress…) 进行更新 UI；onProgressUpdate(Progress…) 执行任务收尾； 启动这个任务：new targetTask().execute(); 服务的基本用法定义一个服务创建一个 Service 并在 AndroidManifest 中注册，其中 Exported 属性表示是否允许除了当前程序之外的其他程序访问这个服务，Enabled 属性表示是否启用这个服务。 活动和服务进行通信 创建一个子类继承 Service 123456789101112131415public class xxxService extends Service&#123; private final IBinder mBinder = new LocalBinder(); public class LocalBinder extends Binder &#123; public xxxService getService() &#123; return xxxService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 在 Activity/Fragment 中调用 Service： 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity&#123; private xxxService.LocalBinder localBinder; private xxxService mxxxService; /** * 绑定 xxxService 服务结果回调 */ private ServiceConnection serviceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; localBinder = (xxxService.LocalBinder) service; //通过向下转型得到 localBinder 实例 mxxxService = localBinder.getService(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent bindIntent = new Intent(this, xxxService.class); bindService(bindIntent, serviceConnection, Context.BIND_AUTO_CREATE); //绑定服务获取持久连接 &#125; @Override public void onDestroy() &#123; super.onDestroy(); unbindService(serviceConnection); &#125;&#125; 服务的更多技巧使用前台服务前台服务和普通服务最大区别是，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏可以看到更加详细的信息。类似于彩云天气的前台服务效果。 使用 IntentService一个异步的、会自动停止的服务。onHandleIntent(Intent intent) 方法运行在子线程中。 1234567891011121314151617181920public class xxxIntentService extends IntentService&#123; public xxxIntentService()&#123; super(\"xxxIntentService\"); //调用父类的有参构造函数 &#125; @Override protected void onHandleIntent(Intent intent) &#123; //当前的逻辑已经在子线程中运行 //打印当前线程的 id Log.d(\"xxxIntentService\", \"Thread id is\" + Thread.currentThread().getId()); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Service","slug":"Service","permalink":"http://yoursite.com/tags/Service/"},{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"}]},{"title":"Broadcast 使用","slug":"Broadcast 使用","date":"2018-07-05T05:47:25.000Z","updated":"2018-07-07T03:18:41.593Z","comments":true,"path":"2018/07/05/Broadcast 使用/","link":"","permalink":"http://yoursite.com/2018/07/05/Broadcast 使用/","excerpt":"广播机制 标准广播 完全异步执行，所有广播接收器同时接收 有序广播 同步执行，同一时刻只有一个广播接收器可以接收","text":"广播机制 标准广播 完全异步执行，所有广播接收器同时接收 有序广播 同步执行，同一时刻只有一个广播接收器可以接收 接收系统广播动态注册监听网络变化动态注册的广播接收器可以随意地控制注册和注销，但必须要在程序启动之后才能街道广播。 静态注册实现开机启动发送自定义广播发送标准广播发送有序广播使用 sendOrderBrocast() 发送广播，同时需要在 AndroidManifest 中设置优先级 &lt;intent-filter android:priority= &gt; 使用本地广播LocalBroadcastManger 来管理广播。LocalBroadcastManger localBroadcastmanger = LocalBroadcastManger.getInstance(this); 获取 LocalBroadcastManger 实例。localBroadcastmanger.sendBroadcast() 发送广播。localBroadcastmanger.registerReceiver() 注册广播。localBroadcastmanger.unregisterReceiver() 注销广播。 利用广播实现强制下线功能 首先定义一个活动回收器 ActivityCollector 类，创建一个列表来管理活动，ActivityCollector 类里面包含添加活动 addActivity、移除活动 removeActivity、结束活动 finishAll 的方法。 创建一个 BaseActivity 类作为所有活动的父类，同时复写 onCreate 添加 addActivity 方法；复写 onDestroy 添加 removeActivity 方法；复写 onResume 在里面注册广播；复写 onPause 在里面注销广播；在 ForceOfflineReceiver 的 onReceive 方法里面放入 finishAll 方法。 让需要实现强制下线功能的 Activity 继承 BaseActivity 类，同时发送强制下线功能的广播。 利用静态广播实现 APP 开机自动启动","categories":[],"tags":[]},{"title":"ViewPager使用","slug":"ViewPager使用","date":"2018-07-05T05:47:02.000Z","updated":"2018-07-05T05:47:02.958Z","comments":true,"path":"2018/07/05/ViewPager使用/","link":"","permalink":"http://yoursite.com/2018/07/05/ViewPager使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java 获取时间日期方法","slug":"Java 获取当前时间方法","date":"2018-07-05T05:46:33.000Z","updated":"2018-07-08T01:12:54.753Z","comments":true,"path":"2018/07/05/Java 获取当前时间方法/","link":"","permalink":"http://yoursite.com/2018/07/05/Java 获取当前时间方法/","excerpt":"单个获取年、月、日、时、分","text":"单个获取年、月、日、时、分 1234567891011121314151617181920212223242526272829303132333435363738394041public static int getYear() &#123; //获取系统的日期 Calendar calendar = Calendar.getInstance(); //年 int year = calendar.get(Calendar.YEAR); return year; &#125; public static int getMonth() &#123; Calendar calendar = Calendar.getInstance(); //月份需要加 1，因为是从 0 开始算的 int month = calendar.get(Calendar.MONTH) + 1; return month; &#125; public static int getDay() &#123; Calendar calendar = Calendar.getInstance(); int day = calendar.get(Calendar.DAY_OF_MONTH); return day; &#125; public static int getHour() &#123; Calendar calendar = Calendar.getInstance(); int hour = calendar.get(Calendar.HOUR_OF_DAY); return hour; &#125; public static int getMinute() &#123; Calendar calendar = Calendar.getInstance(); int minute = calendar.get(Calendar.MINUTE); return minute; &#125; 获取当前时间12345678910/** * 获取当前时间的年月日 * @return */ public static String simpleDate()&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日\"); Date date = new Date(System.currentTimeMillis()); return simpleDateFormat.format(date); &#125; 以当前时间为原点，往前或往后查询某一天123456789101112131415161718192021222324/** * 显示某一日的数据 * @param dateIndex * @return */ public static String getDisplayOffsetDate(int dateIndex)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日\"); if (dateIndex == 0)&#123; Date date = new Date(System.currentTimeMillis()); return simpleDateFormat.format(date); &#125;else &#123; Date beginDate = new Date();//获取当天 年月日+时间+时区 Calendar date = Calendar.getInstance();//获取当天更加详细时间 date.setTime(beginDate); date.set(Calendar.DATE, date.get(Calendar.DATE) + dateIndex); Date endDate = null; try &#123; endDate = simpleDateFormat.parse(simpleDateFormat.format(date.getTime())); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return simpleDateFormat.format(endDate); &#125; &#125; 如果查询某一年、某一月，则改变 Calendar.DATE 为 YEAR 或 MONTH。 查询某一个月有多少天1234567891011121314151617/** * 查询某一个月一共有多少天 * @param date * @return */public static int getDaysOfMonth(String date)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月\"); Date timeMillis = new Date(); try &#123; timeMillis = simpleDateFormat.parse(date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; Calendar calendar = Calendar.getInstance(); calendar.setTime(timeMillis); return calendar.getActualMaximum(Calendar.DAY_OF_MONTH);&#125; 设置 calendar 的时间为 2000-01-01-00-00，并获取 1970至2000-01-01-00-00时间的毫秒12345678910111213141516171819202122/** * 2000-01-01-00-00 * @return */public static Calendar get20000101Datetime() &#123; Calendar cal_ = Calendar.getInstance(); cal_.set(Calendar.YEAR, 2000); cal_.set(Calendar.MONTH, Calendar.JANUARY); cal_.set(Calendar.DATE, 1); cal_.set(Calendar.HOUR_OF_DAY, 0); cal_.set(Calendar.MINUTE, 0); cal_.set(Calendar.SECOND, 0); cal_.set(Calendar.MILLISECOND, 0); return cal_;&#125;//设置 calendar 的时间为 2000-01-01-00-00Calendar calendar = get20000101Datetime();//setTimeInMillis 为 （1970至2000-01-01-00-00时间的毫秒）calendar.getTimeInMillis(); 把 String 类型的日期，转换为日期的毫秒数12345678910111213141516/** * 把 String 类型的日期，转换为日期的毫秒数 * @param i * @return */public static Long stringToDateMillis(String i)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm\");//24小时制 long timeMillis = 0; try &#123; timeMillis = simpleDateFormat.parse(i).getTime(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return timeMillis;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"时间","slug":"时间","permalink":"http://yoursite.com/tags/时间/"}]},{"title":"BLE 开发知识","slug":"BLE 开发知识","date":"2018-07-05T05:20:32.000Z","updated":"2018-07-08T01:12:54.743Z","comments":true,"path":"2018/07/05/BLE 开发知识/","link":"","permalink":"http://yoursite.com/2018/07/05/BLE 开发知识/","excerpt":"开发流程声明 BLE 权限在 AndroidManifest 中添加： 12345&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;!-- 6.0 之后需要位置权限--&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;","text":"开发流程声明 BLE 权限在 AndroidManifest 中添加： 12345&lt;uses-permission android:name=\"android.permission.BLUETOOTH\" /&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt;&lt;!-- 6.0 之后需要位置权限--&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; 获取 BluetoothAdapter 实例12345678910111213141516171819202122/** * 初始化本地蓝牙 * * @return */private boolean initBLE() &#123; if (mBluetoothManager == null) &#123; mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); if (mBluetoothManager == null) &#123; LogUtil.e(TAG, \"Unable to initialize BluetoothManager.\"); return false; &#125; &#125; mBluetoothAdapter = mBluetoothManager.getAdapter(); if (mBluetoothAdapter == null) &#123; LogUtil.e(TAG, \"Unable to obtain a BluetoothAdapter.\"); return false; &#125; return true;&#125; 动态申请定位权限Android 6.0 系统以上开启蓝牙还需要定位权限，定位权限属于危险权限，需要动态申请： 12345678910private void initPermission() &#123; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123; …………………… //请求权限 requestPermissions(new String[]&#123;Manifest.permission.WRITE_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION); &#125;&#125; 如果是在 Fragment 中使用，则是 xxxFragment.this.requestPermissions requestPermissions 的回调方法是 123456789@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_ACCESS_COARSE_LOCATION: Toast.makeText(getActivity(), \"已经可以定位了\", Toast.LENGTH_SHORT).show(); &#125;&#125; 请求位置服务判断是否开启定位功能1234567891011121314/** * 开启定位功能 * @param context * @return */private static boolean isLocationEnable(Context context) &#123; LocationManager locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE); boolean networkProvider = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER); boolean gpsProvider = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER); if (networkProvider || gpsProvider) &#123; return true; &#125; return false;&#125; 开启定位服务123456789/** * 获取定位服务 * * @param context */private static void setLocationService(Context context) &#123; Intent locationIntent = new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS); ((Activity) context).startActivityForResult(locationIntent, Global.REQUEST_CODE_LOCATION_SETTINGS);&#125; 扫描设备在 android 6.0 中，使用 BluetoothLeScanner.startScan() 来扫描的： 123456789101112131415161718192021222324252627282930313233343536/** * 扫描 BLE 设备 * @param enable */public void scanDevices(boolean enable) &#123; LogUtil.i(TAG, \"BluetoothAdapter 状态：\" + mBluetoothAdapter.getState()); if (enable) &#123; /*new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; mBluetoothAdapter.getBluetoothLeScanner().stopScan(mScanCallback); &#125; &#125;, 3000);*/ LogUtil.i(TAG, \"正在搜索设备…………\"); mBluetoothAdapter.getBluetoothLeScanner().startScan(mScanCallback); &#125; else &#123; LogUtil.i(TAG, \"停止搜索设备\"); mBluetoothAdapter.getBluetoothLeScanner().stopScan(mScanCallback); &#125;&#125;private ScanCallback mScanCallback = new ScanCallback() &#123; @Override public void onScanResult(int callbackType, ScanResult result) &#123; super.onScanResult(callbackType, result); Bundle data = new Bundle(); data.putParcelable(BluetoothDevice.EXTRA_DEVICE, result.getDevice()); Intent intent = new Intent(); intent.setAction(ACTION_DEVICE_FOUND); intent.putExtras(data); sendBroadcast(intent); &#125;&#125;; 注册广播123456789101112131415/** * 初始化广播 */private void initBroadcastReceiver() &#123; IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); intentFilter.addAction(BluetoothService.ACTION_DEVICE_FOUND); intentFilter.addAction(BluetoothService.ACTION_GATT_SERVICES_DISCOVERED_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_DESCRIPTOR_WRITE_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_CHARACTERISTIC_WRITE_SUCCESS); intentFilter.addAction(BluetoothService.ACTION_GATT_CHARACTERISTIC_DATA_REPLY); registerReceiver(broadcastReceiver, intentFilter);&#125; 123456789101112/** * 广播接收器 */private BroadcastReceiver broadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) &#123; ………… &#125; &#125; 连接设备需要获取 BluetoothGATT 再进行操作： 1234567891011121314151617181920212223242526/** * 连接目标 BLE 设备 * * @param address * @return */public boolean connect(final String address) &#123; if (mBluetoothAdapter == null || address == null) &#123; LogUtil.e(TAG, \"BluetoothAdapter not initialized or unspecified address.\"); return false; &#125; final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address); if (device == null) &#123; LogUtil.e(TAG, \"Device not found. Unable to connect.\"); return false; &#125; // We want to directly connect to the device, so we are setting the autoConnect // parameter to false. mBluetoothGatt = device.connectGatt(this, false, mGattCallback); LogUtil.i(TAG, \"成功连接上设备：\" + device.getName()); LogUtil.i(TAG, \"------------Create a new connection.------------\"); return true;&#125; 当 GATT 客户端连接上或者连接状态改变时，调用 onConnectionStateChange。 如果使用：device.connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback, int transport) 根据源码 @param transport preferred transport for GATT connections to remote dual-mode devices跟双模设备连接，transport 如果不传默认 TRANSPORT_AUTO，6.0系统及以上需要使用 TRANSPORT_LE 这种传输模式。 发现服务当使用 mBluetoothGatt.discoverServices() 时，则调用 onServicesDiscovered。 获取 BluetoothGattService 和 BluetoothGattCharacteristic12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 获取 BluetoothGattService * * @param bluetoothGatt * @param uuid_service * @return */ private BluetoothGattService getBluetoothGATTService(BluetoothGatt bluetoothGatt, UUID uuid_service) &#123; if (mBluetoothGatt != null) &#123; BluetoothGattService bluetoothGattService = mBluetoothGatt.getService(uuid_service); if (bluetoothGattService != null) &#123; //LogUtil.i(TAG, \"成功获取 bluetoothGattService：\" + uuid_service); return bluetoothGattService; &#125; else &#123; LogUtil.e(TAG, \"bluetoothgatt get service uuid:\" + uuid_service + \" is null\"); &#125; &#125; else &#123; LogUtil.e(TAG, \"mBluetoothGatt is null\"); &#125; return null; &#125; /** * 获取 BluetoothGattCharacteristic * * @param bluetoothGattService * @param uuid_characteristic * @return */ private BluetoothGattCharacteristic getBluetoothGattCharacteristic(BluetoothGattService bluetoothGattService, UUID uuid_characteristic) &#123; if (bluetoothGattService != null) &#123; BluetoothGattCharacteristic bluetoothGattCharacteristic = bluetoothGattService.getCharacteristic(uuid_characteristic); if (bluetoothGattCharacteristic != null) &#123; //LogUtil.i(TAG, \"成功获取 bluetoothGattCharacteristic：\" + uuid_characteristic); return bluetoothGattCharacteristic; &#125; else &#123; LogUtil.e(TAG, \"bluetoothGattService get characteristic uuid:\" + uuid_characteristic + \" is null\"); &#125; &#125; else &#123; LogUtil.e(TAG, \"bluetoothGattService is null\"); &#125; return null; &#125; 开启通知，并且写入 DescriptorWriteCharacteristic() 后有数据返回，则需要先： 12345678910111213141516171819202122232425/** * 设置 Characteristic 通知属性，并且写上 Descriptor */ private void setCharacteristicNotifyAndWriteDescriptor(UUID uuid_service, UUID uuid_characteristic, UUID uuid_descriptor) &#123; BluetoothGattService mBluetoothGattService = getBluetoothGATTService(mBluetoothGatt, uuid_service); BluetoothGattCharacteristic mBluetoothGattCharacteristic = getBluetoothGattCharacteristic(mBluetoothGattService, uuid_characteristic); if (mBluetoothGatt != null &amp;&amp; mBluetoothGattCharacteristic != null) &#123; mBluetoothGatt.setCharacteristicNotification(mBluetoothGattCharacteristic, true); BluetoothGattDescriptor mBluetoothGattDescriptor = mBluetoothGattCharacteristic.getDescriptor(uuid_descriptor); if (mBluetoothGattDescriptor != null) &#123; LogUtil.i(TAG, \"成功设置 mBluetoothGattDescriptor\"); mBluetoothGattDescriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); mBluetoothGatt.writeDescriptor(mBluetoothGattDescriptor); &#125; &#125; else if (mBluetoothGatt == null) &#123; LogUtil.e(TAG, \"mBluetoothGatt is null\"); &#125; else if (mBluetoothGattCharacteristic == null) &#123; LogUtil.e(TAG, \"mBluetoothGattCharacteristic is null\"); &#125; &#125; 然后会回调 onDescriptorWrite 写入 Characteristic12345678910111213141516171819202122/** * 写入 Characteristic * @param uuid_service * @param uuid_characteristic * @param value */private void writeCharacteristic(UUID uuid_service, UUID uuid_characteristic, byte[] value) &#123; BluetoothGattService mBluetoothGattService = getBluetoothGATTService(mBluetoothGatt, uuid_service); BluetoothGattCharacteristic mBluetoothGattCharacteristic = getBluetoothGattCharacteristic(mBluetoothGattService, uuid_characteristic); if (mBluetoothGatt != null &amp;&amp; mBluetoothGattCharacteristic != null) &#123; mBluetoothGattCharacteristic.setValue(value); mBluetoothGattCharacteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE); mBluetoothGatt.writeCharacteristic(mBluetoothGattCharacteristic); &#125;else if (mBluetoothGatt == null) &#123; LogUtil.e(TAG, \"mBluetoothGatt is null\"); &#125; else if (mBluetoothGattCharacteristic == null) &#123; LogUtil.e(TAG, \"mBluetoothGattCharacteristic is null\"); &#125;&#125; 则先回调 onCharacteristicWrite，然后回调 onCharacteristicChanged。 BluetoothGatt 的回调1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * BluetoothGatt 的回调 */private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; super.onConnectionStateChange(gatt, status, newState); if (newState == BluetoothProfile.STATE_CONNECTED) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; LogUtil.i(TAG, \"Connected To GATT Server\"); LogUtil.i(TAG, \"Attempting To Start Service Discovery:\" + mBluetoothGatt.discoverServices()); broadcastUpdate(ACTION_GATT_CONNECTED); &#125; else &#123; disconnect(); close(); &#125; &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123; close(); &#125; &#125; @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; super.onServicesDiscovered(gatt, status); LogUtil.i(TAG, \"onServicesDiscovered received: \" + status); if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED_SUCCESS); &#125; else &#123; LogUtil.i(TAG, \"onServicesDiscovered received: \" + status); &#125; &#125; @Override public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorWrite(gatt, descriptor, status); if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_DESCRIPTOR_WRITE_SUCCESS); &#125; &#125; @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicWrite(gatt, characteristic, status); if (status == BluetoothGatt.GATT_SUCCESS)&#123; broadcastUpdate(ACTION_GATT_CHARACTERISTIC_WRITE_SUCCESS); //LogUtil.i(TAG, \"onCharacteristicWrite 返回的数据\" + Arrays.toString(characteristic.getValue())); &#125; &#125; @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicChanged(gatt, characteristic); LogUtil.i(TAG, \"onCharacteristicChanged 返回的数据\" + Arrays.toString(characteristic.getValue())); broadcastUpdate(ACTION_GATT_CHARACTERISTIC_DATA_REPLY, KEY_HOUR_DATA, characteristic.getValue()); &#125; @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicRead(gatt, characteristic, status); &#125; @Override public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; super.onDescriptorRead(gatt, descriptor, status); &#125;&#125;; 发送广播12345678910111213141516/** * 发送广播 * * @param action */private void broadcastUpdate(final String action) &#123; final Intent intent = new Intent(action); sendBroadcast(intent);&#125;private void broadcastUpdate(final String action, String key, byte[] value)&#123; final Intent intent = new Intent(action); intent.putExtra(key, value); sendBroadcast(intent);&#125; 参考资料 Android蓝牙4.0 BLE开发坑总结 Android BLE 多次writeCharacteristic 为什么只有一个回调","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"BLE","slug":"Android/BLE","permalink":"http://yoursite.com/categories/Android/BLE/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"BLE 4.0","slug":"BLE-4-0","permalink":"http://yoursite.com/tags/BLE-4-0/"}]},{"title":"BLE 手环开发总结","slug":"手环开发总结","date":"2018-07-05T03:04:25.000Z","updated":"2018-07-07T03:18:41.601Z","comments":true,"path":"2018/07/05/手环开发总结/","link":"","permalink":"http://yoursite.com/2018/07/05/手环开发总结/","excerpt":"基础功能 显示步数、距离、卡路里、电量、目标完成状况","text":"基础功能 显示步数、距离、卡路里、电量、目标完成状况 功能实现过程 通过手机蓝牙与手环连接，手机 APP 发送个人设置数据给手环；当手环接收数据成功后，更新用户信息，同时返回当前时刻到上一次同步数据时刻的数据（注：数据以1小时为单位，返回的每个1小时数据是每个1小时的累计数据)，这次返回的数据中含有掉电标志字节，用于判断本次数据同步是正常还是掉电后重新上电后的第一次同步。 手机 APP 发送请求同步手环屏幕当前显示数据的数据给手环；手环接收数据成功后，返回步数、距离、卡路里、电量的数据。 手机 APP 发送请求同步手环72个小时数据的数据给手环；手环接收数据成功后，返回步数、卡路里、每个小时的 UTC 秒数的数据。 开发辅助数据库框架greenDAO 简书上面的参考资料： Android Study 之 玩转GreenDao 3.2.2 点滴提升逼格~ 数据库调试Android-Debug-Database 智能刷新框架SmartRefreshLayout 图表显示框架MPAndroidChart CSDN 上面的两篇参考资料： Android图表控件MPAndroidChart的简单介绍（MPAndroidChart3.0 MPAndroidChart 教程 Fragment 切换指示器SpringIndicator 自定义选择器框架AndroidPicker 遇到的问题 BLE 以6.0版本为界限的开发流程、GATT 规范 Java 获取当前时间以及各种转换 ViewPager + Fragment 使用 Activity 和 Fragment 跳转、数据交互 BottomNavigationView 使用 Broadcast 使用 Service 使用 Intent 使用 异步使用 enum 自定义 View 参考：仿支付宝芝麻信用的仪表盘安卓自定义View教程 Fragment 的 add、hide、show。简书收藏几篇文章 由于手环储存的步数数据仅为1个小时的累计，所以当用图表显示月、年的时候，需要对数据进行处理 实时监控手机的网络、蓝牙状态变化 蓝牙、定位、位置服务权限申请 byte[] 数组对应天数开关处理 Fragment 的接口回调 自定义一个 NoScrollViewPagerAdapter 自定义一个 LogUtil RecyclerView 使用 Bundle 使用 改进 引入 ButterKnife 使用异步加载图表数据，现在加载月、年数据比较慢 同步时间过长之后，再次同步一次会出现数据错乱情况 引入网络数据 引入 Google 的 easypermissions 作为权限获取库","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"BLE 4.0","slug":"BLE-4-0","permalink":"http://yoursite.com/tags/BLE-4-0/"}]},{"title":"ICON 资源网站","slug":"ICON 资源网站","date":"2018-07-05T02:50:21.000Z","updated":"2018-07-05T02:59:24.522Z","comments":true,"path":"2018/07/05/ICON 资源网站/","link":"","permalink":"http://yoursite.com/2018/07/05/ICON 资源网站/","excerpt":"","text":"Android Asset Studio Material Palette easyicon","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ICON","slug":"ICON","permalink":"http://yoursite.com/tags/ICON/"}]},{"title":"MPAndroidChart 翻译","slug":"MPAndroidChart 翻译","date":"2018-07-02T04:39:10.000Z","updated":"2018-07-08T01:12:54.753Z","comments":true,"path":"2018/07/02/MPAndroidChart 翻译/","link":"","permalink":"http://yoursite.com/2018/07/02/MPAndroidChart 翻译/","excerpt":"","text":"MPAndroidChart 开始本章介绍使用此库的基本设置。 添加依赖作为第一步，将该库的依赖项添加到您的项目中。 如何添加依赖已经在此存储库的用法部分中进行了介绍。 推荐使用 Gradle 方式作为添加依赖的方式。 创建界面使用 LineChart, BarChart, ScatterChart, CandleStickChart, PieChart, BubbleChart or RadarChart ，在 .xml 中定义：1234&lt;com.github.mikephil.charting.charts.LineChart android:id=\"@+id/chart\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 然后从 Activity, Fragment or whatever 中取回：12// in this example, a LineChart is initialized from xmlLineChart chart = (LineChart) findViewById(R.id.chart); 或者使用代码来创建（跟着在 layout 添加）123456// programmatically create a LineChartLineChart chart = new LineChart(Context);// get a layout defined in xmlRelativeLayout rl = (RelativeLayout) findViewById(R.id.relativeLayout);rl.add(chart); // add the programmatically created chart 添加数据在获得图表实例后，你可以创建数据并且添加到图表。这个例子使用的是 LineChart，Entry 类代表图表中一个点的 X，Y 坐标。其他图表类型，例如 BarChart 使用 BarEntry。添加数据到图表，将每一个数据代入到 Entry 中，例如：123456789YourData[] dataObjects = ...;List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;();for (YourData data : dataObjects) &#123; // turn your data into Entry objects entries.add(new Entry(data.getValueX(), data.getValueY()));&#125; 下一步，将 List 添加到 LineDataSet。DataSet 对象保存数据，同时允许单独设置数据的样式。如果启用，下面使用的“标签”仅具有描述性目的，并显示在图表中。123LineDataSet dataSet = new LineDataSet(entries, \"Label\"); // add entries to datasetdataSet.setColor(...);dataSet.setValueTextColor(...); // styling, ... 最后一步，添加 LineDataSet 对象到 LineData 对象。这个对象持有 chart 实例的所有数据，并允许有单独样式。在你建立数据对象后，你可以使用它建立图表并刷新：123LineData lineData = new LineData(dataSet);chart.setData(lineData);chart.invalidate(); // refresh 请考虑到上面的仅仅是基本应用。需要更详细的扩展应用，请参考 setting data 部分，其中有很多添加数据到不同 chart 类型图表的例子。 样式有关图表外观和数据的设置和样式的信息，请参考 general settings &amp; styling 部分。关于单个图表类型的更具体的样式和设置，请参考 specific settings &amp; styling。 与图表交互该库允许您完全自定义与图表视图的可能触摸（和手势）交互，并通过回调方法对交互作出反应。 启用/禁用交互 setTouchEnabled(boolean enabled) 允许启用/禁用与图表的所有可能的触摸交互。 setDragEnabled(boolean enabled) 启用/禁用图表的拖动（平移）。 setScaleEnabled(boolean enabled) 启用/禁用两个轴上的图表缩放。 setScaleXEnabled(boolean enabled) 启用/禁用 X 轴缩放。 setScaleYEnabled(boolean enabled) 启用/禁用 Y 轴缩放。 setPinchZoom(boolean enabled) 如果设置为 true，则启用缩放。如果禁用，则可以单独缩放 X 轴和 Y 轴。 setDoubleTapToZoomEnabled(boolean enabled) 将此设置为 false 以禁止通过双击来缩放图表。 图表抛物线/减速 setDragDecelerationEnabled(boolean enabled) 如果设置为 true，则图表会在触摸后继续滚动。 默认值：true。 setDragDecelerationFrictionCoef(float coef) 减速摩擦系数在 [0; 1] 之间，较高的值表示速度将缓慢下降，例如，如果设置为 0，它将立即停止。 1 是无效值，将自动转换为 0.9999。 突出显示值如何允许通过点击手势和编程方式，突出显示条目在 highlightning section 中进行了描述。 手势回调OnChartGestureListener 将允许您对图表上的手势做出反应： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface OnChartGestureListener &#123; /** * Callbacks when a touch-gesture has started on the chart (ACTION_DOWN) * * @param me * @param lastPerformedGesture */ void onChartGestureStart(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when a touch-gesture has ended on the chart (ACTION_UP, ACTION_CANCEL) * * @param me * @param lastPerformedGesture */ void onChartGestureEnd(MotionEvent me, ChartTouchListener.ChartGesture lastPerformedGesture); /** * Callbacks when the chart is longpressed. * * @param me */ public void onChartLongPressed(MotionEvent me); /** * Callbacks when the chart is double-tapped. * * @param me */ public void onChartDoubleTapped(MotionEvent me); /** * Callbacks when the chart is single-tapped. * * @param me */ public void onChartSingleTapped(MotionEvent me); /** * Callbacks then a fling gesture is made on the chart. * * @param me1 * @param me2 * @param velocityX * @param velocityY */ public void onChartFling(MotionEvent me1, MotionEvent me2, float velocityX, float velocityY); /** * Callbacks when the chart is scaled / zoomed via pinch zoom gesture. * * @param me * @param scaleX scalefactor on the x-axis * @param scaleY scalefactor on the y-axis */ public void onChartScale(MotionEvent me, float scaleX, float scaleY); /** * Callbacks when the chart is moved / translated via drag gesture. * * @param me * @param dX translation distance on the x-axis * @param dY translation distance on the y-axis */ public void onChartTranslate(MotionEvent me, float dX, float dY);&#125; 只需让你接收回调的类实现这个接口，并将其设置为图表的监听器：1chart.setOnChartGestureListener(this); 高亮显示值本节重点介绍通过 tap-gesture 和基于发行版 v3.0.0 以编程方式，高亮显示图表中条目的主题。 启用/禁用高亮显示 setHighlightPerDragEnabled(boolean enabled) 在图表上将此设置为 true，以便在完全缩小时，在图表表面上进行每次拖动时高亮显示。 默认值： true setHighlightPerTapEnabled(boolean enabled) 在图表上将此设置为 false，以防止通过点击手势高亮显示值。 但仍可通过拖动或以编程方式高亮显示值。 默认值： true setMaxHighlightDistance(float distanceDp) 在 dp 中设置最大的高光距离。在图表上轻敲远离条目的距离，不会触发高亮显示。 默认值： 500dp 除此之外，还可以为各个 DataSet 对象配置高亮显示：123456dataSet.setHighlightEnabled(true); // allow highlighting for DataSet // set this to false to disable the drawing of highlight indicator (lines) dataSet.setDrawHighlightIndicators(true); dataSet.setHighlightColor(Color.BLACK); // color for highlight indicator // and more... 以编程方式突出显示 highlightValue(float x, int dataSetIndex, boolean callListener) 高亮显示给定 DataSet 中给定 x位置的值。 提供 -1 作为 dataSetIndex 以撤消所有高亮显示。布尔标志确定是否应该调用选择侦听器。 highlightValue(Highlight high, boolean callListener) 高亮显示提供的 Highlight对象 所代表的值。提供 null 以撤消所有高亮显示。布尔标志确定是否应该调用选择侦听器。 highlightValues(Highlight[] highs) 高亮显示给定 Highlight [] 数组所表示的值。提供 null 或空数组以撤消所有高亮显示。 getHighlighted() 返回 Highlight [] 数组，其中包含有关所有高亮显示的条目，x-index 和 dataset-index 的信息。 选择回调该库在交互时为回调提供了许多侦听器。 其中一个是 OnChartValueSelectedListener，用于通过触控高亮显示值时的回调： 1234567891011121314 public interface OnChartValueSelectedListener &#123; /** * Called when a value has been selected inside the chart. * * @param e The selected Entry. * @param h The corresponding highlight object that contains information * about the highlighted position */ public void onValueSelected(Entry e, Highlight h); /** * Called when nothing has been selected or an \"un-select\" has been made. */ public void onNothingSelected();&#125; 只需让你的接收回调的类，实现这个接口并将其设置为图表的监听器：chart.setOnChartValueSelectedListener(this); 高亮的类Highlight类 表示与高亮显示的 Entry 关联的所有数据，例如高亮显示的 Entry对象 本身，它所属的 DataSet，它在绘图表面上的位置等等。它可用于获取有关已高亮显示的条目的信息，或用于向图表提供要高亮显示的条目的信息。关于这个目的，Highlight类 提供了两个构造函数：12345/** constructor for standard highlight */public Highlight(float x, int dataSetIndex) &#123; ... &#125;/** constructor for stacked BarEntry highlight */public Highlight(float x, int dataSetIndex, int stackIndex) &#123; ... &#125; 这些构造函数可用于创建 Highlight对象，该对象允许以编程方式执行突出显示：1234// highlight the entry and x-position 50 in the first (0) DataSetHighlight highlight = new Highlight(50f, 0);chart.highlightValue(highlight, false); // highlight this value, don't call listener 自定义高亮所有用户输入的高亮手势形式，都由默认的 ChartHighlighter类 在内部处理。使用以下方法，用自定义实现替换默认的 highligher： setHighlighter（ChartHighlighter highlighter） 为图表设置自定义 highligher对象，以处理在图表视图上执行的所有高亮触摸事件。您自定义的 highlighter对象 需要继承 ChartHighlighter类。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Chart","slug":"Android/Chart","permalink":"http://yoursite.com/categories/Android/Chart/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Chart","slug":"Chart","permalink":"http://yoursite.com/tags/Chart/"},{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"JSON 数据解析","slug":"JSON 数据解析","date":"2018-06-25T18:21:16.000Z","updated":"2018-07-08T01:12:54.753Z","comments":true,"path":"2018/06/26/JSON 数据解析/","link":"","permalink":"http://yoursite.com/2018/06/26/JSON 数据解析/","excerpt":"JSONObject 及 JSONArray 取值String 转 JSONObject 或 JSONArrayJSONArray jsonArray = JSONArray.fromObject(str); JSONObject jsonObject = JSONObject.fromObject(str);","text":"JSONObject 及 JSONArray 取值String 转 JSONObject 或 JSONArrayJSONArray jsonArray = JSONArray.fromObject(str); JSONObject jsonObject = JSONObject.fromObject(str); JSONObject 中获取 JSONArray 或 StringJSONObject jsonObject = new JSONObject(resource); String str = jsonObject.getString(&quot;str&quot;); //获取 sequences的值 JSONArray sequencesArray = jsonObject.getJSONArray(&quot;sequences&quot;); JSONObject 中还有其它 get 方法。 JSONArray 中获取 JSONObject 或 StringJSONArray jsonArray = new JSONArray(resource); String str = jsonArray.getString(0); JSONObject jsonObject = jsonArray.getJSONObject(0); 解析 json 格式的数据时要看清楚，最外面为 { 的是 JSONObject ，为 [ 的是JSONArray。 实例JSONArray 中获取 JSONObject1234567891011121314151617181920212223242526272829303132public class Province extends DataSupport &#123; private int id; private String provinceName; private int provinceCode; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getProvinceName() &#123; return provinceName; &#125; public void setProvinceName(String provinceName) &#123; this.provinceName = provinceName; &#125; public int getProvinceCode() &#123; return provinceCode; &#125; public void setProvinceCode(int provinceCode) &#123; this.provinceCode = provinceCode; &#125;&#125; 1JSON 数组 [&#123;&quot;id&quot;:1, &quot;name&quot;:北京&#125;,&#123;&quot;id&quot;:2, &quot;name&quot;:上海&#125;,&#123;&quot;id&quot;:3, &quot;name&quot;:天津&#125;,&#123;&quot;id&quot;:4, &quot;name&quot;:重庆&#125;,&#123;&quot;id&quot;:5, &quot;name&quot;:香港&#125;] 123456789101112131415161718public static boolean handleProvinceResponse(String response) &#123; if (!TextUtils.isEmpty(response)) &#123; try &#123; JSONArray allProvinces = new JSONArray(response); for (int i = 0; i &lt; allProvinces.length(); i++) &#123; JSONObject provinceObject = allProvinces.getJSONObject(i); Province province = new Province(); province.setProvinceName(provinceObject.getString(\"name\")); province.setProvinceCode(provinceObject.getInt(\"id\")); province.save(); &#125; return true; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125; JSONObject 中获取 JSONArray，然后在从 JSONArray 中获取 JSONObject12345678910111213141516public class Weather &#123; public String status; public Basic basic; public AQI aqi; public Now now; public Suggestion suggestion; @SerializedName(\"daily_forecast\") public List&lt;Forecast&gt; forecastList;&#125; 1&#123;&quot;HeWeather&quot;: [&#123;&quot;basic&quot;:&#123;&quot;cid&quot;:&quot;CN101300105&quot;,&quot;location&quot;:&quot;隆安&quot;,&quot;parent_city&quot;:&quot;南宁&quot;,&quot;admin_area&quot;:&quot;广西&quot;,&quot;cnty&quot;:&quot;中国&quot;,&quot;lat&quot;:&quot;23.17476273&quot;,&quot;lon&quot;:&quot;107.68865967&quot;,&quot;tz&quot;:&quot;+8.00&quot;,&quot;city&quot;:&quot;隆安&quot;,&quot;id&quot;:&quot;CN101300105&quot;,&quot;update&quot;:&#123;&quot;loc&quot;:&quot;2018-05-02 11:47&quot;,&quot;utc&quot;:&quot;2018-05-02 03:47&quot;&#125;&#125;,&quot;update&quot;:&#123;&quot;loc&quot;:&quot;2018-05-02 11:47&quot;,&quot;utc&quot;:&quot;2018-05-02 03:47&quot;&#125;,&quot;status&quot;:&quot;ok&quot;,&quot;now&quot;:&#123;&quot;cloud&quot;:&quot;25&quot;,&quot;cond_code&quot;:&quot;300&quot;,&quot;cond_txt&quot;:&quot;阵雨&quot;,&quot;fl&quot;:&quot;32&quot;,&quot;hum&quot;:&quot;71&quot;,&quot;pcpn&quot;:&quot;0.0&quot;,&quot;pres&quot;:&quot;1014&quot;,&quot;tmp&quot;:&quot;29&quot;,&quot;vis&quot;:&quot;10&quot;,&quot;wind_deg&quot;:&quot;107&quot;,&quot;wind_dir&quot;:&quot;东南风&quot;,&quot;wind_sc&quot;:&quot;1&quot;,&quot;wind_spd&quot;:&quot;4&quot;,&quot;cond&quot;:&#123;&quot;code&quot;:&quot;300&quot;,&quot;txt&quot;:&quot;阵雨&quot;&#125;&#125;,&quot;daily_forecast&quot;:[&#123;&quot;date&quot;:&quot;2018-05-02&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;中雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;30&quot;,&quot;min&quot;:&quot;23&quot;&#125;&#125;,&#123;&quot;date&quot;:&quot;2018-05-03&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;阵雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;27&quot;,&quot;min&quot;:&quot;22&quot;&#125;&#125;,&#123;&quot;date&quot;:&quot;2018-05-04&quot;,&quot;cond&quot;:&#123;&quot;txt_d&quot;:&quot;阵雨&quot;&#125;,&quot;tmp&quot;:&#123;&quot;max&quot;:&quot;28&quot;,&quot;min&quot;:&quot;23&quot;&#125;&#125;],&quot;hourly&quot;:[&#123;&quot;cloud&quot;:&quot;90&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;26&quot;,&quot;hum&quot;:&quot;83&quot;,&quot;pop&quot;:&quot;58&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-02 13:00&quot;,&quot;tmp&quot;:&quot;30&quot;,&quot;wind_deg&quot;:&quot;188&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;11&quot;&#125;,&#123;&quot;cloud&quot;:&quot;95&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;24&quot;,&quot;hum&quot;:&quot;85&quot;,&quot;pop&quot;:&quot;49&quot;,&quot;pres&quot;:&quot;1010&quot;,&quot;time&quot;:&quot;2018-05-02 16:00&quot;,&quot;tmp&quot;:&quot;30&quot;,&quot;wind_deg&quot;:&quot;172&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;1&quot;&#125;,&#123;&quot;cloud&quot;:&quot;98&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;24&quot;,&quot;hum&quot;:&quot;87&quot;,&quot;pop&quot;:&quot;25&quot;,&quot;pres&quot;:&quot;1010&quot;,&quot;time&quot;:&quot;2018-05-02 19:00&quot;,&quot;tmp&quot;:&quot;29&quot;,&quot;wind_deg&quot;:&quot;173&quot;,&quot;wind_dir&quot;:&quot;南风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;8&quot;&#125;,&#123;&quot;cloud&quot;:&quot;99&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;23&quot;,&quot;hum&quot;:&quot;89&quot;,&quot;pop&quot;:&quot;20&quot;,&quot;pres&quot;:&quot;1013&quot;,&quot;time&quot;:&quot;2018-05-02 22:00&quot;,&quot;tmp&quot;:&quot;28&quot;,&quot;wind_deg&quot;:&quot;27&quot;,&quot;wind_dir&quot;:&quot;东北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;9&quot;&#125;,&#123;&quot;cloud&quot;:&quot;99&quot;,&quot;cond_code&quot;:&quot;104&quot;,&quot;cond_txt&quot;:&quot;阴&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;90&quot;,&quot;pop&quot;:&quot;71&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-03 01:00&quot;,&quot;tmp&quot;:&quot;25&quot;,&quot;wind_deg&quot;:&quot;5&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;6&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;306&quot;,&quot;cond_txt&quot;:&quot;中雨&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;93&quot;,&quot;pop&quot;:&quot;49&quot;,&quot;pres&quot;:&quot;1012&quot;,&quot;time&quot;:&quot;2018-05-03 04:00&quot;,&quot;tmp&quot;:&quot;24&quot;,&quot;wind_deg&quot;:&quot;2&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;6&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;104&quot;,&quot;cond_txt&quot;:&quot;阴&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;93&quot;,&quot;pop&quot;:&quot;34&quot;,&quot;pres&quot;:&quot;1013&quot;,&quot;time&quot;:&quot;2018-05-03 07:00&quot;,&quot;tmp&quot;:&quot;23&quot;,&quot;wind_deg&quot;:&quot;11&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;10&quot;&#125;,&#123;&quot;cloud&quot;:&quot;100&quot;,&quot;cond_code&quot;:&quot;305&quot;,&quot;cond_txt&quot;:&quot;小雨&quot;,&quot;dew&quot;:&quot;22&quot;,&quot;hum&quot;:&quot;86&quot;,&quot;pop&quot;:&quot;70&quot;,&quot;pres&quot;:&quot;1015&quot;,&quot;time&quot;:&quot;2018-05-03 10:00&quot;,&quot;tmp&quot;:&quot;23&quot;,&quot;wind_deg&quot;:&quot;3&quot;,&quot;wind_dir&quot;:&quot;北风&quot;,&quot;wind_sc&quot;:&quot;1-2&quot;,&quot;wind_spd&quot;:&quot;2&quot;&#125;],&quot;aqi&quot;:&#123;&quot;city&quot;:&#123;&quot;aqi&quot;:&quot;51&quot;,&quot;pm25&quot;:&quot;29&quot;,&quot;qlty&quot;:&quot;良&quot;&#125;&#125;,&quot;suggestion&quot;:&#123;&quot;comf&quot;:&#123;&quot;type&quot;:&quot;comf&quot;,&quot;brf&quot;:&quot;较舒适&quot;,&quot;txt&quot;:&quot;白天有雨，从而使空气湿度加大，会使人们感觉有点儿闷热，但早晚的天气很凉爽、舒适。&quot;&#125;,&quot;sport&quot;:&#123;&quot;type&quot;:&quot;sport&quot;,&quot;brf&quot;:&quot;较不宜&quot;,&quot;txt&quot;:&quot;有较强降水，建议您选择在室内进行健身休闲运动。&quot;&#125;,&quot;cw&quot;:&#123;&quot;type&quot;:&quot;cw&quot;,&quot;brf&quot;:&quot;不宜&quot;,&quot;txt&quot;:&quot;不宜洗车，未来24小时内有雨，如果在此期间洗车，雨水和路上的泥水可能会再次弄脏您的爱车。&quot;&#125;&#125;&#125;]&#125; 12345678910111213141516/** * 将返回的 JSON 数据解析成 Weather 实体类 */public static Weather parseWeatherResponse(String response) &#123; try &#123; JSONObject jsonObject = new JSONObject(response); JSONArray jsonArray = jsonObject.getJSONArray(\"HeWeather\"); String weatherContent = jsonArray.getJSONObject(0).toString(); return new Gson().fromJson(weatherContent, Weather.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]}]}